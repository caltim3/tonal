<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
  /* === DROP-IN COLOR SCHEME FIX: Make index (5) match index (74) === */

/* Light mode base */
body {
  background-color: #1f618d !important;
}
.app-section {
  background: #fff !important;
  border-radius: 10px !important;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1) !important;
}
.fretboard-container {
  background: #fff !important;
  border-radius: 10px !important;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1) !important;
}
button, .toggle-button, .control-button {
  padding: 10px 20px !important;
  border: none !important;
  border-radius: 5px !important;
  background: #4CAF50 !important;
  color: #fff !important;
  cursor: pointer !important;
  transition: all 0.3s ease !important;
}
button:hover, .toggle-button:hover, .control-button:hover {
  background: #45a049 !important;
}
select {
  padding: 5px !important;
  margin: 5px !important;
  border-radius: 5px !important;
  border: 1px solid #ddd !important;
}
#tempo-display {
  font-size: 1.2em !important;
  font-weight: bold !important;
  margin: 0 10px !important;
}
.beat {
  background: #9E9E9E !important;
  color: #fff !important;
}
.beat.active {
  transform: translateY(-10px) !important;
}
.measure {
  background-color: #e9ecef !important;
  border-radius: 4px !important;
  transition: opacity 0.2s ease !important;
}
.measure.active {
  background-color: #c3e6cb !important;
  border: 2px solid #28a745 !important;
}
.measure-number {
  color: #333 !important;
}
.fretboard-section {
  border: 1px solid #ccc !important;
  background-color: #f9f9f9 !important;
  border-radius: 8px !important;
}
.scale-display {
  font-size: 1.1em !important;
  font-weight: bold !important;
  margin-bottom: 10px !important;
  text-align: center !important;
}
.fretboard {
  background-color: #FFCF79 !important;
  border: 2px solid #4B1C2E !important;
  border-radius: 5px !important;
}
.note {
  background-color: #4CAF50 !important;
  color: #fff !important;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
}
.note:hover {
  transform: scale(1.2) !important;
  background-color: #45a049 !important;
}
.note.root-note-highlight {
  background-color: #BD2031 !important;
}
.note.scale-note-highlight {
  background-color: #006400 !important;
}
.note.note-active-feedback {
  background-color: #BD2031 !important;
}
.volume-control {
  color: #333 !important;
}
#dark-mode-toggle.active {
  background-color: #283618 !important;
  color: #fefae0 !important;
  border: 1px solid #dda15e !important;
}

/* --- DARK MODE 1 --- */
body.dark-mode {
  background-color: #283618 !important;
  color: #fefae0 !important;
}
body.dark-mode .app-section,
body.dark-mode #fretflow-section {
  background: linear-gradient(145deg, #283618, #606c38) !important;
  color: #fefae0 !important;
  border-radius: 12px !important;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3) !important;
}
body.dark-mode .fretboard-container {
  background-color: #606c38 !important;
  border: 1px solid #dda15e !important;
}
body.dark-mode .fretboard {
  background-color: #dda15e !important;
  border: 2px solid #4b4b4b !important;
}
body.dark-mode .note {
  background-color: #dda15e !important;
  color: #283618 !important;
}
body.dark-mode .note:hover {
  background-color: #bc6c25 !important;
}
body.dark-mode .scale-display {
  color: #fefae0 !important;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5) !important;
}
body.dark-mode button, body.dark-mode .toggle-button, body.dark-mode .control-button {
  background-color: #dda15e !important;
  color: #283618 !important;
  border: 1px solid #bc6c25 !important;
}
body.dark-mode button:hover, body.dark-mode .toggle-button:hover, body.dark-mode .control-button:hover {
  background-color: #bc6c25 !important;
}
body.dark-mode select {
  background-color: #dda15e !important;
  color: #283618 !important;
  border: 1px solid #bc6c25 !important;
}
body.dark-mode .measure {
  background-color: #606c38 !important;
  color: #fefae0 !important;
  border: 1px solid #dda15e !important;
}
body.dark-mode .measure.active {
  background-color: #dda15e !important;
  border-color: #bc6c25 !important;
}
body.dark-mode .beat {
  background-color: #dda15e !important;
  color: #283618 !important;
}
body.dark-mode .beat.active {
  background-color: #bc6c25 !important;
  transform: translateY(-5px) !important;
}
body.dark-mode .volume-control {
  color: #fefae0 !important;
}
body.dark-mode .volume-control input[type="range"] {
  background: #606c38 !important;
}
body.dark-mode .volume-control input[type="range"]::-webkit-slider-thumb {
  background: #dda15e !important;
  border: 1px solid #bc6c25 !important;
}

/* --- DARK MODE 2 --- */
body.dark-mode-2 {
  background-color: #0a1128 !important;
  color: #fefcfb !important;
}
body.dark-mode-2 .app-section,
body.dark-mode-2 #fretflow-section {
  background: linear-gradient(145deg, #001f54, #034078) !important;
  color: #fefcfb !important;
}
body.dark-mode-2 .fretboard-container {
  background-color: #034078 !important;
  border: 1px solid #1282a2 !important;
}
body.dark-mode-2 .fretboard {
  background-color: #001f54 !important;
  border: 2px solid #1282a2 !important;
}
body.dark-mode-2 .note {
  background-color: #1282a2 !important;
  color: #fefcfb !important;
}
body.dark-mode-2 .note:hover {
  background-color: #034078 !important;
}
body.dark-mode-2 .scale-display {
  color: #fefcfb !important;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5) !important;
}
body.dark-mode-2 button, body.dark-mode-2 .toggle-button, body.dark-mode-2 .control-button {
  background-color: #1282a2 !important;
  color: #fefcfb !important;
  border: 1px solid #034078 !important;
}
body.dark-mode-2 button:hover, body.dark-mode-2 .toggle-button:hover, body.dark-mode-2 .control-button:hover {
  background-color: #034078 !important;
}
body.dark-mode-2 select {
  background-color: #034078 !important;
  color: #fefcfb !important;
  border: 1px solid #1282a2 !important;
}
body.dark-mode-2 .measure {
  background-color: #034078 !important;
  color: #fefcfb !important;
  border: 1px solid #1282a2 !important;
}
body.dark-mode-2 .measure.active {
  background-color: #1282a2 !important;
  border-color: #fefcfb !important;
}
body.dark-mode-2 .beat {
  background-color: #1282a2 !important;
  color: #fefcfb !important;
}
body.dark-mode-2 .beat.active {
  background-color: #034078 !important;
  transform: translateY(-5px) !important;
}

/* --- DARK MODE 3 --- */
body.dark-mode-3 {
  background-color: #6b705c !important;
  color: #ffe8d6 !important;
}
body.dark-mode-3 .app-section,
body.dark-mode-3 #fretflow-section {
  background: linear-gradient(145deg, #6b705c, #a5a58d) !important;
  color: #ffe8d6 !important;
}
body.dark-mode-3 .fretboard-container {
  background-color: #606c38 !important;
  border: 1px solid #cb997e !important;
}
body.dark-mode-3 .fretboard {
  background-color: #cb997e !important;
  border: 2px solid #6b705c !important;
}
body.dark-mode-3 .note {
  background-color: #b7b7a4 !important;
  color: #6b705c !important;
}
body.dark-mode-3 .note:hover {
  background-color: #cb997e !important;
}
body.dark-mode-3 .scale-display {
  color: #ffe8d6 !important;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5) !important;
}
body.dark-mode-3 button, body.dark-mode-3 .toggle-button, body.dark-mode-3 .control-button {
  background-color: #cb997e !important;
  color: #ffe8d6 !important;
  border: 1px solid #6b705c !important;
}
body.dark-mode-3 button:hover, body.dark-mode-3 .toggle-button:hover, body.dark-mode-3 .control-button:hover {
  background-color: #6b705c !important;
}
body.dark-mode-3 select {
  background-color: #ddbea9 !important;
  color: #6b705c !important;
  border: 1px solid #cb997e !important;
}
body.dark-mode-3 .measure {
  background-color: #a5a58d !important;
  color: #ffe8d6 !important;
  border: 1px solid #cb997e !important;
}
body.dark-mode-3 .measure.active {
  background-color: #ddbea9 !important;
  border-color: #cb997e !important;
}
body.dark-mode-3 .beat {
  background-color: #ddbea9 !important;
  color: #6b705c !important;
}
body.dark-mode-3 .beat.active {
  background-color: #cb997e !important;
  transform: translateY(-5px) !important;
}
body.dark-mode-3 .volume-control {
  color: #ffe8d6 !important;
}
#dark-mode-toggle.active-3 {
  background-color: #cb997e !important;
  color: #ffe8d6 !important;
  border: 1px solid #6b705c !important;
}
    
    </style>
</head>
<body>
    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <div class="controls"> <!-- Added a controls div for top bar items -->
            <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
            <div class="volume-control">
                <span>Fretboard Volume:</span>
                <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
            </div>
        </div>
        <div class="fretboard-container">
            <div class="scale-display" id="scale-display">C Major</div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click beats to customize pattern, or select sound type.</h3>
        <div class="controls">
            <div class="control-group">
                <label for="time-signature">Time Sig:</label>
                <select id="time-signature" aria-label="Select time signature">
                    <option value="2/4">2/4</option>
                    <option value="3/4">3/4</option>
                    <option value="4/4" selected>4/4</option>
                    <option value="6/8">6/8</option>
                    <option value="7/8">7/8</option>
                    <option value="8/8">8/8</option>
                    <option value="12/8">12/8</option>
                </select>
            </div>
            <div class="control-group">
                <label for="sound-type">Sound:</label>
                <select id="sound-type" aria-label="Select metronome sound">
                    <option value="click">Click</option>
                    <option value="woodblock">Woodblock</option>
                    <option value="drums">Drums</option>
                </select>
            </div>
            <button id="drumSetToggleBtn" class="toggle-button" style="display:none;">Default Kit</button> <!-- Hidden by default, JS will show if soundType is drums -->
            <div class="volume-control">
                <label for="metronome-volume">Metro Vol:</label>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
        </div>
        <div class="controls">
             <div class="control-group">
                <label for="tempo">Tempo:</label>
                <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
                <span id="tempo-display">120 BPM</span>
            </div>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>
        <div class="beats-container"></div> <!-- This is the crucial container -->
        <div class="volume-control"> <!-- Moved Accent Intensity here -->
            <label for="accent-intensity">Accent Intensity:</label>
            <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
        </div>
        <!-- Placeholder for Drum Pad Buttons -->
        </div>
    
    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <h3>Create a progression or pick one. Choose key and scale per chord.</h3>
        <div class="controls">
            <div class="control-group">
                <label for="progression-select">Load Progression:</label>
                <select id="progression-select" aria-label="Select chord progression">
                    <option value="i-v7">I-V7</option>
                    <option value="jazz-blues">Jazz Blues</option>
                    <option value="minor-blues">Minor Blues</option>
                    <option value="rhythm-changes">Rhythm Changes</option>
                    <option value="ii-v-i">II-V-I</option>
                    <option value="vi-ii-v-i">VI-II-V-I</option>
                    <option value="minor-ii-v-i">Minor iim-V7-im</option>
                    <option value="dark-eyes">Dark Eyes</option>
                    <option value="ill-see-you-in-my-dreams">I'll See You In My Dreams</option>
                    <option value="rose-room">Rose Room</option>
                    <option value="black-orpheus">Black Orpheus</option>
                    <option value="all-the-things-you-are">All The Things You Are</option>
                    <option value="all-of-me">All of Me</option>
                    <option value="stella-by-starlight">Stella By Starlight</option>
                    <option value="autumn-leaves">Autumn Leaves</option>
                    <option value="summertime">Summertime</option>
                    <option value="girl-from-ipanema">Girl From Ipanema</option>
                    <option value="coltrane-changes">Coltrane Changes</option>
                    <option value="bird-blues">Bird Blues</option>
                    <option value="just-friends">Just Friends</option>
                    <option value="blue-bossa">Blue Bossa</option>
                    <option value="on-green-dolphin-street">On Green Dolphin Street</option>
                    <option value="solar">Solar</option>
                    <option value="misty">Misty</option>
                    <option value="days-of-wine-and-roses">Days of Wine and Roses</option>
                    <option value="cherokee">Cherokee</option>
                    <option value="caravan">Caravan</option>
                    <option value="nows-the-time">Now's The Time</option>
                    <option value="tenor-madness">Tenor Madness</option>
                </select>
            </div>
            <div class="control-group">
                <label for="keySelect">Global Key:</label>
                <select id="keySelect" aria-label="Select key">
                    <option value="C">C</option><option value="Db">Db</option><option value="D">D</option>
                    <option value="Eb">Eb</option><option value="E">E</option><option value="F">F</option>
                    <option value="Gb">Gb</option><option value="G">G</option><option value="Ab">Ab</option>
                    <option value="A">A</option><option value="Bb">Bb</option><option value="B">B</option>
                </select>
            </div>
        </div>
        <div id="measures">
            <!-- Measures will be populated dynamically -->
        </div>
        <div class="controls">
            <button id="add-measure-button" aria-label="Add measure">Add Measure</button> <!-- Changed ID to match JS querySelector if it uses ID -->
            <button id="remove-measure-button" aria-label="Remove measure">Remove Measure</button> <!-- Changed ID -->
        </div>
        <div class="controls">
            <div class="checkbox-wrapper">
                <button id="chordsEnabled" class="toggle-button active">Chords ON</button>
            </div>
            <div class="volume-control">
                <label for="chord-volume">Chord Volume:</label>
                <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.75" aria-label="Chord volume">
            </div>
            <div class="control-group">
                <label for="reverb-dial">Reverb:</label>
                <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
                <span id="reverb-dial-value">20</span>%
            </div>
        </div>
    </div>

    <div class="app-section" id="fretflow-section">
        <h2>FretFlow</h2>
        <h3>Multiple scale workout</h3>
        <div class="fretboards-grid"></div> <!-- Container for multiple fretboards -->
    </div>

    <!-- Audio Loading Progress Indicator (dynamically created by JS if not present, but good to have a placeholder) -->
    <div id="loading-indicator" style="display: none; position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; background-color: rgba(0,0,0,0.7); color: white; border-radius: 5px; z-index: 10000; transition: opacity 0.5s ease-in-out;">
        <p id="loading-status-message" style="margin: 0 0 5px 0;">Loading...</p>
        <div style="width: 100%; background-color: #555; height: 10px; border-radius: 3px; overflow: hidden;">
            <div id="loading-progress-fill" style="width: 0%; height: 100%; background-color: #4CAF50; transition: width 0.2s ease-out;"></div>
        </div>
        <span id="loading-progress-text" style="font-size: 0.8em; margin-left: 10px;">0%</span>
    </div>
    <!-- Fallback for the specific audio-loading-progress div if JS uses it differently -->
    <div id="audio-loading-progress" style="display: none; position: fixed; top: 10px; left: 50%; transform: translateX(-50%); width: 300px; background: #f0f0f0; border-radius: 5px; padding: 10px; text-align: center; z-index: 1001;">
        <span id="audio-loading-text">Loading Audio Samples...</span> <!-- JS UI.elements.audioLoadingText looks for this ID -->
        <div style="width: 100%; height: 20px; background: #ddd; border-radius: 3px; overflow: hidden;">
            <div id="progress-bar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s ease;"></div>
        </div>
        <span id="progress-text">0%</span> <!-- This is what index (31).html had, JS updateLoadingStatus uses loading-progress-text -->
    </div>


    <script>
    
// --- Configuration Constants ---
const LOG_PREFIX = "[Bebop Blueprint]";
const PIANO_SAMPLE_BASE_PATH = './'; 
const DRUM_SAMPLE_BASE_PATH = './';   
const METRONOME_SOUND_BASE_PATH = './'; 
const REVERB_IMPULSE_PATH = './ir-sweep.wav'; 


// --- Utility Functions ---
function log(message) {
    console.log(`${LOG_PREFIX} ${message}`);
}

function updateLoadingStatus(message, percentage = null) {
    let indicator = document.getElementById('loading-indicator');
    let progressBarFill = document.getElementById('loading-progress-fill');
    let progressTextElement = document.getElementById('loading-progress-text'); // Corrected variable name
    let statusMsgElement = document.getElementById('loading-status-message');

    // Fallback to the other progress bar if the primary one isn't found
    if (!indicator) {
        indicator = document.getElementById('audio-loading-progress');
        if (indicator) {
            progressBarFill = indicator.querySelector('#progress-bar');
            progressTextElement = indicator.querySelector('#progress-text'); // Uses the span with id="progress-text"
            statusMsgElement = indicator.querySelector('#audio-loading-text'); // Uses the span with id="audio-loading-text"
            indicator.style.display = 'block'; // Make sure it's visible
        }
    }


    if (!indicator) { // If neither indicator exists, create the primary one
        indicator = document.createElement('div');
        indicator.id = 'loading-indicator';
        indicator.style.position = 'fixed';
        indicator.style.bottom = '20px';
        indicator.style.left = '20px';
        indicator.style.padding = '10px 20px';
        indicator.style.backgroundColor = 'rgba(0,0,0,0.7)';
        indicator.style.color = 'white';
        indicator.style.borderRadius = '5px';
        indicator.style.zIndex = '10000';
        indicator.style.transition = 'opacity 0.5s ease-in-out';

        statusMsgElement = document.createElement('p');
        statusMsgElement.id = 'loading-status-message';
        statusMsgElement.style.margin = '0 0 5px 0';

        const progressBarContainer = document.createElement('div');
        progressBarContainer.style.width = '100%';
        progressBarContainer.style.backgroundColor = '#555';
        progressBarContainer.style.height = '10px';
        progressBarContainer.style.borderRadius = '3px';
        progressBarContainer.style.overflow = 'hidden';

        progressBarFill = document.createElement('div');
        progressBarFill.id = 'loading-progress-fill';
        progressBarFill.style.width = '0%';
        progressBarFill.style.height = '100%';
        progressBarFill.style.backgroundColor = '#4CAF50';
        progressBarFill.style.transition = 'width 0.2s ease-out';

        progressTextElement = document.createElement('span');
        progressTextElement.id = 'loading-progress-text';
        progressTextElement.style.fontSize = '0.8em';
        progressTextElement.style.marginLeft = '10px';

        progressBarContainer.appendChild(progressBarFill);
        indicator.appendChild(statusMsgElement);
        indicator.appendChild(progressBarContainer);
        indicator.appendChild(progressTextElement);
        document.body.appendChild(indicator);
        indicator.style.display = 'block'; // Ensure visibility after creation
    }
    
    if (statusMsgElement) statusMsgElement.textContent = message;

    if (percentage !== null && progressBarFill && progressTextElement) {
        progressBarFill.style.width = `${percentage}%`;
        progressTextElement.textContent = `${percentage}%`;
        if (progressBarFill.parentElement) progressBarFill.parentElement.style.display = 'block'; // Show container
        if (progressTextElement) progressTextElement.style.display = 'inline';
    } else if (progressBarFill) {
        if (progressBarFill.parentElement) progressBarFill.parentElement.style.display = 'none'; // Hide bar if no percentage
        if(progressTextElement) progressTextElement.style.display = 'none';
    }
}


function debounce(func, wait) {
    let timeout;
    return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// --- Music Constants ---
const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
const PIANO_SAMPLE_NOTES = ['c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs', 'a', 'as', 'b'];
const PIANO_OCTAVES = [2, 3, 4, 5]; 
const PIANO_FILE_FORMAT = 'wav'; 
const ENHARMONIC_MAP = { 
    'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
};

const DISPLAY_TO_SAMPLE_NOTE_MAP = {
    'C': 'c',   'C#': 'cs', 'Db': 'cs',
    'D': 'd',   'D#': 'ds', 'Eb': 'ds',
    'E': 'e',
    'F': 'f',   'F#': 'fs', 'Gb': 'fs',
    'G': 'g',   'G#': 'gs', 'Ab': 'gs',
    'A': 'a',   'A#': 'as', 'Bb': 'as',
    'B': 'b'
};

function standardizeNoteName(note) {
    if (!note || typeof note !== 'string') return '';
    let standardized = note.toUpperCase().trim();
    standardized = standardized.replace('♭', 'b').replace('♯', '#');
    return ENHARMONIC_MAP[standardized] || standardized;
}

const SCALES = {
    major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10], harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
    melodicMinor: [0, 2, 3, 5, 7, 9, 11], dorian: [0, 2, 3, 5, 7, 9, 10], phrygian: [0, 1, 3, 5, 7, 8, 10],
    lydian: [0, 2, 4, 6, 7, 9, 11], mixolydian: [0, 2, 4, 5, 7, 9, 10], locrian: [0, 1, 3, 5, 6, 8, 10],
    bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11], bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11], bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10],
    bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10], altered: [0, 1, 3, 4, 6, 8, 10], lydianDominant: [0, 2, 4, 6, 7, 9, 10],
    diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11], diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10], wholeTone: [0, 2, 4, 6, 8, 10], 
    pentatonicMajor: [0, 2, 4, 7, 9], pentatonicMinor: [0, 3, 5, 7, 10], blues: [0, 3, 5, 6, 7, 10],
    majorBlues: [0, 2, 3, 4, 7, 9], harmonicMajor: [0, 2, 4, 5, 7, 8, 11], doubleHarmonic: [0, 1, 4, 5, 7, 8, 11],
    enigmatic: [0, 1, 4, 6, 8, 10, 11], persian: [0, 1, 4, 5, 6, 8, 11], arabic: [0, 2, 4, 5, 6, 8, 10],
    japanese: [0, 2, 5, 7, 8], egyptian: [0, 2, 5, 7, 10]
};
const SCALES_DISPLAY_NAMES = { 
    major: "Major (Ionian)", minor: "Minor (Aeolian)", harmonicMinor: "Harmonic Minor", melodicMinor: "Melodic Minor",
    dorian: "Dorian", phrygian: "Phrygian", lydian: "Lydian", mixolydian: "Mixolydian (Dominant)", locrian: "Locrian",
    bebopDominant: "Bebop Dominant", bebopMajor: "Bebop Major", bebopDorian: "Bebop Dorian", bebopPhrygian: "Bebop Phrygian",
    altered: "Altered (Super Locrian)", lydianDominant: "Lydian Dominant", diminishedWH: "Diminished (W-H)",
    diminishedHW: "Diminished (H-W)", wholeTone: "Whole Tone", pentatonicMajor: "Pentatonic Major",
    pentatonicMinor: "Pentatonic Minor", blues: "Blues", majorBlues: "Major Blues",
    harmonicMajor: "Harmonic Major", doubleHarmonic: "Double Harmonic", enigmatic: "Enigmatic",
    persian: "Persian", arabic: "Arabic (Major Locrian)", japanese: "Japanese (Hirajoshi)", egyptian: "Egyptian (Pentatonic)"
};


const TUNINGS = { 
    standard: ['E', 'B', 'G', 'D', 'A', 'E'],
    dropD:    ['E', 'B', 'G', 'D', 'A', 'D'],
    openG:    ['D', 'B', 'G', 'D', 'G', 'D'],
    DADGAD:   ['D', 'A', 'G', 'D', 'A', 'D'],
    openE:    ['E', 'B', 'E', 'Ab', 'B', 'E'] 
};

let currentDrumSetIndex = 0;
const drumSoundSets = [ 
    { name: "Default Kit", kick: "Kick.wav", snare: "Snare.wav", hihat: "HiHat.wav" }, // Ensure these files exist
    { name: "Makaya Kit", kick: "Kick2.wav", snare: "Snare2.wav", hihat: "HiHat2.wav" },
    { name: "PhillyJoe Kit", kick: 'jazzkick.wav', snare: 'jazzsnare.wav', hihat: 'jazzhat.wav' }
];

const METRONOME_SOUND_PATHS = { 
    click: 'Click.wav', // Ensure this file exists
    woodblock: 'woodblock.wav' // Ensure this file exists
};

const progressions = {
    "i-v7": { displayName: "I-V7 Progression", defaultKey: "C", progression: ["Imaj7", "V7"]},
    "jazz-blues": { displayName: "Jazz Blues", defaultKey: "Bb", progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "IIm7", "V7", "I7", "V7"]},
    "minor-blues": { displayName: "Minor Blues", defaultKey: "Am", progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"]},
    "rhythm-changes": { displayName: "Rhythm Changes", defaultKey: "Bb", progression: ["Imaj7", "vim7", "iim7", "V7", "iiim7", "VI7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "IVmaj7", "IV#dim7", "Imaj7", "V7"]},
    "ii-v-i": { displayName: "ii-V-I Progression", defaultKey: "C", progression: ["iim7", "V7", "Imaj7", "Imaj7"]},
    "vi-ii-v-i": { displayName: "vi-ii-V-I Progression", defaultKey: "C", progression: ["vim7", "iim7", "V7", "Imaj7"]},
    "minor-ii-v-i": { displayName: "Minor ii-V-I", defaultKey: "Am", progression: ["iim7b5", "V7alt", "imaj7", "imaj7"]}, // V7alt, imaj7
    "dark-eyes": { displayName: "Dark Eyes", defaultKey: "Dm", progression: ["im", "im", "V7", "V7", "V7", "V7", "im", "im", "ivm", "ivm", "im", "im", "V7", "V7", "im", "im"]},
    "ill-see-you-in-my-dreams": { displayName: "I'll See You in My Dreams", defaultKey: "F", progression: ["Imaj7", "Imaj7", "IVmaj7", "ivm6", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "Imaj7", "VI7", "VI7", "II7", "II7", "iim7", "V7"]},
    "rose-room": { displayName: "Rose Room", defaultKey: "Ab", progression: ["Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "IVmaj7", "ivm6", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "Imaj7"]},
    "black-orpheus": { displayName: "Black Orpheus (Manhã de Carnaval)", defaultKey: "Am", progression: ["im7", "im7", "iim7b5", "V7alt", "im7", "im7", "ivm7", "bVII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7alt", "im7", "im7"]},
    "all-the-things-you-are": { displayName: "All the Things You Are", defaultKey: "Ab", progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "IVmaj7", "#ivdim7", "V7", "iiim7", "VI7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "IVmaj7", "IVmaj7", "#ivdim7", "V7", "iiim7", "VI7", "iim7", "V7", "Imaj7", "Imaj7", "Imaj7"]},
    "all-of-me": { displayName: "All of Me", defaultKey: "C", progression: ["Imaj7", "Imaj7", "E7", "E7", "A7", "A7", "dm7", "dm7", "E7", "E7", "Am", "Am", "D7", "D7", "dm7", "G7"]},
    "stella-by-starlight": { displayName: "Stella by Starlight", defaultKey: "Bb", progression: ["Em7b5", "A7alt", "Dm7", "G7", "Cm7", "F7", "Bbmaj7", "Bbmaj7", "Em7b5", "A7alt", "Dm7", "G7", "Cm7", "F7", "Fm7", "Bb7", "Ebmaj7", "Ebmaj7", "Ab7", "Ab7", "Dm7", "G7", "Cm7", "F7", "Bbmaj7", "Bbmaj7"]},
    "autumn-leaves": { displayName: "Autumn Leaves", defaultKey: "Gm", progression: ["Cm7", "F7", "Bbmaj7", "Ebmaj7", "Am7b5", "D7alt", "Gm", "Gm" ]}, // Key Gm
    "summertime": { displayName: "Summertime", defaultKey: "Am", progression: ["Am", "Am", "E7", "E7", "Am", "Am", "Dm", "Dm", "Am", "E7", "Am", "Am"]},
    "girl-from-ipanema": { displayName: "The Girl from Ipanema", defaultKey: "F", progression: ["Fmaj7", "Fmaj7", "G7", "G7", "Gm7", "Gm7", "Gb7", "Gb7", "Fmaj7", "Fmaj7", "Gb7", "Gb7", "Gm7", "C7", "Fmaj7", "Fmaj7"]},
    "coltrane-changes": { displayName: "Coltrane Changes (Giant Steps)", defaultKey: "Eb", progression: ["Bbmaj7", "Db7", "Gbmaj7", "A7", "Dmaj7", "F7", "Bbmaj7", "Db7", "Gbmaj7", "A7", "Dmaj7", "F7", "Bbmaj7"]}, // Key Eb for Giant Steps
    "bird-blues": { displayName: "Bird Blues (Blues for Alice)", defaultKey: "F", progression: ["Fmaj7", "Em7b5", "A7alt", "Dm7", "G7", "Cm7", "F7", "Bbmaj7", "Bbm7", "Eb7", "Am7", "D7", "Abm7", "Db7", "Gm7", "C7"]},
    "just-friends": { displayName: "Just Friends", defaultKey: "G", progression: ["Cmaj7", "Cmaj7", "Am7", "D7", "Gmaj7", "Gmaj7", "Em7", "A7", "Am7", "D7", "Gmaj7", "Gmaj7"]},
    "blue-bossa": { displayName: "Blue Bossa", defaultKey: "Cm", progression: ["Cm7", "Cm7", "Fm7", "Fm7", "Dm7b5", "G7alt", "Cm7", "Cm7", "Ebm7", "Ab7", "Dbmaj7", "Dbmaj7", "Dm7b5", "G7alt", "Cm7", "Cm7"]},
    "on-green-dolphin-street": { displayName: "On Green Dolphin Street", defaultKey: "C", progression: ["Cmaj7", "Cmaj7", "Cm7", "F7", "Bbmaj7", "Bbmaj7", "Am7b5", "D7alt", "Gm7", "C7", "Fmaj7", "Fmaj7", "Dm7", "G7", "Cmaj7", "Cmaj7"]}, // Key C
    "solar": { displayName: "Solar", defaultKey: "Cm", progression: ["CmMaj7", "CmMaj7", "Gm7", "C7", "Fmaj7", "Fmaj7", "Fm7", "Bb7", "Ebmaj7", "Ebmaj7", "Dm7b5", "G7alt", "CmMaj7", "CmMaj7"]},
    "misty": { displayName: "Misty", defaultKey: "Eb", progression: ["Ebmaj7", "Bbm7", "Eb7", "Abmaj7", "Abm7", "Db7", "Ebmaj7", "Cm7", "Fm7", "Bb7", "Ebmaj7", "Ebmaj7"]},
    "days-of-wine-and-roses": { displayName: "Days of Wine and Roses", defaultKey: "F", progression: ["Fmaj7", "Fmaj7", "Eb7", "Eb7", "Am7", "D7", "Gm7", "C7", "Fmaj7", "Fmaj7"]},
    "cherokee": { displayName: "Cherokee", defaultKey: "Bb", progression: ["Bbmaj7", "Bbmaj7", "Bb7", "Bb7", "Ebmaj7", "Ebm", "Bbmaj7", "Gm7", "Cm7", "F7", "Bbmaj7", "Bbmaj7"]},
    "caravan": { displayName: "Caravan", defaultKey: "Fm", progression: ["Fm", "Fm", "C7", "C7", "Fm", "Fm", "Bbm", "Bbm", "Eb7", "Eb7", "Abmaj7", "Abmaj7", "Dbmaj7", "Dbmaj7", "C7", "C7"]},
    "nows-the-time": { displayName: "Now's The Time", defaultKey: "F", progression: ["F7", "Bb7", "F7", "F7", "Bb7", "Bb7", "F7", "D7alt", "Gm7", "C7", "F7", "C7"]},
    "tenor-madness": { displayName: "Tenor Madness", defaultKey: "Bb", progression: ["Bb7", "Eb7", "Bb7", "Bb7", "Eb7", "Eb7", "Bb7", "G7alt", "Cm7", "F7", "Bb7", "F7"]}
};


// --- State Management ---
const AppState = {
    isPlaying: false, currentBeat: 0, currentMeasure: 0, tempo: 120,
    audioInitialized: false, darkMode: false, chordsEnabled: true,
    intervalId: null, lastTap: null,
    listeners: [],
    updateState(newState) {
    Object.assign(this, newState);
    this.notifyListeners();
    },
    addListener(callback) { this.listeners.push(callback); },
    notifyListeners() { this.listeners.forEach(callback => callback(this)); }
};

const UI = {
    elements: {
    chordFretboard: document.getElementById('chord-fretboard'),
    measures: document.getElementById('measures'),
    tempoDisplay: document.getElementById('tempo-display'),
    startStopButton: document.getElementById('start-stop'),
    progressionSelect: document.getElementById('progression-select'),
    keySelect: document.getElementById('keySelect'),
    scaleDisplay: document.getElementById('scale-display'),
    chordTuning: document.getElementById('chord-tuning'),
    timeSignature: document.getElementById('time-signature'),
    soundType: document.getElementById('sound-type'),
    metronomeVolume: document.getElementById('metronome-volume'),
    tempo: document.getElementById('tempo'), // This is the range input
    tapTempo: document.getElementById('tap-tempo'),
    chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
    chordVolume: document.getElementById('chord-volume'),
    chordsEnabled: document.getElementById('chordsEnabled'),
    fretboardsGrid: document.querySelector('.fretboards-grid'),
    darkModeToggle: document.getElementById('dark-mode-toggle'),
    accentIntensity: document.getElementById('accent-intensity'),
    drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
    reverbDial: document.getElementById('reverb-dial'),
    reverbDialValue: document.getElementById('reverb-dial-value'),
    // Using IDs for add/remove measure buttons for direct access
    addMeasureButton: document.getElementById('add-measure-button'), 
    removeMeasureButton: document.getElementById('remove-measure-button'),
    audioLoadingProgress: document.getElementById('audio-loading-progress'), // The specific div from HTML
    audioLoadingText: document.getElementById('audio-loading-text'), // The span inside the above div
    // Drum Pad Buttons
    beatsContainer: document.querySelector('.beats-container') // Added for createBeats
    },

    init() {
    log("UI.init() called.");
    let allFound = true;
    for (const key in this.elements) {
        if (!this.elements[key]) {
            // More specific check for aria-label buttons if IDs were not used
            if (key === 'addMeasureButton' && !document.querySelector('button[aria-label="Add measure"]')) {
                 console.warn(`${LOG_PREFIX} Missing DOM element for UI.elements.${key} (expected ID 'add-measure-button' or aria-label).`);
                 allFound = false;
            } else if (key === 'removeMeasureButton' && !document.querySelector('button[aria-label="Remove measure"]')) {
                 console.warn(`${LOG_PREFIX} Missing DOM element for UI.elements.${key} (expected ID 'remove-measure-button' or aria-label).`);
                 allFound = false;
            } else if (!['addMeasureButton', 'removeMeasureButton'].includes(key)) { // Don't double-warn for these
                console.warn(`${LOG_PREFIX} Missing DOM element for UI.elements.${key}.`);
                allFound = false;
            }
        }
    }
    if (allFound) log("All expected UI elements cached.");
    else log("Some UI elements were not found. Check HTML IDs and selectors.");


    this.populateProgressionSelect();
    log("UI elements populated and initial setup done.");
    },

    populateProgressionSelect() {
        if (this.elements.progressionSelect && typeof progressions !== 'undefined' && Object.keys(progressions).length > 0) {
            // Clear existing options from HTML template if any, before populating
            // this.elements.progressionSelect.innerHTML = ''; // Already done in HTML
            Object.entries(progressions).forEach(([id, { displayName }]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = displayName;
                // Check if this option was already in the HTML to avoid duplicates if HTML is static
                if (!this.elements.progressionSelect.querySelector(`option[value="${id}"]`)) {
                    this.elements.progressionSelect.appendChild(option);
                }
            });
            log("Progression select populated.");
        } else if (!this.elements.progressionSelect) {
            console.warn(`${LOG_PREFIX} 'progression-select' element not found for populating.`);
        } else if (typeof progressions === 'undefined' || Object.keys(progressions).length === 0) {
            console.warn(`${LOG_PREFIX} 'progressions' data not available or empty for populating select.`);
        }
    }
};
    
// --- AudioContextManager (Refactored for Preloading) ---
const AudioContextManager = {
    context: null,
    soundBuffers: {},
    reverbNode: null,
    reverbBuffer: null,
    chordGainNode: null,
    reverbAmount: 0.2,
    samplesFullyLoaded: false,
    currentChordSources: [],
    activePianoNotes: {},
    activeMetronomeSounds: [],
    reverbNodeConnectedToDestination: false,

    async initialize() {
        if (this.context) return this.context;
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            if (this.context.state === 'suspended') {
                log("AudioContext is suspended. Attempting to resume...");
            }
            this.chordGainNode = this.context.createGain();
            this.chordGainNode.gain.value = parseFloat(UI.elements.chordVolume?.value || 0.75);
            this.chordGainNode.connect(this.context.destination);

            await this.setupReverb();
            AppState.updateState({ audioInitialized: true });
            log("AudioContext initialized (state: " + this.context.state + "). Sample loading will follow.");
        } catch (error) {
            console.error(`${LOG_PREFIX} AudioContext initialization failed:`, error);
            AppState.updateState({ audioInitialized: false });
            updateLoadingStatus("Audio system failed to initialize. Please refresh or enable audio in your browser.", null);
            throw error;
        }
        return this.context;
    },

    async ensureAudioContextResumed() {
        if (!this.context) {
            await this.initialize();
        }
        if (this.context && this.context.state === 'suspended') {
            try {
                await this.context.resume();
                log("AudioContext resumed successfully.");
            } catch (e) {
                console.error(`${LOG_PREFIX} Failed to resume AudioContext:`, e);
                updateLoadingStatus("Could not resume audio. Please interact with the page.", null);
            }
        }
        return this.context && this.context.state === 'running';
    },

    async loadAllSoundSamples() {
        if (this.samplesFullyLoaded) return;
        if (!this.context) {
            log("AudioContext not ready for sample loading. Will retry after initialization.");
            return;
        }
        if (this.context.state !== 'running') {
            log("AudioContext not running. Sample loading deferred until resumed.");
            return;
        }

        log("Starting to load all sound samples...");
        updateLoadingStatus("Loading audio samples...", 0);

        const samplesToLoad = [];
        PIANO_SAMPLE_NOTES.forEach(note => {
            PIANO_OCTAVES.forEach(octave => {
                const fileName = `${note}${octave}.${PIANO_FILE_FORMAT}`;
                samplesToLoad.push({ key: `piano_${note}${octave}`, path: `${PIANO_SAMPLE_BASE_PATH}${fileName}` });
            });
        });
        drumSoundSets.forEach((kit) => {
            const kitNameKey = kit.name.replace(/\s+/g, '_').toLowerCase();
            ['kick', 'snare', 'hihat'].forEach(drumType => {
                if (kit[drumType]) {
                    samplesToLoad.push({ key: `drum_${kitNameKey}_${drumType}`, path: `${DRUM_SAMPLE_BASE_PATH}${kit[drumType]}` });
                }
            });
        });
        Object.entries(METRONOME_SOUND_PATHS).forEach(([name, filePath]) => {
            samplesToLoad.push({ key: `metronome_${name}`, path: `${METRONOME_SOUND_BASE_PATH}${filePath}` });
        });

        let loadedCount = 0;
        const totalSamples = samplesToLoad.length;
        if (totalSamples === 0) {
            this.samplesFullyLoaded = true;
            log("No samples defined to load.");
            updateLoadingStatus("No audio samples to load.", 100);
            setTimeout(() => {
                const indicator = document.getElementById('loading-indicator') || document.getElementById('audio-loading-progress');
                if (indicator) indicator.style.opacity = '0';
                setTimeout(() => indicator?.remove(), 600);
            }, 1000);
            return;
        }

        for (const sample of samplesToLoad) {
            try {
                const response = await fetch(sample.path);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} for ${sample.path}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[sample.key] = await this.context.decodeAudioData(arrayBuffer);
                loadedCount++;
                const percentage = Math.round((loadedCount / totalSamples) * 100);
                updateLoadingStatus(`Loading: ${sample.key.replace(/_/g, ' ')}`, percentage);
            } catch (error) {
                console.error(`${LOG_PREFIX} Failed to load sample ${sample.key} from ${sample.path}:`, error);
            }
        }

        this.samplesFullyLoaded = true;
        log(`All sound samples processed. ${loadedCount}/${totalSamples} loaded successfully.`);
        if (loadedCount < totalSamples) {
            updateLoadingStatus(`Partial audio load (${loadedCount}/${totalSamples}). Some sounds may be missing.`, 100);
        } else {
            updateLoadingStatus("Audio samples loaded!", 100);
        }
        setTimeout(() => {
            const indicator = document.getElementById('loading-indicator') || document.getElementById('audio-loading-progress');
            if (indicator) indicator.style.opacity = '0';
            setTimeout(() => indicator?.remove(), 600);
        }, 1500);
    },

    async setupReverb() {
        if (!this.context) return;
        try {
            const response = await fetch(REVERB_IMPULSE_PATH);
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} for ${REVERB_IMPULSE_PATH}`);
            const arrayBuffer = await response.arrayBuffer();
            this.reverbBuffer = await this.context.decodeAudioData(arrayBuffer);
            this.reverbNode = this.context.createConvolver();
            this.reverbNode.buffer = this.reverbBuffer;
            log("Reverb impulse loaded. Convolver ready.");
        } catch (error) {
            console.error(`${LOG_PREFIX} Failed to set up reverb:`, error);
            this.reverbNode = null;
        }
    },

    _playBuffer(bufferKey, volume, destination, pan = 0, pitchBend = 0, isMetronomeSound = false) {
        if (!this.context || this.context.state !== 'running' || !this.soundBuffers[bufferKey]) {
            if (!this.soundBuffers[bufferKey]) console.warn(`${LOG_PREFIX} Buffer not found for key: ${bufferKey}`);
            return null;
        }

        const source = this.context.createBufferSource();
        source.buffer = this.soundBuffers[bufferKey];

        if (pitchBend !== 0) source.detune.value = pitchBend * 100;

        const gainNode = this.context.createGain();
        gainNode.gain.value = Math.max(0, Math.min(1, volume));

        const pannerNode = this.context.createStereoPanner();
        pannerNode.pan.value = Math.max(-1, Math.min(1, pan));

        source.connect(gainNode);
        gainNode.connect(pannerNode);

        const finalDestination = (!isMetronomeSound && this.chordGainNode) ? this.chordGainNode : (destination || this.context.destination);
        pannerNode.connect(finalDestination);

        if (this.reverbNode && this.reverbAmount > 0 && !isMetronomeSound) {
            const reverbSendGain = this.context.createGain();
            reverbSendGain.gain.value = this.reverbAmount * (bufferKey.startsWith('piano_') ? 0.5 : 0.3);
            pannerNode.connect(reverbSendGain);
            reverbSendGain.connect(this.reverbNode);

            if (!this.reverbNodeConnectedToDestination) {
                this.reverbNode.connect(this.context.destination);
                this.reverbNodeConnectedToDestination = true;
            }
        }

        source.start(this.context.currentTime);
        return { source, gainNode, pannerNode };
    },

    stopAllPianoNotes() {
        for (const noteId in this.activePianoNotes) {
            try {
                this.activePianoNotes[noteId].stop(this.context.currentTime);
            } catch (e) { /* ignore */ }
        }
        this.activePianoNotes = {};
    },

    stopAllMetronomeSounds() {
        this.activeMetronomeSounds.forEach(sound => {
            try {
                if (sound.source) {
                    if (sound.gainNode) {
                        sound.gainNode.gain.cancelScheduledValues(this.context.currentTime);
                        sound.gainNode.gain.setValueAtTime(sound.gainNode.gain.value, this.context.currentTime);
                        sound.gainNode.gain.linearRampToValueAtTime(0.0001, this.context.currentTime + 0.02);
                        sound.source.stop(this.context.currentTime + 0.03);
                    } else {
                        sound.source.stop(this.context.currentTime + 0.02);
                    }
                }
            } catch (e) { /* ignore */ }
        });
        this.activeMetronomeSounds = [];
    },

    playPianoNote(noteNameWithOctave, volume, durationMs = 1000) {
        const bufferKey = `piano_${noteNameWithOctave.toLowerCase()}`;
        const playedSound = this._playBuffer(bufferKey, volume, this.context.destination);

        if (playedSound && durationMs > 0) {
            const noteId = `${bufferKey}_${Date.now()}`;
            this.activePianoNotes[noteId] = playedSound.source;
            playedSound.source.onended = () => {
                delete this.activePianoNotes[noteId];
            };
            playedSound.source.stop(this.context.currentTime + durationMs / 1000);
        }
        return playedSound ? playedSound.source : null;
    },

    stopCurrentChord() {
        this.currentChordSources.forEach(chordNote => {
            try {
                if (chordNote.source) {
                    if (chordNote.gainNode) {
                        chordNote.gainNode.gain.cancelScheduledValues(this.context.currentTime);
                        chordNote.gainNode.gain.setValueAtTime(chordNote.gainNode.gain.value, this.context.currentTime);
                        chordNote.gainNode.gain.exponentialRampToValueAtTime(0.0001, this.context.currentTime + 0.05);
                        chordNote.source.stop(this.context.currentTime + 0.06);
                    } else {
                        chordNote.source.stop(this.context.currentTime + 0.05);
                    }
                }
            } catch (e) { /* ignore if already stopped or disconnected */ }
        });
        this.currentChordSources = [];
    }
}; // <--- End of AudioContextManager object

async function playMetronomeSound(baseBeatVolume) {
    if (!await AudioContextManager.ensureAudioContextResumed()) return;
    if (!AudioContextManager.samplesFullyLoaded) return;

    const metronomeVolumeSetting = parseFloat(UI.elements.metronomeVolume?.value || 0.7);
    const combinedVolume = baseBeatVolume * metronomeVolumeSetting;
    if (combinedVolume <= 0) return;

    const soundType = UI.elements.soundType?.value || 'click';
    const beatElement = UI.elements.beatsContainer?.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    if (!beatElement) return;

    const drumSoundKeys = beatElement.dataset.sound?.split(',').map(s => s.trim()).filter(s => s) || ['click'];
    const accentBoost = parseFloat(UI.elements.accentIntensity?.value || 1.0); 
    const isStrongBeat = parseFloat(beatElement.dataset.baseVolume) >= 1.0; 

    AudioContextManager.activeMetronomeSounds = AudioContextManager.activeMetronomeSounds.filter(s => {
        try { return s.source.playbackState !== AudioBufferSourceNode.FINISHED_STATE; } // Clean up finished sounds
        catch(e) { return false; }
    });


    for (let soundKey of drumSoundKeys) {
        if (soundKey === 'silent') continue;
        let bufferKeyToPlay;
        let soundSpecificVolumeAdjustment = 1.0;

        if (soundType === 'drums') {
            if (!drumSoundSets || currentDrumSetIndex === undefined || !drumSoundSets[currentDrumSetIndex]) {
                bufferKeyToPlay = `metronome_click`; 
            } else {
                const currentSet = drumSoundSets[currentDrumSetIndex];
                const kitNameKey = currentSet.name.replace(/\s+/g, '_').toLowerCase();
                bufferKeyToPlay = `drum_${kitNameKey}_${soundKey}`;
                if (!AudioContextManager.soundBuffers[bufferKeyToPlay]) {
                    bufferKeyToPlay = `drum_default_kit_${soundKey}`; 
                    if (!AudioContextManager.soundBuffers[bufferKeyToPlay]) continue; 
                }
            }
            if (soundKey === 'kick') soundSpecificVolumeAdjustment = 1.1;
            else if (soundKey === 'snare') soundSpecificVolumeAdjustment = 1.0;
            else if (soundKey === 'hihat' || soundKey === 'closedhat') soundSpecificVolumeAdjustment = 0.7;
        } else { 
            bufferKeyToPlay = `metronome_${soundType}`;
            if (!AudioContextManager.soundBuffers[bufferKeyToPlay]) continue;
        }

        let finalVolume = combinedVolume * soundSpecificVolumeAdjustment;
        if (isStrongBeat && (soundKey === 'kick' || soundKey === 'snare' || soundType === 'click' || soundType === 'woodblock')) {
            finalVolume = Math.min(finalVolume * accentBoost, 1.0); 
        }
        finalVolume = Math.max(0, Math.min(finalVolume, 1.0)); 

        const playedSound = AudioContextManager._playBuffer(bufferKeyToPlay, finalVolume, AudioContextManager.context.destination, 0, 0, true); // true for isMetronomeSound
        if (playedSound) {
            AudioContextManager.activeMetronomeSounds.push(playedSound);
            playedSound.source.onended = () => { // Auto-cleanup from active list
                AudioContextManager.activeMetronomeSounds = AudioContextManager.activeMetronomeSounds.filter(s => s !== playedSound);
            };
        }
    }
}
// --- Chord and Scale Utilities ---
function getNoteFromScaleDegree(scaleDegree, key, scaleIntervals = SCALES.major) {
    const rootIndex = NOTES.indexOf(standardizeNoteName(key));
    if (rootIndex === -1) return null; 
    const offset = scaleIntervals[scaleDegree % scaleIntervals.length];
    return NOTES[(rootIndex + offset + 12) % 12]; 
}
function getChordNotes(root, quality) {
    const CHORD_INTERVALS = {
    'maj': [0, 4, 7], 'min': [0, 3, 7], 'dim': [0, 3, 6], 'aug': [0, 4, 8],
    'sus4': [0, 5, 7], 'sus2': [0, 2, 7],
    'maj7': [0, 4, 7, 11], 'dom7': [0, 4, 7, 10], 'min7': [0, 3, 7, 10],
    'dim7': [0, 3, 6, 9], 'min7b5': [0, 3, 6, 10], 'aug7': [0, 4, 8, 10], 
    '6': [0, 4, 7, 9], 'm6': [0, 3, 7, 9], 
    'maj9': [0, 4, 7, 11, 14], 'dom9': [0, 4, 7, 10, 14], 'min9': [0, 3, 7, 10, 14],
    'V7alt': [0, 4, 10], 'alt': [0, 4, 10], // Added 'alt' as an alias
    'imaj7': [0, 3, 7, 11] // Minor Major 7th
    };
    const intervals = CHORD_INTERVALS[quality] || CHORD_INTERVALS['maj']; 
    const rootStd = standardizeNoteName(root);
    const rootIndex = NOTES.indexOf(rootStd);

    if (rootIndex === -1) return [rootStd]; 
    return intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
}
    
function getChordFromFunction(romanNumeralInput, key = "C") {
    const romanMap = { "I":0, "II":2, "III":4, "IV":5, "V":7, "VI":9, "VII":11 };
    const qualityMap = {
        "maj7": "maj7", "Δ": "maj7", "M7": "maj7",
        "m7": "min7", "-7": "min7",
        "7": "dom7",
        "m7b5": "min7b5", "ø": "min7b5",
        "dim7": "dim7", "°7": "dim7", "dim": "dim", "°": "dim", // Added dim triad
        "6": "6", "m6": "m6",
        "maj": "maj", "": "maj", // Default to major triad if no suffix
        "m": "min", "min": "min",
        "alt": "V7alt", "7alt": "V7alt",
        "sus": "sus4", "sus4": "sus4",
        "aug": "aug", "+": "aug", // Added augmented triad
        "imaj7": "imaj7", "mΔ": "imaj7", "mM7": "imaj7" // Minor Major 7th
    };

    if (typeof romanNumeralInput !== 'string') return { root: key, quality: 'maj7' }; 

    const match = romanNumeralInput.match(/([b#♭♯]*)?([IViv]+)(.*)/i);
    if (!match) return { root: key, quality: 'maj7' }; 

    let [, accidental, numeralStr, suffix] = match;
    let quality = ''; // Start with empty, determine from suffix or case
    let isExplicitlyMinor = numeralStr === numeralStr.toLowerCase();

    suffix = suffix.trim();
    if (suffix.length > 0) {
        for (const [qSuffix, qInternal] of Object.entries(qualityMap)) {
            if (suffix.toUpperCase() === qSuffix.toUpperCase()) { // Case-insensitive suffix match
                quality = qInternal;
                break;
            }
        }
    }
    
    if (!quality) { // If suffix didn't define quality
        if (isExplicitlyMinor) quality = 'min'; // i, ii, iii, etc. -> minor triad
        else quality = 'maj'; // I, II, III, etc. -> major triad
    }


    let semitoneOffset = romanMap[numeralStr.toUpperCase()];
    if (semitoneOffset === undefined) return { root: key, quality: 'maj7' };

    if (accidental) { 
        if (accidental.includes('b') || accidental.includes('♭')) semitoneOffset--;
        if (accidental.includes('#') || accidental.includes('♯')) semitoneOffset++;
    }

    const keyStd = standardizeNoteName(key);
    const keyIndex = NOTES.indexOf(keyStd);
    if (keyIndex === -1) return { root: key, quality: 'maj7' };

    const rootNote = NOTES[(keyIndex + semitoneOffset + 12) % 12];
    return { root: rootNote, quality: quality };
}
function getQualityValue(quality) { 
    const map = { 'maj': 'maj', 'min': 'min', 'V7alt': 'dom7', 'alt': 'dom7', 'imaj7': 'imaj7' }; 
    return map[quality] || quality;
}

function suggestScaleForQuality(quality) {
    const scaleMap = {
    'maj': 'major', 'maj7': 'lydian', 
    'min': 'dorian', 'min7': 'dorian', 
    'dom7': 'mixolydian', 'V7alt': 'altered', 'alt': 'altered',
    'min7b5': 'locrian', 
    'dim7': 'diminishedWH', 'dim': 'diminishedWH',
    '6': 'major', 'm6': 'melodicMinor',
    'imaj7': 'melodicMinor' // or harmonic minor
    };
    return scaleMap[quality] || 'major';
}

// --- DOM Utilities ---
function createKeyOptions(selectedKey = 'C') {
    return NOTES.map(note => `<option value="${note}"${note === selectedKey ? ' selected' : ''}>${note}</option>`).join('');
}

function createQualityOptions(selectedQuality = 'maj7') {
    const qualities = [
        { value: 'maj', label: 'Major Triad' }, { value: 'min', label: 'Minor Triad' },
        { value: 'aug', label: 'Augmented Triad' }, { value: 'dim', label: 'Diminished Triad' },
        { value: 'maj7', label: 'Major 7th' }, { value: 'min7', label: 'Minor 7th' },
        { value: 'dom7', label: 'Dominant 7th' }, { value: 'min7b5', label: 'Minor 7th ♭5 (Half-Dim)' },
        { value: 'dim7', label: 'Diminished 7th' }, { value: 'V7alt', label: 'Altered Dominant' }, // V7alt is often just 'alt'
        { value: '6', label: 'Major 6th' }, { value: 'm6', label: 'Minor 6th' },
        { value: 'sus4', label: 'Sus 4' }, { value: 'imaj7', label: 'Minor-Major 7th' }
    ];
    return qualities.map(q => `<option value="${q.value}" ${q.value === selectedQuality ? 'selected' : ''}>${q.label}</option>`).join('');
}

function createScaleOptions(selectedScale = 'major') {
    return Object.entries(SCALES_DISPLAY_NAMES)
    .map(([value, displayName]) => `<option value="${value}"${value === selectedScale ? ' selected' : ''}>${displayName}</option>`)
    .join('');
}

// --- Audio Playback Functions (Using Preloaded Samples) ---
async function playNoteOnFretboard(noteNameWithOctave, volume = 0.7) { 
    if (!await AudioContextManager.ensureAudioContextResumed()) return;
    if (!AudioContextManager.samplesFullyLoaded) return;
    const standardizedNoteKey = noteNameWithOctave.toLowerCase();
    AudioContextManager.playPianoNote(standardizedNoteKey, volume, 700); 
}

async function playChord(root, quality, durationMs = 2000) {
    if (!await AudioContextManager.ensureAudioContextResumed()) return;
    if (!AudioContextManager.samplesFullyLoaded) return;

    AudioContextManager.stopCurrentChord(); 

    const chordNotes = getChordNotes(root, quality); 
    const chordVolume = parseFloat(UI.elements.chordVolume?.value || 0.5);

    if (chordVolume <= 0 || !chordNotes || chordNotes.length === 0) return;

    chordNotes.forEach((note, index) => {
        let baseOctave = 3;
        if (index === 0 && NOTES.indexOf(note) < NOTES.indexOf('F')) baseOctave = 2; 
        else baseOctave = 3;
        
        let octave = baseOctave;
        if (index > 0 && NOTES.indexOf(note) < NOTES.indexOf(chordNotes[0])) octave = baseOctave + 1; 

        const sampleNoteName = DISPLAY_TO_SAMPLE_NOTE_MAP[note];
        if (!sampleNoteName) return; 
        
        const finalOctave = Math.min(PIANO_OCTAVES[PIANO_OCTAVES.length-1], Math.max(PIANO_OCTAVES[0], octave));
        const noteKey = `${sampleNoteName}${finalOctave}`;
        
        const playedSound = AudioContextManager._playBuffer(`piano_${noteKey}`, chordVolume * (0.8 + Math.random() * 0.2), AudioContextManager.context.destination);
        if (playedSound) {
            AudioContextManager.currentChordSources.push(playedSound); // Store {source, gainNode, pannerNode}
            if (durationMs > 0) {
                playedSound.source.onended = () => { // Auto-remove from list when stopped
                    AudioContextManager.currentChordSources = AudioContextManager.currentChordSources.filter(cs => cs !== playedSound);
                };
                playedSound.source.stop(AudioContextManager.context.currentTime + durationMs / 1000);
            }
        }
    });
}

// --- Fretboard Rendering (Event Delegation for Clicks) ---
function createFretboard(container, tuningArray) {
    if (!container) { console.error("Fretboard container not found for creation."); return; }
    container.innerHTML = ''; 
    const numFrets = 12;
    const numStrings = tuningArray.length;

    for (let i = 0; i <= numFrets; i++) { 
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`;
        container.appendChild(fretLine);
        if (i > 0) {
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
            container.appendChild(fretNumber);
        }
    }
    for (let i = 0; i < numStrings; i++) { 
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        stringLine.style.top = `${(i / (numStrings - 1)) * 100}%`;
        container.appendChild(stringLine);
    }
    [3, 5, 7, 9, 12].forEach(pos => { 
        if (pos > numFrets) return;
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((pos - 0.5) / numFrets) * 100}%`;
        if (pos === 12) {
            const m1 = marker.cloneNode(true); m1.style.top = '25%'; container.appendChild(m1);
            const m2 = marker.cloneNode(true); m2.style.top = '75%'; container.appendChild(m2);
        } else {
            marker.style.top = '50%'; container.appendChild(marker);
        }
    });
}

function updateFretboardNotes(container, rootNote, scaleName, tuningArray) {
    if (!(container instanceof HTMLElement)) return;
    const standardizedRoot = standardizeNoteName(rootNote);
    if (!NOTES.includes(standardizedRoot) || !SCALES[scaleName] || !Array.isArray(tuningArray)) return;

    container.querySelectorAll('.note').forEach(noteEl => noteEl.remove()); 

    if (container.id === 'chord-fretboard' && UI.elements.measures?.children.length > 0 && AppState.currentMeasure < UI.elements.measures.children.length) {
        const currentMeasureEl = UI.elements.measures.children[AppState.currentMeasure];
        const chordRoot = currentMeasureEl?.querySelector('.chord-controls .root-note')?.value;
        const chordQuality = currentMeasureEl?.querySelector('.chord-controls .chord-quality')?.value;
        const displayScaleName = SCALES_DISPLAY_NAMES[scaleName] || scaleName;
        if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = `${standardizedRoot} ${displayScaleName} (over ${chordRoot || "?"} ${chordQuality || "?"})`;
    } else if (container.id === 'chord-fretboard' && UI.elements.scaleDisplay) { // Fallback for initial load or no measures
        const displayScaleName = SCALES_DISPLAY_NAMES[scaleName] || scaleName;
        UI.elements.scaleDisplay.textContent = `${standardizedRoot} ${displayScaleName}`;
    }


    const scaleIntervals = SCALES[scaleName];
    const rootIndex = NOTES.indexOf(standardizedRoot);
    const scaleNotesInKey = scaleIntervals.map(interval => NOTES[(rootIndex + interval) % 12]);

    const numStrings = tuningArray.length;
    const numFrets = 12;
    const stringBaseOctaves = numStrings === 6 ? [4, 3, 3, 2, 2, 2] : Array(numStrings).fill(3); 

    for (let stringIdx = 0; stringIdx < numStrings; stringIdx++) {
        const openNoteName = standardizeNoteName(tuningArray[stringIdx]);
        const openNoteIndex = NOTES.indexOf(openNoteName);
        if (openNoteIndex === -1) continue;
        const baseOctaveForString = stringBaseOctaves[stringIdx];

        for (let fret = 0; fret <= numFrets; fret++) {
            const noteAbsIndex = openNoteIndex + fret;
            const currentNoteName = NOTES[noteAbsIndex % 12];

            if (scaleNotesInKey.includes(currentNoteName)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNoteName;
                const fretOffset = fret === 0 ? 0.02 : ((fret - 0.5) / numFrets); 
                noteElement.style.left = `${fretOffset * 100}%`;
                noteElement.style.top = `${(stringIdx / (numStrings - 1)) * 100}%`;
                const currentOctave = baseOctaveForString + Math.floor(noteAbsIndex / 12);
                const sampleNoteFilePart = DISPLAY_TO_SAMPLE_NOTE_MAP[currentNoteName];
                noteElement.dataset.note = `${sampleNoteFilePart}${currentOctave}`; 
                if (currentNoteName === standardizedRoot) noteElement.classList.add('root-note-highlight');
                else noteElement.classList.add('scale-note-highlight');
                container.appendChild(noteElement);
            }
        }
    }
}

// --- Beat Creation and Playback Logic ---
function createBeats() {
    const container = UI.elements.beatsContainer; 
    if (!container) { console.error(`${LOG_PREFIX} Beats container not found.`); return; }
    container.innerHTML = '';

    const timeSigSelectValue = UI.elements.timeSignature?.value || '4/4'; // Default to 4/4
    const [beatsPerMeasureStr, beatUnitStr] = timeSigSelectValue.split('/');
    const beatsPerMeasure = parseInt(beatsPerMeasureStr);
    const beatUnit = parseInt(beatUnitStr); // Not directly used in this simplified pattern logic, but good to have

    const soundType = UI.elements.soundType?.value || 'click';
    // For 4/4, display 8 subdivisions (8th notes). For others, display main beats.
    const totalDisplayBeats = (beatsPerMeasure === 4 && beatUnit === 4) ? 8 : beatsPerMeasure;


    const beatPatternConfig = { 
        '4/4_drums': [
            { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
            { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50', label: '2' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
            { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D', label: '3' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
            { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50', label: '4' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
        ],
        '4/4_click': [ // 8 subdivisions for 4/4 click
            { sound: ['click'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            { sound: ['click'], volume: '0.7', color: '#4CAF50', label: '2' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            { sound: ['click'], volume: '1', color: '#1F618D', label: '3' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            { sound: ['click'], volume: '0.7', color: '#4CAF50', label: '4' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
        ],
        '4/4_woodblock': [ // 8 subdivisions for 4/4 woodblock
            { sound: ['woodblock'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            { sound: ['woodblock'], volume: '0.7', color: '#4CAF50', label: '2' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            { sound: ['woodblock'], volume: '1', color: '#1F618D', label: '3' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            { sound: ['woodblock'], volume: '0.7', color: '#4CAF50', label: '4' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
        ],
        // Default patterns for other time signatures (main beats)
        'default_drums': (bpm) => Array.from({length: bpm}, (_, i) => ({
            sound: i === 0 ? ['kick', 'hihat'] : ['snare', 'hihat'],
            volume: i === 0 ? '1' : '0.8',
            color: i === 0 ? '#1F618D' : '#4CAF50',
            label: (i + 1).toString()
        })),
        'default_click': (bpm) => Array.from({length: bpm}, (_, i) => ({
            sound: ['click'],
            volume: i === 0 ? '1' : '0.7',
            color: i === 0 ? '#1F618D' : '#4CAF50',
            label: (i + 1).toString()
        })),
         'default_woodblock': (bpm) => Array.from({length: bpm}, (_, i) => ({
            sound: ['woodblock'],
            volume: i === 0 ? '1' : '0.7',
            color: i === 0 ? '#1F618D' : '#4CAF50',
            label: (i + 1).toString()
        }))
    };
    
    let currentPatternKey = `${beatsPerMeasure}/${beatUnit}_${soundType}`;
    let pattern = beatPatternConfig[currentPatternKey];

    if (!pattern) { // Fallback to default patterns if specific one not found
        const defaultPatternGenerator = beatPatternConfig[`default_${soundType}`];
        if (defaultPatternGenerator) {
            pattern = defaultPatternGenerator(beatsPerMeasure);
        } else {
            pattern = beatPatternConfig['default_click'](beatsPerMeasure); // Absolute fallback
        }
    }


    for (let i = 0; i < totalDisplayBeats; i++) {
        const beatEl = document.createElement('div');
        beatEl.className = 'beat';
        beatEl.dataset.beat = i.toString(); // This is the index for playback logic
        
        const config = pattern[i % pattern.length]; // Use modulo for safety if totalDisplayBeats > pattern.length
        beatEl.textContent = config.label || (Math.floor(i / (totalDisplayBeats / beatsPerMeasure)) + 1).toString();
        beatEl.dataset.sound = Array.isArray(config.sound) ? config.sound.join(',') : config.sound;
        beatEl.dataset.baseVolume = config.volume;
        beatEl.style.backgroundColor = config.color;
        
        beatEl.addEventListener('click', () => toggleBeatState(beatEl, timeSigSelectValue, soundType));
        container.appendChild(beatEl);
    }
}

function toggleBeatState(beatElement, timeSignature, soundType) { 
    const currentSounds = beatElement.dataset.sound.split(',');
    const currentVolume = parseFloat(beatElement.dataset.baseVolume);
    let nextState;

    if (soundType === 'click' || soundType === 'woodblock') {
        if (currentVolume >= 1.0) nextState = { sound: [soundType], volume: '0.7', color: '#4CAF50' }; // Strong to normal
        else if (currentVolume > 0) nextState = { sound: ['silent'], volume: '0', color: '#666666' }; // Normal to silent
        else nextState = { sound: [soundType], volume: '1.0', color: '#1F618D' }; // Silent to strong
    } else if (soundType === 'drums') {
        const drumCycle = ['kick', 'snare', 'hihat', 'silent']; // Simple cycle for now
        let currentSoundIndex = drumCycle.indexOf(currentSounds[0]); // Consider first sound for simplicity
        if (currentSoundIndex === -1 || currentSounds[0] === 'silent') currentSoundIndex = drumCycle.length -1; // If silent or unknown, start before kick
        
        const nextSound = drumCycle[(currentSoundIndex + 1) % drumCycle.length];
        
        if (nextSound === 'silent') {
            nextState = { sound: ['silent'], volume: '0', color: '#666666' };
        } else {
            const newSounds = [nextSound];
            // Optional: auto-add hihat with kick/snare if not already there
            // if ((nextSound === 'kick' || nextSound === 'snare') && !newSounds.includes('hihat')) {
            //     newSounds.push('hihat');
            // }
            nextState = { 
                sound: newSounds, 
                volume: (nextSound === 'kick' || nextSound === 'snare') ? '1.0' : '0.7', 
                color: (nextSound === 'kick') ? '#1F618D' : (nextSound === 'snare' ? '#4CAF50' : '#9E9E9E')
            };
        }
    } else { // Fallback, should not happen if soundType is validated
        nextState = { sound: ['click'], volume: '0.7', color: '#4CAF50' };
    }
    beatElement.dataset.sound = nextState.sound.join(',');
    beatElement.dataset.baseVolume = nextState.volume;
    beatElement.style.backgroundColor = nextState.color;
}

async function playBeat() {
    if (!AppState.isPlaying) return; 

    const allBeatElements = UI.elements.beatsContainer?.querySelectorAll('.beat');
    if (!allBeatElements || allBeatElements.length === 0) return;

    allBeatElements.forEach(b => b.classList.remove('active')); 
    const currentBeatVisualIndex = AppState.currentBeat % allBeatElements.length; 
    const currentBeatElement = allBeatElements[currentBeatVisualIndex];

    if (currentBeatElement) {
        currentBeatElement.classList.add('active');
        const baseBeatVol = parseFloat(currentBeatElement.dataset.baseVolume) || 0;
        if (baseBeatVol > 0 && UI.elements.metronomeVolume?.value > 0) { 
            await playMetronomeSound(baseBeatVol);
        }
    }

    const measureElements = UI.elements.measures?.children; 
    const timeSigValue = UI.elements.timeSignature?.value || '4/4';
    const [beatsPerMeasureNumStr] = timeSigValue.split('/');
    const beatsPerMeasureNum = parseInt(beatsPerMeasureNumStr);
    
    // For 4/4, we have 8 subdivisions (8th notes). Otherwise, main beats.
    const totalSubdivisionsPerMeasureCycle = (beatsPerMeasureNum === 4 && UI.elements.soundType?.value !== 'drums') ? 8 : beatsPerMeasureNum;
    // If drums are selected in 4/4, it might also use 8 subdivisions based on createBeats logic.
    // Let's make it consistent: if totalDisplayBeats in createBeats was 8, use 8 here.
    const displayBeatsCount = UI.elements.beatsContainer?.children.length || beatsPerMeasureNum;
    const effectiveTotalSubdivisions = displayBeatsCount;


    if (measureElements && measureElements.length > 0) {
        const currentMeasureDOMIndex = AppState.currentMeasure % measureElements.length;
        const currentMeasureEl = measureElements[currentMeasureDOMIndex];

        if (currentMeasureEl) {
            if (AppState.currentBeat === 0) { 
                Array.from(measureElements).forEach((m, idx) => m.classList.toggle('active', idx === currentMeasureDOMIndex));
                
                const scaleRoot = currentMeasureEl.querySelector('.scale-controls .second-key')?.value;
                const scaleType = currentMeasureEl.querySelector('.scale-controls .scale-select')?.value;
                if (scaleRoot && scaleType && UI.elements.chordFretboard && UI.elements.chordTuning) {
                    const chordTuningValue = UI.elements.chordTuning.value;
                    if (TUNINGS && TUNINGS[chordTuningValue]) {
                        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, TUNINGS[chordTuningValue]);
                    }
                }
            }

            if (AppState.chordsEnabled) {
                const root = currentMeasureEl.querySelector('.chord-controls .root-note')?.value;
                const quality = currentMeasureEl.querySelector('.chord-controls .chord-quality')?.value;
                const tempo = AppState.tempo || parseInt(UI.elements.tempo?.value || 120);
                const beatDurationSec = 60 / tempo;
                
                let shouldPlayChord = false;
                // For 8 subdivisions (e.g. 4/4 with 8th notes), play chords on 1st and 3rd quarter notes (beat 0 and 4 of 8)
                if (effectiveTotalSubdivisions === 8) { 
                    if (AppState.currentBeat === 0 || AppState.currentBeat === 4) shouldPlayChord = true;
                } else { // For other time sigs or main beat counting, play chord on the first beat
                    if (AppState.currentBeat === 0) shouldPlayChord = true;
                }

                if (shouldPlayChord && root && quality) {
                    const subdivisionUnit = (effectiveTotalSubdivisions === 8) ? 2 : 1; // How many subdivisions per main beat
                    const chordDurationBeats = (effectiveTotalSubdivisions === 8) ? (subdivisionUnit * 2) : beatsPerMeasureNum; // Chord lasts 2 main beats in 4/4, or full measure
                    const chordDurationMs = beatDurationSec * chordDurationBeats * ( (effectiveTotalSubdivisions === 8) ? 0.5 : 1); // Adjust if interval is 8th vs quarter
                    await playChord(root, quality, chordDurationMs);
                }
            }
        }
    }
    
    AppState.currentBeat = (AppState.currentBeat + 1) % effectiveTotalSubdivisions;
    if (AppState.currentBeat === 0 && measureElements && measureElements.length > 0) { 
        AppState.currentMeasure = (AppState.currentMeasure + 1) % measureElements.length;
    }
}

async function startPlayback() {
    log("Attempting to start playback...");
    if (!await AudioContextManager.ensureAudioContextResumed()) {
        updateLoadingStatus("Audio not ready. Please click the page to enable audio.", null);
        return;
    }
    if (!AudioContextManager.samplesFullyLoaded) {
        const confirmStart = confirm("Audio samples might still be loading. Some sounds may not play immediately. Continue?");
        if (!confirmStart) { log("Playback cancelled by user due to samples loading."); return; }
    }
    if (AppState.isPlaying) return;

    const measureElements = UI.elements.measures?.children;
    if (!measureElements || measureElements.length === 0) {
        alert('No measures defined. Please load or add measures.'); return;
    }

    AppState.tempo = parseInt(UI.elements.tempo?.value || 120); 
    AppState.updateState({ isPlaying: true, currentBeat: 0, currentMeasure: 0 });

    if (AppState.intervalId) clearInterval(AppState.intervalId);

    const timeSigValue = UI.elements.timeSignature?.value || '4/4';
    const [beatsPerMeasureNumStr] = timeSigValue.split('/');
    const beatsPerMeasureNum = parseInt(beatsPerMeasureNumStr);
    
    // Determine interval based on displayed beats (subdivisions)
    const displayBeatsCount = UI.elements.beatsContainer?.children.length || beatsPerMeasureNum;
    const intervalMs = (60 / AppState.tempo) * 1000 / (displayBeatsCount / beatsPerMeasureNum);


    // Initial setup for the very first beat/measure
    const firstMeasureEl = measureElements[0];
    if (firstMeasureEl) {
        Array.from(measureElements).forEach(m => m.classList.remove('active'));
        firstMeasureEl.classList.add('active');
        const initialScaleRoot = firstMeasureEl.querySelector('.scale-controls .second-key')?.value;
        const initialScaleType = firstMeasureEl.querySelector('.scale-controls .scale-select')?.value;
        if (initialScaleRoot && initialScaleType && UI.elements.chordFretboard && UI.elements.chordTuning) {
            updateFretboardNotes(UI.elements.chordFretboard, initialScaleRoot, initialScaleType, TUNINGS[UI.elements.chordTuning.value]);
        }
        // Pre-play first chord if applicable (playBeat will also try, this is for immediate sound)
        if (AppState.chordsEnabled && AppState.currentBeat === 0) { // Only if first beat is a chord beat
            const initialRoot = firstMeasureEl.querySelector('.chord-controls .root-note')?.value;
            const initialQuality = firstMeasureEl.querySelector('.chord-controls .chord-quality')?.value;
            if (initialRoot && initialQuality) {
                const beatDurationSec = 60 / AppState.tempo;
                const effectiveTotalSubdivisions = displayBeatsCount;
                const subdivisionUnit = (effectiveTotalSubdivisions === 8) ? 2 : 1;
                const chordDurationBeats = (effectiveTotalSubdivisions === 8) ? (subdivisionUnit * 2) : beatsPerMeasureNum;
                const chordDurationMs = beatDurationSec * chordDurationBeats * ( (effectiveTotalSubdivisions === 8) ? 0.5 : 1);
                await playChord(initialRoot, initialQuality, chordDurationMs);
            }
        }
    }
    
    await playBeat(); // Play the first beat immediately
    
    AppState.intervalId = setInterval(async () => {
        try { await playBeat(); } 
        catch (beatError) { console.error(`${LOG_PREFIX} Error during scheduled playBeat:`, beatError); }
    }, intervalMs);

    if (UI.elements.startStopButton) UI.elements.startStopButton.textContent = 'Stop';
    log(`Playback started. Interval: ${intervalMs}ms. Tempo: ${AppState.tempo}bpm.`);
}

function stopPlayback() {
    if (AppState.intervalId) {
        clearInterval(AppState.intervalId);
        AppState.intervalId = null;
    }
    AudioContextManager.stopCurrentChord(); 
    AudioContextManager.stopAllPianoNotes(); 
    AudioContextManager.stopAllMetronomeSounds();

    AppState.updateState({ isPlaying: false }); 
    
    document.querySelectorAll('.beat.active').forEach(el => el.classList.remove('active'));
    // Don't remove active from measure, so user knows where they left off.
    // document.querySelectorAll('.measure.active').forEach(el => el.classList.remove('active'));

    if (UI.elements.startStopButton) UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped.");
}

// --- Progression and Measure Management ---
function loadProgression(progressionName, overrideKey = null) {
    const progressionData = progressions[progressionName];
    if (!progressionData) { alert(`Progression "${progressionName}" not found.`); return; }

    const selectedKey = overrideKey || progressionData.defaultKey || "C"; 
    if (UI.elements.keySelect) UI.elements.keySelect.value = selectedKey;
    
    const measuresContainer = UI.elements.measures;
    if (measuresContainer) measuresContainer.innerHTML = ''; 
    else { console.error("Measures container not found."); return; }

    let firstChordDetails = null;
    if (!progressionData.progression || !Array.isArray(progressionData.progression)) {
        alert(`Invalid progression data for "${progressionName}".`); return;
    }

    progressionData.progression.forEach((chordFunc, index) => {
        const parsedChord = getChordFromFunction(chordFunc, selectedKey); 
        if (!parsedChord || !parsedChord.root || !parsedChord.quality) return; 
        if (index === 0) {
            firstChordDetails = { ...parsedChord, scaleType: suggestScaleForQuality(parsedChord.quality) }; 
        }
        addMeasureWithChordDOM(parsedChord, index + 1); 
    });

    if (UI.elements.chordFretboard && firstChordDetails) {
        const tuningValue = UI.elements.chordTuning?.value || 'standard';
        if (TUNINGS && TUNINGS[tuningValue] && firstChordDetails.scaleType) {
            updateFretboardNotes(UI.elements.chordFretboard, firstChordDetails.root, firstChordDetails.scaleType, TUNINGS[tuningValue]);
        }
    }
    log(`Loaded progression: ${progressionData.displayName || progressionName} in key ${selectedKey}.`);
    AppState.currentMeasure = 0; // Reset current measure when loading new progression
    AppState.currentBeat = 0;
}

function addMeasureWithChordDOM(parsedChord, measureNumber) { 
    const measure = document.createElement('div');
    measure.className = 'measure';
    measure.draggable = true; 
    measure.dataset.measureNumber = measureNumber;

    const rootNote = parsedChord.root || 'C';
    const quality = parsedChord.quality || 'maj'; 
    const suggestedScale = suggestScaleForQuality(quality) || 'major'; 

    measure.innerHTML = `
    <button class="delete-measure-btn" title="Delete measure">X</button> 
    <span class="measure-number">${measureNumber}</span>
    <div class="chord-controls">
    <label>Chord: </label>
    <select class="root-note">${createKeyOptions(rootNote)}</select>
    <select class="chord-quality">${createQualityOptions(getQualityValue(quality))}</select> 
    </div>
    <div class="scale-controls">
    <label>Scale: </label>
    <select class="second-key">${createKeyOptions(rootNote)}</select> 
    <select class="scale-select">${createScaleOptions(suggestedScale)}</select>
    </div>
    `;
    
    UI.elements.measures?.appendChild(measure);
    setupIndividualMeasureEventListeners(measure); 
}

function updateProgressionKey(newKey) {
    const selectedProgName = UI.elements.progressionSelect?.value;
    const progressionData = progressions[selectedProgName];
    if (!progressionData || !progressionData.progression) return;

    Array.from(UI.elements.measures?.children || []).forEach((measureEl, index) => {
        if (index >= progressionData.progression.length) return; // Safety check
        const chordFunc = progressionData.progression[index];
        if (!chordFunc) return;
        const parsedChord = getChordFromFunction(chordFunc, newKey);
        if (!parsedChord) return;
        measureEl.querySelector('.root-note').value = parsedChord.root;
        measureEl.querySelector('.chord-quality').value = getQualityValue(parsedChord.quality);
        measureEl.querySelector('.second-key').value = parsedChord.root; // Update scale root too
        measureEl.querySelector('.scale-select').value = suggestScaleForQuality(parsedChord.quality);
    });
    updateFretboardFromFirstMeasure();
    log(`Progression "${progressionData.displayName}" updated to key: ${newKey}`);
}

function addMeasure() {
    const measureCount = UI.elements.measures?.children.length || 0;
    addMeasureWithChordDOM({ root: 'C', quality: 'maj7' }, measureCount + 1); 
    // updateMeasureNumbers(); // addMeasureWithChordDOM now takes measureNumber
}
function removeMeasure() { // Removes the last measure
    const measuresContainer = UI.elements.measures;
    if (measuresContainer?.lastElementChild) {
        measuresContainer.lastElementChild.remove();
        // updateMeasureNumbers(); // Not strictly needed if numbers are part of creation
        if (AppState.currentMeasure >= measuresContainer.children.length && measuresContainer.children.length > 0) {
            AppState.currentMeasure = measuresContainer.children.length - 1; // Adjust current measure if it's out of bounds
        } else if (measuresContainer.children.length === 0) {
            AppState.currentMeasure = 0;
        }
    }
}
function updateMeasureNumbers() { // Call after drag/drop or mass add/remove
    Array.from(UI.elements.measures?.children || []).forEach((measure, index) => {
        const numEl = measure.querySelector('.measure-number');
        if (numEl) numEl.textContent = (index + 1).toString();
        measure.dataset.measureNumber = (index + 1).toString();
    });
}

// --- Drag and Drop for Measures ---
let draggedMeasure = null;
function dragStart(e) {
    if (!e.target.classList.contains('measure')) return;
    draggedMeasure = e.target;
    e.dataTransfer.effectAllowed = 'move';
    // e.dataTransfer.setData('text/html', draggedMeasure.innerHTML); // Not essential for this logic
    setTimeout(() => e.target.classList.add('dragging'), 0);
}
function dragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
function drop(e) {
    e.preventDefault();
    const targetMeasure = e.target.closest('.measure');
    if (targetMeasure && draggedMeasure && draggedMeasure !== targetMeasure && UI.elements.measures?.contains(targetMeasure) && UI.elements.measures?.contains(draggedMeasure)) {
        const measuresArray = Array.from(UI.elements.measures.children);
        const draggedIdx = measuresArray.indexOf(draggedMeasure);
        const targetIdx = measuresArray.indexOf(targetMeasure);
        if (draggedIdx < targetIdx) {
            UI.elements.measures.insertBefore(draggedMeasure, targetMeasure.nextSibling);
        } else {
            UI.elements.measures.insertBefore(draggedMeasure, targetMeasure);
        }
        updateMeasureNumbers();
        updateFretboardFromFirstMeasure(); // If first measure changed
    }
    draggedMeasure?.classList.remove('dragging');
    draggedMeasure = null;
}
function dragEnd(e) { 
    e.target.classList.remove('dragging'); 
    draggedMeasure = null; 
}


// --- FretFlow Multi-Fretboard Section ---
function initializeFretFlow() {
    const grid = UI.elements.fretboardsGrid;
    if (!grid) return;
    grid.innerHTML = ''; 
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(350px, 1fr))'; 
    grid.style.gap = '20px';

    for (let i = 0; i < 2; i++) { // Reduced to 2 for simplicity, can be increased
        const section = document.createElement('div');
        section.className = 'fretboard-section'; // Use this class for dark mode styling
        section.innerHTML = `
        <h4>Fretboard ${i + 1}</h4>
        <div class="fretboard-controls controls"> <!-- Added 'controls' class -->
            <div class="control-group"><label for="ff-key-${i}">Key:</label><select id="ff-key-${i}" class="fretflow-key">${createKeyOptions()}</select></div>
            <div class="control-group"><label for="ff-scale-${i}">Scale:</label><select id="ff-scale-${i}" class="fretflow-scale">${createScaleOptions()}</select></div>
            <div class="control-group"><label for="ff-tuning-${i}">Tuning:</label><select id="ff-tuning-${i}" class="tuning-select">${Object.entries(TUNINGS).map(([val, arr]) => `<option value="${val}">${val.charAt(0).toUpperCase() + val.slice(1)} (${arr[0]}${arr[5]})</option>`).join('')}</select></div>
        </div>
        <div class="scale-display" id="ff-scale-display-${i}">C Major</div>
        <div id="ff-fretboard-${i}" class="fretboard fretflow-instance"></div>
        `;
        grid.appendChild(section);

        const fretboardEl = section.querySelector(`#ff-fretboard-${i}`);
        const keySelect = section.querySelector(`#ff-key-${i}`);
        const scaleSelect = section.querySelector(`#ff-scale-${i}`);
        const tuningSelect = section.querySelector(`#ff-tuning-${i}`);
        const scaleDisplayEl = section.querySelector(`#ff-scale-display-${i}`);

        const updateDisplay = () => {
            const key = keySelect.value;
            const scale = scaleSelect.value;
            const tuningName = tuningSelect.value;
            scaleDisplayEl.textContent = `${key} ${SCALES_DISPLAY_NAMES[scale] || scale}`;
            createFretboard(fretboardEl, TUNINGS[tuningName]);
            updateFretboardNotes(fretboardEl, key, scale, TUNINGS[tuningName]);
        };
        [keySelect, scaleSelect, tuningSelect].forEach(sel => sel.addEventListener('change', updateDisplay));
        setupFretboardInteractions(fretboardEl); 
        updateDisplay(); 
    }
}

// --- Event Listener Setup ---
function setupFretboardInteractions(fretboardContainer) {
    if (!fretboardContainer) return;
    fretboardContainer.addEventListener('click', async (event) => {
        const noteElement = event.target.closest('.note');
        if (noteElement && noteElement.dataset.note) {
            try {
                const noteToPlay = noteElement.dataset.note; 
                // Determine volume based on which fretboard section this is in
                let volume = 0.7;
                if (fretboardContainer.id === 'chord-fretboard' && UI.elements.chordFretboardVolume) {
                    volume = parseFloat(UI.elements.chordFretboardVolume.value);
                } // Could add logic for FretFlow volumes if they have separate controls
                
                await playNoteOnFretboard(noteToPlay, volume);
                noteElement.classList.add('note-active-feedback'); 
                setTimeout(() => noteElement.classList.remove('note-active-feedback'), 150);
            } catch (error) { console.error(`${LOG_PREFIX} Error playing note from fretboard:`, error); }
        }
    });
}

function setupIndividualMeasureEventListeners(measureElement) {
    measureElement.addEventListener('dragstart', dragStart);
    // dragover, drop, dragend are on the measures container for broader drop targets

    measureElement.querySelectorAll('select').forEach(select => {
        select.addEventListener('change', (e) => {
            const rootVal = measureElement.querySelector('.root-note').value;
            const qualityVal = measureElement.querySelector('.chord-quality').value;
            
            if (e.target.matches('.root-note, .chord-quality')) { 
                measureElement.querySelector('.second-key').value = rootVal; 
                measureElement.querySelector('.scale-select').value = suggestScaleForQuality(getQualityValue(qualityVal)); 
            }
            // Update main fretboard only if the *first* measure is changed
            if (measureElement === UI.elements.measures?.firstElementChild) {
                updateFretboardFromFirstMeasure();
            }
        });
    });
    const deleteBtn = measureElement.querySelector('.delete-measure-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
            const parent = measureElement.parentElement;
            measureElement.remove();
            updateMeasureNumbers(); // Renumber remaining measures
            if (parent?.children.length > 0) { // If there are still measures
                 updateFretboardFromFirstMeasure(); // Update from new first measure
                 if (AppState.currentMeasure >= parent.children.length) {
                    AppState.currentMeasure = Math.max(0, parent.children.length - 1);
                 }
            } else { // No measures left
                UI.elements.scaleDisplay.textContent = ""; // Clear scale display
                UI.elements.chordFretboard.innerHTML = ""; // Clear fretboard notes
                createFretboard(UI.elements.chordFretboard, TUNINGS[UI.elements.chordTuning.value]); // Redraw empty
                AppState.currentMeasure = 0;
            }
        });
    }
}


function updateFretboardFromFirstMeasure() {
    const firstMeasure = UI.elements.measures?.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector(".second-key")?.value;
        const scaleType = firstMeasure.querySelector(".scale-select")?.value;
        const tuningName = UI.elements.chordTuning?.value || 'standard';
        if (scaleRoot && scaleType && TUNINGS[tuningName] && UI.elements.chordFretboard) {
            updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, TUNINGS[tuningName]);
        }
    } else if (UI.elements.chordFretboard) { // No measures, clear main fretboard
        UI.elements.scaleDisplay.textContent = "N/A";
        updateFretboardNotes(UI.elements.chordFretboard, 'C', 'major', TUNINGS[UI.elements.chordTuning.value]); // Default display
    }
}

function setupGlobalEventListeners() {
    const addSafeListener = (elementKey, event, handler) => {
        const element = UI.elements[elementKey];
        if (element) {
            // For range inputs, 'input' is better than 'change' for live updates
            const eventType = (element.type === 'range' && event === 'change') ? 'input' : event;
            element.addEventListener(eventType, handler);
        } else {
            // Don't warn for optional drum pad buttons if they are truly optional by design
            const optionalButtons = ['kickButton', 'snareButton', 'hihatClosedButton', 'hihatOpenButton', 'crashButton'];
            if (!optionalButtons.includes(elementKey)) {
                 console.warn(`${LOG_PREFIX} Element not found for listener: UI.elements.${elementKey}`);
            }
        }
    };

    let audioManuallyInitialized = false; // To track if user interaction has occurred
    const initializeAudioAndLoadSamples = async () => {
        if (audioManuallyInitialized) return; // Already done
        audioManuallyInitialized = true; // Mark as attempted

        log("User interaction detected. Initializing/Resuming AudioContext...");
        const resumed = await AudioContextManager.ensureAudioContextResumed();
        if (resumed) {
            log("AudioContext is running. Proceeding to load samples.");
            await AudioContextManager.loadAllSoundSamples();
        } else {
            log("AudioContext could not be resumed. Sample loading deferred.");
            updateLoadingStatus("Audio disabled. Please enable audio/interact again.", null);
        }
        // Remove these listeners after first interaction
        document.removeEventListener('click', initializeAudioAndLoadSamples);
        document.removeEventListener('keydown', initializeAudioAndLoadSamples);
    };
    // These listeners are crucial for browsers that block auto-play audio
    document.addEventListener('click', initializeAudioAndLoadSamples, { once: true });
    document.addEventListener('keydown', initializeAudioAndLoadSamples, { once: true });


    addSafeListener('startStopButton', 'click', () => AppState.isPlaying ? stopPlayback() : startPlayback());
    addSafeListener('progressionSelect', 'change', e => loadProgression(e.target.value, UI.elements.keySelect.value));
    addSafeListener('keySelect', 'change', e => updateProgressionKey(e.target.value));
    
    addSafeListener('tempo', 'input', debounce(() => { // Changed to 'input' for live update
        if (!UI.elements.tempo) return;
        AppState.tempo = parseInt(UI.elements.tempo.value);
        if (UI.elements.tempoDisplay) UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        if (AppState.isPlaying) { stopPlayback(); startPlayback(); } // Restart playback with new tempo
    }, 100)); // Reduced debounce for responsiveness

    let tapTempoTimeouts = [];
    let lastTapTime = 0;
    addSafeListener('tapTempo', 'click', () => {
        const now = performance.now();
        if (lastTapTime > 0) {
            const diff = now - lastTapTime;
            if (diff < 2000 && diff > 50) { // Ignore taps too close or too far apart
                tapTempoTimeouts.push(diff);
                if (tapTempoTimeouts.length > 4) tapTempoTimeouts.shift(); 
                if (tapTempoTimeouts.length >= 2) {
                    const avgInterval = tapTempoTimeouts.reduce((a,b) => a+b, 0) / tapTempoTimeouts.length;
                    const newTempo = Math.round(60000 / avgInterval);
                    AppState.tempo = Math.max(40, Math.min(300, newTempo)); // Clamp tempo
                    if(UI.elements.tempo) UI.elements.tempo.value = AppState.tempo;
                    if(UI.elements.tempoDisplay) UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                    if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
                }
            } else { // Reset if tap is out of reasonable range
                tapTempoTimeouts = [];
            }
        }
        lastTapTime = now;
        // Auto-reset if no tap for a while
        setTimeout(() => { if (performance.now() - lastTapTime > 3000) { tapTempoTimeouts = []; lastTapTime = 0;} }, 3000);
    });


    addSafeListener('timeSignature', 'change', () => { createBeats(); if (AppState.isPlaying) { stopPlayback(); startPlayback(); } });
    addSafeListener('soundType', 'change', e => {
        if (UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.style.display = e.target.value === 'drums' ? 'inline-block' : 'none';
        createBeats(); // Recreate beats based on new sound type
    });
    addSafeListener('drumSetToggleBtn', 'click', () => {
        currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
        if (UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
         // Preview sound from new kit
    });

    // Volume controls are read directly when sounds are played, no specific event handlers needed beyond UI update if any
    addSafeListener('reverbDial', 'input', e => { // Changed to 'input'
        AudioContextManager.reverbAmount = parseFloat(e.target.value) / 100;
        if (UI.elements.reverbDialValue) UI.elements.reverbDialValue.textContent = e.target.value;
    });

    let currentDarkMode = 0;
    const darkModes = ['', 'dark-mode', 'dark-mode-2', 'dark-mode-3']; // Cycle through no dark mode and 3 themes
    addSafeListener('darkModeToggle', 'click', () => {
        document.body.classList.remove(...darkModes.filter(Boolean)); // Remove all dark mode classes
        currentDarkMode = (currentDarkMode + 1) % darkModes.length;
        if (darkModes[currentDarkMode]) {
            document.body.classList.add(darkModes[currentDarkMode]);
        }
        UI.elements.darkModeToggle.textContent = darkModes[currentDarkMode] ? `Theme ${currentDarkMode}` : "Light Mode";
        UI.elements.darkModeToggle.classList.toggle('active', !!darkModes[currentDarkMode]);
    });

    addSafeListener('chordsEnabled', 'click', () => {
        AppState.chordsEnabled = !AppState.chordsEnabled;
        UI.elements.chordsEnabled.textContent = AppState.chordsEnabled ? "Chords ON" : "Chords OFF";
        UI.elements.chordsEnabled.classList.toggle('active', AppState.chordsEnabled);
    });
    addSafeListener('chordTuning', 'change', () => {
        updateFretboardFromFirstMeasure(); // Update main fretboard
        initializeFretFlow(); // Re-init FretFlow as tunings affect all fretboards
    });

    addSafeListener('addMeasureButton', 'click', addMeasure);
    addSafeListener('removeMeasureButton', 'click', removeMeasure);

    // Event delegation for measure controls (drag/drop on container)
    if (UI.elements.measures) {
        UI.elements.measures.addEventListener('dragover', dragOver);
        UI.elements.measures.addEventListener('drop', drop);
        UI.elements.measures.addEventListener('dragend', dragEnd); // Catch dragend here if not on item
    }
    log("Global event listeners set up.");
}

// --- Application Initialization ---
async function initializeApp() {
    updateLoadingStatus("Initializing UI...", null); 
    UI.init(); 

    try {
        await AudioContextManager.initialize(); // Initialize context but don't assume it's running
    } catch (error) {
        // Error already logged and status updated by AudioContextManager.initialize
    }

    // 🔊 Set up chord volume live control
    if (UI.elements.chordVolume) {
        UI.elements.chordVolume.addEventListener('input', () => {
            const vol = parseFloat(UI.elements.chordVolume.value);
            if (AudioContextManager.chordGainNode) {
                AudioContextManager.chordGainNode.gain.setValueAtTime(vol, AudioContextManager.context.currentTime);
            }
        });
    }

    updateLoadingStatus("Setting up interface components...", null);

    createBeats();
    if (UI.elements.chordFretboard && UI.elements.chordTuning) {
        createFretboard(UI.elements.chordFretboard, TUNINGS[UI.elements.chordTuning.value] || TUNINGS.standard);
        setupFretboardInteractions(UI.elements.chordFretboard); 
        updateFretboardNotes(UI.elements.chordFretboard, 'C', 'major', TUNINGS[UI.elements.chordTuning.value] || TUNINGS.standard); 
    }
    initializeFretFlow(); 
    setupGlobalEventListeners();

    if (UI.elements.progressionSelect?.value) {
        loadProgression(UI.elements.progressionSelect.value, UI.elements.keySelect.value);
    } else {
        addMeasure(); 
    }

    if (UI.elements.tempoDisplay && UI.elements.tempo) {
        UI.elements.tempoDisplay.textContent = `${UI.elements.tempo.value} BPM`;
    }
    if (UI.elements.reverbDialValue && UI.elements.reverbDial) {
        UI.elements.reverbDialValue.textContent = UI.elements.reverbDial.value;
    }
    if (UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
    }
    if (UI.elements.soundType?.value !== 'drums' && UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.style.display = 'none';
    }

    if (!AudioContextManager.context || AudioContextManager.context.state !== 'running') {
        updateLoadingStatus("Ready. Click or press a key to enable audio and load samples.", null);
    } else {
        await AudioContextManager.loadAllSoundSamples();
    }

    log("Application initialized.");
}


// --- Global Error Handling ---
window.addEventListener('error', (event) => {
    console.error(`${LOG_PREFIX} Global error:`, event.error, event.message, event.filename, event.lineno);
    updateLoadingStatus('An unexpected error occurred. Please check console and refresh.', null);
});
window.addEventListener('unhandledrejection', (event) => {
    console.error(`${LOG_PREFIX} Unhandled promise rejection:`, event.reason);
    updateLoadingStatus('An async error occurred. Please check console and refresh.', null);
});

// --- Start the App ---
document.addEventListener('DOMContentLoaded', initializeApp);
    
    </script>
    </body>
    </html>
