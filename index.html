<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Lato', sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--bg-color, #f0f0f0); /* Lighter default background */
        color: var(--text-color, #333);

        /* Light Theme (Default) Guide Tone Colors */
        --guide-tone-bg-color: #007bff;       /* Bright Blue */
        --guide-tone-text-color: white;
        --guide-tone-border-color: #0056b3;    /* Darker Blue */
        --root-highlight-border-color: #c82333; /* Default for root highlight border */

        /* Item 1: Song Title Color */
        --song-title-fretboard-color: #0056b3; /* Darker blue for light mode */

        /* NEW: Subsection styling variables for Light Mode */
        --subsection-bg-color: #e9ecef;
        --subsection-border-color: #ced4da;
        --subsection-title-color: inherit;
    }
    .app-section {
        background: var(--section-bg-color, white);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        color: var(--section-text-color, inherit);
    }

    /* NEW: Subsection styling */
    .app-subsection {
        background-color: var(--subsection-bg-color, #e9ecef);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        border: 1px solid var(--subsection-border-color, #ced4da);
    }
    .song-setup-controls h4 { /* Specific for the song setup title */
        margin-top: 0;
        margin-bottom: 10px;
        color: var(--subsection-title-color, var(--text-color));
    }


    .fretboards-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin-bottom: 30px;
    }
    .fretboard-container {
        background: var(--fretboard-container-bg, white);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        border: 1px solid var(--fretboard-container-border, transparent);
    }
    /* Song Info Display Styling (Item 1) */
    #song-info-display-fretboard {
        margin-bottom: 10px; /* Space before scale display */
    }
    #song-info-display-fretboard #current-song-title-fretboard {
        text-align: left;
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 1.3em; /* Slightly larger */
        font-weight: bold; /* Bolder */
        color: var(--song-title-fretboard-color); /* Themed color */
    }
    #song-info-display-fretboard p {
        text-align: left;
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 0.9em;
        color: var(--song-info-p-color, #555);
        font-style: italic;
    }

    .scale-display {
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
        margin-bottom: 5px; /* Reduced margin */
        color: var(--scale-display-color, #333);
        min-height: 1.5em; /* Reserve space */
    }
    /* Next Chord Display Styling */
    .next-chord-display {
        font-size: 0.95em; /* Slightly smaller than scale display */
        font-style: italic;
        text-align: center;
        color: var(--next-chord-color, #6c757d); /* Muted gray color */
        margin-top: -5px; /* Pull it up slightly */
        margin-bottom: 15px; /* Space below before controls */
        height: auto; /* Allow multiple lines */
        min-height: 1.2em; /* Reserve space to prevent layout shift for single line */
        line-height: 1.2em;
    }
    .controls, .top-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
        align-items: center;
    }
    /* MODIFIED: .top-controls for global panel */
    .top-controls {
        justify-content: flex-start; /* Align items to the start */
    }

    .controls-container { display: flex; gap: 20px; margin-bottom: 20px; }
    .control-group { display: flex; align-items: center; gap: 10px; }
    .control-group label { font-weight: bold; }
    .control-group select { padding: 5px; border-radius: 4px; border: 1px solid #ccc; }

    .fretboard {
        position: relative;
        height: 200px;
        background-color: var(--fretboard-bg, #FFCF79);
        border-radius: 5px;
        margin-bottom: 30px;
        border: 2px solid var(--fretboard-border, #4A3B31);
        overflow: visible;
    }
    .fret-line { position: absolute; top: 0; height: 100%; width: 2px; background: #A0A0A0; border-right: 1px solid rgba(0,0,0,0.1); z-index: 1; }
    .string-line { position: absolute; left: 0; width: 100%; height: 1px; background: #C0C0C0; border-bottom: 1px solid rgba(0,0,0,0.1); z-index: 0; }
    .fret-number { position: absolute; bottom: -25px; font-size: 14px; color: #555; transform: translateX(-50%); font-weight: bold; z-index: 2; width: 20px; text-align: center; }
    .fret-marker { position: absolute; width: 10px; height: 10px; background-color: #5A4F46; border-radius: 50%; transform: translate(-50%, -50%); z-index: 1; }
    
    .note {
        position: absolute;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: var(--note-text-color, white); /* Default note text color */
        z-index: 3;
        cursor: pointer;
        transform: translate(-50%, -50%);
        transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s ease, color 0.2s ease, outline 0.2s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        /* background-color is set by JS for regular notes */
    }

    /* UPDATED GUIDE TONE STYLING (Item 3) */
    .note.guide-tone-highlight, .note.root-highlight-for-guides {
        outline: 3px solid var(--guide-tone-border-color) !important;
        box-shadow: 0 0 8px 2px var(--guide-tone-border-color) !important;
        transform: translate(-50%, -50%) scale(0.95) !important; /* Make them slightly smaller */
        z-index: 10 !important;
        font-weight: bold !important;
        border-radius: 50%;
    }
    .note.guide-tone-highlight {
        background-color: var(--guide-tone-bg-color) !important;
        color: var(--guide-tone-text-color) !important;
    }
    .note.root-highlight-for-guides {
        /* Retains its original background and text color from the scale drawing logic */
        /* Specific border for root if needed, defaults to guide tone border */
         outline-color: var(--root-highlight-border-color) !important;
         box-shadow: 0 0 8px 2px var(--root-highlight-border-color) !important;
    }

    .note:hover {
        transform: translate(-50%, -50%) scale(1.2);
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .note.guide-tone-highlight:hover, .note.root-highlight-for-guides:hover {
        transform: translate(-50%, -50%) scale(1.1) !important; /* Slightly larger hover for highlighted notes */
    }


    .beat { width: 40px; height: 80px; background: #9E9E9E; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s ease; font-size: 14px; margin: 0 2px; }
    .beats-container { display: flex; justify-content: center; gap: 8px; margin: 20px 0; flex-wrap: nowrap; overflow-x: auto; }
    .beat.active { transform: translateY(-10px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    #measures { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
    
    .measure { 
        position: relative; 
        background-color: var(--measure-bg, #e9ecef); 
        padding: 10px; /* Reduced padding slightly */
        border-radius: 4px; 
        transition: opacity 0.2s ease, background-color 0.2s ease, border 0.2s ease; 
        border: 2px solid transparent; 
        cursor: pointer; 
        color: var(--measure-text-color, #333); 
        display: flex; /* For split measure layout */
        flex-direction: column; /* Default: Stack parts or part + button */
        gap: 8px; /* Gap between parts or part and button */
    }
    .measure.split-active {
        /* Styles for when measure is split, parts might go side-by-side */
        flex-direction: row; /* Arrange parts side by side */
        align-items: flex-start; /* Align items at the top */
    }
    .measure-part {
        flex: 1; /* Each part takes equal space if side-by-side */
        display: flex;
        flex-direction: column;
        gap: 5px; /* Gap between controls within a part */
        padding: 5px;
        border: 1px dashed var(--measure-part-border-color, #ccc);
        border-radius: 3px;
    }
    .measure.split-active .measure-part {
        min-width: 120px; /* Ensure controls don't get too squished */
    }

    .measure-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
    }
    .measure-number { 
        font-size: 12px; 
        color: var(--measure-text-color, #333);
        background-color: rgba(255,255,255,0.7); 
        padding: 2px 4px; 
        border-radius: 3px; 
    }
    .split-measure-button {
        padding: 3px 6px;
        font-size: 0.8em;
        align-self: flex-end; /* Position button appropriately */
        margin-top: 5px;
    }
    .measure.split-active .split-measure-button {
        /* Adjust button position if measure content is row-based */
        /* This might need to be outside the measure-part flow */
    }
     .measure-footer { /* Container for buttons at the bottom of a measure */
        display: flex;
        justify-content: flex-end; /* Align button to the right */
        margin-top: auto; /* Pushes to the bottom if measure is flex-column */
    }
     .measure.split-active .measure-footer {
        width: 100%; /* Make footer span across if measure becomes row for parts */
        justify-content: center; /* Center button if parts are side-by-side */
        padding-top: 10px;
    }


    .measure.loop-selected { border: 2px solid var(--measure-loop-border, #007bff); background-color: var(--measure-loop-bg, #e6f2ff); }
    .measure.active .measure-part.part-active { background-color: var(--measure-active-bg, #c3e6cb); border: 1px solid var(--measure-active-border, #28a745); }
    .measure.active .measure-part:not(.part-active) { /* Slightly dim inactive part */
        opacity: 0.7;
    }


    .chord-controls, .scale-controls { display: flex; gap: 5px; margin-bottom: 5px; flex-wrap: wrap;}
    .chord-controls select, .scale-controls select { flex: 1; min-width: 60px; }


    .fretboard-section { border: 1px solid #ccc; padding: 15px; border-radius: 8px; background-color: #f9f9f9; }
    body.dark-mode .fretboard-section { background-color: #3a441e; border-color: #606c38; color: #fefae0; }
    body.dark-mode-2 .fretboard-section { background-color: #001f54; border-color: #1282a2; color: #fefcfb; }
    body.dark-mode-3 .fretboard-section { background-color: #a5a58d; border-color: #cb997e; color: #ffe8d6; }
    .fretboard-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; }
    
    .volume-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 5px 0;
        color: var(--volume-control-text-color, inherit);
    }
    #metronome-volume-controls-stack {
        display: flex; /* Initially flex, JS will toggle to none/flex */
        flex-direction: column;
        gap: 8px;
        max-width: 400px;
        margin: 15px auto 20px auto;
    }
    #metronome-volume-controls-stack .volume-control {
        width: 100%;
        justify-content: space-between; 
    }
    #metronome-volume-controls-stack .volume-control label,
    #metronome-volume-controls-stack .volume-control span {
        margin-right: 10px;
        white-space: nowrap;
        flex-shrink: 0; 
    }
    #metronome-volume-controls-stack .volume-control input[type="range"] {
        flex-grow: 1;
        min-width: 150px;
        max-width: 250px;
    }

    /* NEW: Collapsible Section Styling */
    .collapsible-section {
        margin-bottom: 15px;
    }
    .collapsible-toggle {
        width: 100%;
        text-align: left;
        padding: 8px 12px;
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .collapsible-toggle .toggle-icon {
        font-weight: bold;
        transition: transform 0.2s ease-in-out;
    }
    .collapsible-toggle[aria-expanded="true"] .toggle-icon {
        transform: rotate(45deg);
    }
    .collapsible-content {
        border-top: 1px solid var(--subsection-border-color, #ced4da);
        padding-top: 10px;
    }


    button, .button-like { padding: 10px 15px; border: none; border-radius: 5px; background: var(--button-bg, #4CAF50); color: var(--button-text-color, white); cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
    button:hover, .button-like:hover { background: var(--button-hover-bg, #45a049); }
    button.secondary { background-color: var(--button-secondary-bg, #007bff); }
    button.secondary:hover { background-color: var(--button-secondary-hover-bg, #0056b3); }
    button.danger { background-color: var(--button-danger-bg, #6b705c); }
    button.danger:hover { background-color: var(--button-danger-hover-bg, #c82333); }
    select { padding: 8px 10px; margin: 5px; border-radius: 5px; border: 1px solid var(--select-border-color, #ddd); background-color: var(--select-bg-color, white); color: var(--select-text-color, inherit); }
    #tempo-display { font-size: 1.2em; font-weight: bold; margin: 0 10px; min-width: 70px; text-align: center; }
    #loading-indicator { position: fixed; top: 20px; right: 20px; padding: 10px 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 5px; z-index: 1000; font-size: 0.9em; display: none; }
    .checkbox-wrapper { margin-top: 10px; margin-left: 0; display: flex; align-items: center; }
    .control-button { padding: 8px 12px; font-size: 0.9em; }
    #chordsEnabled { margin-bottom: 10px; }

    #start-stop {
        padding: 12px 25px !important;
        font-size: 1.1em !important;
        font-weight: bold !important;
        background-color: var(--start-stop-bg, #28a745) !important;
        border: 2px solid var(--start-stop-border, #1e7e34) !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        color: var(--start-stop-text-color, white) !important;
    }
    #start-stop:hover {
        background-color: var(--start-stop-hover-bg, #218838) !important;
        border-color: var(--start-stop-hover-border, #1c6c2e) !important;
    }

    /* --- Dark Mode 1 --- */
    body.dark-mode {
        --bg-color: #283618;
        --text-color: #fefae0;
        --section-bg-color: linear-gradient(145deg, #283618, #606c38);
        --section-text-color: #fefae0;
        --fretboard-container-bg: #606c38;
        --fretboard-container-border: #dda15e;
        /* Item 1 */ --song-title-fretboard-color: #dda15e; /* Goldish for DM1 */
        --song-info-h4-color: #fefae0;
        --song-info-p-color: #e0daca;
        --fretboard-bg: #dda15e;
        --fretboard-border: #4b4b4b;
        --note-text-color: #283618; /* Note text on fretboard */
        --scale-display-color: #fefae0;
        --button-bg: #dda15e;
        --button-text-color: #283618;
        --button-hover-bg: #bc6c25;
        --button-secondary-bg: #a17d40;
        --button-secondary-hover-bg: #8a6930;
        --button-danger-bg: #6b705c;
        --button-danger-hover-bg: #d73744;
        --start-stop-bg: #fca311;
        --start-stop-border: #e79002;
        --start-stop-text-color: #283618;
        --start-stop-hover-bg: #e79002;
        --start-stop-hover-border: #c87800;
        --select-bg-color: #dda15e;
        --select-text-color: #283618;
        --select-border-color: #bc6c25;
        --measure-bg: #606c38;
        --measure-text-color: #fefae0;
        --measure-border: #dda15e; /* Default border for measure */
        --measure-active-bg: #dda15e;
        --measure-active-border: #bc6c25;
        --measure-loop-bg: #7d6830;
        --measure-loop-border: #ffc107;
        --beat-bg: #dda15e;
        --beat-text-color: #283618;
        --beat-active-bg: #bc6c25;
        --volume-control-text-color: #fefae0;
        --next-chord-color: #fefae0;
        --measure-part-border-color: #dda15e;

        /* NEW: Subsection styling variables for Dark Mode 1 */
        --subsection-bg-color: #2c3e1a;
        --subsection-border-color: #4a5a2a;
        --subsection-title-color: #fefae0;

        /* Dark Mode 1 Guide Tone Colors */
        --guide-tone-bg-color: #61dafb;      /* Light Cyan/Aqua */
        --guide-tone-text-color: #0a1128;    /* Very Dark Blue/Black */
        --guide-tone-border-color: #4ac9e8;   /* Slightly Darker Cyan */
        --root-highlight-border-color: #ffc107; /* Gold for root highlight */
    }
    .dark-mode .app-section { box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
    .dark-mode .scale-display { text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
    .dark-mode .beat.active { transform: translateY(-5px); }
    #dark-mode-toggle.active { background-color: #283618; color: #fefae0; border: 1px solid #dda15e; }

    /* --- Dark Mode 2 --- */
    body.dark-mode-2 {
        --bg-color: #0a1128;
        --text-color: #fefcfb;
        --section-bg-color: linear-gradient(145deg, #001f54, #034078);
        --section-text-color: #fefcfb;
        --fretboard-container-bg: #034078;
        --fretboard-container-border: #1282a2;
        /* Item 1 */ --song-title-fretboard-color: #61dafb; /* Cyan for DM2 */
        --song-info-h4-color: #fefcfb;
        --song-info-p-color: #e0e0df;
        --fretboard-bg: #001f54;
        --fretboard-border: #1282a2;
        --note-text-color: #fefcfb; /* Note text on fretboard */
        --scale-display-color: #fefcfb;
        --button-bg: #1282a2;
        --button-text-color: #fefcfb;
        --button-hover-bg: #0e6c89;
        --button-secondary-bg: #0c5f7d;
        --button-secondary-hover-bg: #094b61;
        --button-danger-bg: #6b705c;
        --button-danger-hover-bg: #e83838;
        --start-stop-bg: #61dafb;
        --start-stop-border: #4ac9e8;
        --start-stop-text-color: #0a1128;
        --start-stop-hover-bg: #4ac9e8;
        --start-stop-hover-border: #32b6d4;
        --select-bg-color: #034078;
        --select-text-color: #fefcfb;
        --select-border-color: #1282a2;
        --measure-bg: #034078;
        --measure-text-color: #fefcfb;
        --measure-border: #1282a2;
        --measure-active-bg: #1282a2;
        --measure-active-border: #fefcfb;
        --measure-loop-bg: #01325A;
        --measure-loop-border: #61dafb;
        --beat-bg: #1282a2;
        --beat-text-color: #fefcfb;
        --beat-active-bg: #034078;
        --volume-control-text-color: #fefcfb;
        --next-chord-color: #fefcfb;
        --measure-part-border-color: #1282a2;

        /* NEW: Subsection styling variables for Dark Mode 2 */
        --subsection-bg-color: #001844;
        --subsection-border-color: #022c60;
        --subsection-title-color: #fefcfb;

        /* Dark Mode 2 Guide Tone Colors */
        --guide-tone-bg-color: #fca311;      /* Bright Orange/Yellow */
        --guide-tone-text-color: #001f54;    /* Dark Blue (contrasts with bg) */
        --guide-tone-border-color: #e79002;   /* Darker Orange */
        --root-highlight-border-color: #61dafb; /* Cyan for root highlight */
    }
    #dark-mode-toggle.active-2 { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }

    /* --- Dark Mode 3 --- */
body.dark-mode-3 {
    --bg-color: #2A2F20; /* Very Dark Olive */
    --text-color: #F0EFEB; /* Warm Off-White */
    --section-bg-color: linear-gradient(145deg, #3A4030, #4A5040); /* Muted Olive/Khaki */
    --section-text-color: #F0EFEB;
    
    --fretboard-container-bg: #4A5040; /* Slightly Lighter Olive from gradient */
    --fretboard-container-border: #8A9A5B; /* Sage Green Accent */

    /* Song Title Color */
    --song-title-fretboard-color: #D97904; /* Burnt Orange/Ochre for pop */
    --song-info-h4-color: #F0EFEB;
    --song-info-p-color: #C8C3BF; /* Lighter grey for less emphasis */

    --fretboard-bg: #A98B73; /* Muted Wood Brown */
    --fretboard-border: #2A2F20; /* Match body background */
    
    /* Note Text on Fretboard */
    --note-text-color: #2A2F20; /* Dark text on lighter fretboard notes */

    --scale-display-color: #F0EFEB;
    
    /* Buttons */
    --button-bg: #D97904; /* Primary Accent - Pop */
    --button-text-color: #2A2F20; /* Dark text for contrast on orange */
    --button-hover-bg: #B46504; /* Darker orange */

    --button-secondary-bg: #8A9A5B; /* Sage Green Accent */
    --button-secondary-hover-bg: #6B7A47; /* Darker Sage */

    --button-danger-bg: #705c5c; /* Muted Desaturated Red/Brown for danger */
    --button-danger-text-color: #F0EFEB;
    --button-danger-hover-bg: #8c3333; /* Darker Muted Red */

    /* Start/Stop Button */
    --start-stop-bg: #D97904 !important; /* Pop color */
    --start-stop-border: #B46504 !important;
    --start-stop-text-color: #2A2F20 !important; /* Dark text */
    --start-stop-hover-bg: #E7A002 !important; /* Slightly Brighter/Golden Orange */
    --start-stop-hover-border: #D97904 !important;

    /* Selects */
    --select-bg-color: #4A5040; /* Mid Khaki from section */
    --select-text-color: #F0EFEB;
    --select-border-color: #8A9A5B; /* Sage Accent */

    /* Measures */
    --measure-bg: #3A4030; /* Darker Khaki from section gradient */
    --measure-text-color: #F0EFEB;
    --measure-border: #8A9A5B; /* Sage for inactive measure (subtle) */
    --measure-active-bg: #5F7365; /* Muted Teal-Green for active measure */
    --measure-active-border: #D97904; /* Orange pop for active border */
    --measure-loop-bg: #505A45; /* Darker, desaturated green for loop */
    --measure-loop-border: #E7A002; /* Gold for loop border */
    --measure-part-border-color: #6B7A47; /* Darker Sage for dashed line */ /* Corrected: only one definition */

    /* Beats */
    --beat-bg: #8A9A5B; /* Sage Green */
    --beat-text-color: #2A2F20; /* Dark Text */
    --beat-active-bg: #D97904; /* Orange Pop for active beat */

    --volume-control-text-color: #F0EFEB;
    --next-chord-color: #C8C3BF; /* Lighter grey */

    /* Subsection specific theming */
    --subsection-bg-color: #31372B; /* Darker Khaki */
    --subsection-border-color: #4A5040;
    --subsection-title-color: #F0EFEB;

    /* Guide Tones */
    --guide-tone-bg-color: #E7A002;      /* Muted Gold/Yellow */
    --guide-tone-text-color: #2A2F20;    /* Dark text */
    --guide-tone-border-color: #D97904;   /* Burnt Orange */
    --root-highlight-border-color: #D9534F; /* Muted Red for root highlight (distinct) */
}

body.dark-mode-3 button.danger { color: var(--button-danger-text-color, white); } 
body.dark-mode-3 #dark-mode-toggle.active-3 { 
    background-color: var(--button-bg); 
    color: var(--button-text-color); 
    border: 1px solid var(--button-hover-bg); 
}

/* Fretflow Section Theming - ensure these are after main theme blocks */
/* Dark Mode 1 - Unchanged */
.dark-mode #fretflow-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; }
/* Dark Mode 2 - Unchanged */
.dark-mode-2 #fretflow-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
/* Dark Mode 3 - UPDATED */
body.dark-mode-3 #fretflow-section { 
    background: var(--section-bg-color); 
    color: var(--text-color); 
    border-color: var(--fretboard-container-border);
}

/* Toggle button styling for DM3 */
body.dark-mode-3 .toggle-button.active {
    background: var(--button-bg); 
    color: var(--button-text-color);
}
body.dark-mode-3 .toggle-button:not(.active) {
    background: var(--button-secondary-bg); 
    color: var(--text-color); 
}

/* Optional Font for DM3 Headings */
body.dark-mode-3 h1, body.dark-mode-3 h2, body.dark-mode-3 h3, body.dark-mode-3 h4 {
    font-family: 'Georgia', serif; 
}

/* Note Styling for DM3 */
body.dark-mode-3 .fretboard .note {
    color: #2A2F20; /* Dark text on note circles */
}
body.dark-mode-3 .fretboard .note.guide-tone-highlight {
    background-color: var(--guide-tone-bg-color) !important; 
    color: var(--guide-tone-text-color) !important; 
}
    /* ====== ADD THESE RESPONSIVE STYLES AT THE END OF YOUR EXISTING CSS ====== */

@media (max-width: 768px) {
    body {
        padding: 10px;
    }
    .app-section, .fretboard-container {
        padding: 15px;
        margin-bottom: 15px;
    }
    .app-subsection {
        padding: 10px;
        margin-bottom: 10px;
    }

    h1 { font-size: 1.6em; }
    h2 { font-size: 1.4em; }
    h3 { font-size: 1.1em; }
    h4 { font-size: 1.0em; }

    .top-controls {
        flex-direction: column; /* Stack global controls */
        align-items: flex-start;
    }
    .top-controls button, .top-controls select {
        width: auto; /* Allow them to size naturally initially */
        margin-bottom: 8px;
    }

    .fretboards-grid {
        grid-template-columns: 1fr; /* Stack FretFlow fretboards */
        gap: 15px;
    }

    .fretboard {
        height: 160px; /* Slightly reduce height */
    }
    .note {
        width: 22px; /* Ensure tappability */
        height: 22px;
        font-size: 11px;
    }
    .note.guide-tone-highlight, .note.root-highlight-for-guides {
        outline-width: 2px;
    }

    #measures {
        grid-template-columns: 1fr; /* Single column for measures */
        gap: 15px;
    }
    .measure.split-active {
        flex-direction: column; /* Stack split measure parts */
    }
     .measure.split-active .measure-part {
        min-width: unset; /* Allow full width */
    }

    .controls, .top-controls, .fretboard-controls, .song-setup-controls .controls, #user-songs-section .controls {
        gap: 8px;
    }
    .controls select, .controls button, .top-controls select, .top-controls button {
        padding: 8px 10px; /* Slightly smaller padding on controls */
        font-size: 0.85em;
    }
    #tempo-display {
        font-size: 1em;
        min-width: 60px;
    }
    #start-stop {
        padding: 10px 20px !important;
        font-size: 1em !important;
    }

    #metronome-volume-controls-stack .volume-control {
        flex-direction: column;
        align-items: flex-start;
    }
    #metronome-volume-controls-stack .volume-control label,
    #metronome-volume-controls-stack .volume-control span {
        margin-bottom: 5px;
    }
    #metronome-volume-controls-stack .volume-control input[type="range"] {
        width: 100%; /* Full width for sliders in stack */
        max-width: none;
    }

    .song-setup-controls h4 {
        font-size: 1.1em;
    }
}

@media (max-width: 480px) {
    body {
        padding: 5px;
    }
    .app-section, .fretboard-container {
        padding: 10px;
    }
    .app-subsection {
        padding: 8px;
    }

    h1 { font-size: 1.4em; }
    h2 { font-size: 1.2em; }
    h3 { font-size: 1.0em; }
    h4 { font-size: 0.9em; }

    #song-info-display-fretboard #current-song-title-fretboard {
        font-size: 1.1em;
    }
    #song-info-display-fretboard p {
        font-size: 0.8em;
    }
    .scale-display { font-size: 1em; }
    .next-chord-display { font-size: 0.85em; }


    /* General controls stacking */
    .controls, .fretboard-controls, .song-setup-controls .controls, #user-songs-section .controls,
    .top-controls /* Already column from 768px */ {
        flex-direction: column; /* Ensure stacking */
        align-items: stretch; /* Make children take full available width */
    }
    .controls > *, .fretboard-controls > *, .song-setup-controls .controls > *, #user-songs-section .controls > *,
    .top-controls > * { /* Target direct children */
        width: 100%; /* Full width for inputs/buttons in stacked controls */
        margin-bottom: 8px;
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    }
    .controls select, .controls button, /* Already targeted by > * */
    .control-group select, .control-group button, .control-group input {
        width: 100%;
        box-sizing: border-box;
    }
    .control-group label { margin-bottom: 3px; }


    .fretboard {
        height: 130px; /* Further reduce height */
        margin-bottom: 20px;
    }
    .fret-number { font-size: 10px; bottom: -20px; }
    .note {
        width: 20px;
        height: 20px;
        font-size: 9px;
    }

    .beats-container {
        margin: 10px 0;
        gap: 5px;
    }
    .beat {
        width: 35px;
        height: 70px;
        font-size: 12px;
    }

    .chord-controls select, .scale-controls select {
        min-width: 50px; /* Further reduce min-width */
        font-size: 0.8em;
        padding: 5px;
    }
    .measure-header .measure-number { font-size: 10px; }
    .split-measure-button { font-size: 0.7em; padding: 2px 4px;}


    #tempo { width: calc(100% - 110px); /* Adjust if tap tempo or display changes significantly */}
    #tempo-display { margin: 0 5px; }

    #start-stop {
        padding: 8px 15px !important;
        font-size: 0.9em !important;
    }

    /* Make sure individual volume control stacks correctly */
    .volume-control {
        flex-direction: column; /* Stack label and input */
        align-items: flex-start; /* Align label to start */
        gap: 5px;
    }
    .volume-control input[type="range"] {
        width: 100%; /* Full width for range inputs */
    }
    .control-group {
        flex-direction: column;
        align-items: flex-start;
    }
    .control-group #reverb-dial {
        width: 100%;
    }

    /* Collapsible sections */
    .collapsible-toggle {
        padding: 6px 10px;
        font-size: 0.9em;
    }
}

/* Minor fix for select dropdowns on dark mode for better visibility with potential width:100% */
body.dark-mode select, body.dark-mode-2 select, body.dark-mode-3 select {
    /* If you set width: 100% on selects, ensure their text is readable and they don't look too out of place */
    /* This is mostly fine, but could add specific padding if needed */
}
        
    </style>
</head>
<body>
    <!-- MODIFIED: Top Controls / Global Panel -->
    <div class="top-controls app-section">
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <!-- Placeholder for future global controls -->
        <button id="swing-toggle" class="toggle-button" style="display: none;">Swing Off</button>
        <select id="note-naming-convention" style="display: none; margin-left: 10px;">
            <option value="default">Note Names: Default</option>
            <option value="sharps">Note Names: Sharps</option>
            <option value="flats">Note Names: Flats</option>
        </select>
    </div>

    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <div id="song-info-display-fretboard">
                <h4 id="current-song-title-fretboard"></h4>
                <p id="current-song-description-fretboard"></p>
            </div>
            <div class="scale-display" id="scale-display">Select a progression and key.</div>
            <div class="next-chord-display" id="next-chord-display"></div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
                <button id="guide-tones-toggle" class="toggle-button" aria-label="Toggle guide tones">Guide Tones Off</button>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls"> 
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option> <option value="3">3/4</option> <option value="4" selected>4/4</option>
                <option value="6">6/8</option> <option value="7">7/8</option> <option value="8">8/8</option> <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option> <option value="woodblock">Woodblock</option> <option value="drums">Drums</option>
            </select>
            <!-- NEW Rhythmic Style Dropdown -->
            <div id="rhythmic-style-container" style="display: none;">
                <label for="rhythmic-style-select">Style:</label>
                <select id="rhythmic-style-select" aria-label="Select rhythmic style">
                    <option value="quarterNotes">Quarter Notes</option>
                    <option value="standardSwing">Standard Swing</option>
                    <option value="freddieGreen">Freddie Green</option>
                    <option value="charleston">Charleston</option>
                    <option value="bossaNova">Bossa Nova</option>
                    <option value="sonClave32">Son Clave (3:2)</option>
                </select>
            </div>
            <button id="drumSetToggleBtn" class="control-button" style="display: none;">Drums</button> 
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>

        <!-- MODIFIED: Collapsible Metronome Volume Controls -->
        <div class="collapsible-section">
            <button class="collapsible-toggle button-like secondary" aria-expanded="false" aria-controls="metronome-volume-controls-stack">
                Advanced Volume Controls <span class="toggle-icon">+</span>
            </button>
            <div id="metronome-volume-controls-stack" class="collapsible-content" style="display: none;">
                <div class="volume-control" id="metronome-master-volume-container">
                    <span>Metronome Volume:</span>
                    <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
                </div>
                <div class="volume-control" id="kick-volume-container" style="display: none;">
                    <label for="kick-volume">Kick Volume:</label>
                    <input type="range" id="kick-volume" min="0" max="1" step="0.05" value="1.0" aria-label="Kick volume">
                </div>
                <div class="volume-control" id="snare-volume-container" style="display: none;">
                    <label for="snare-volume">Snare Volume:</label>
                    <input type="range" id="snare-volume" min="0" max="1" step="0.05" value="0.7" aria-label="Snare volume">
                </div>
                <div class="volume-control" id="hihat-volume-container" style="display: none;">
                    <label for="hihat-volume">Hi-hat Volume:</label>
                    <input type="range" id="hihat-volume" min="0" max="1" step="0.05" value="0.8" aria-label="Hi-hat volume">
                </div>
                <div class="volume-control" id="accent-intensity-container">
                    <label for="accent-intensity">Accent Intensity:</label>
                    <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
                </div>
            </div>
        </div>

        <div class="beats-container"></div>
    </div>

    <!-- MODIFIED: Chord Progression Practice Section -->
    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <div id="song-info-display" style="display: none;">
            <h4 id="current-song-title"></h4>
            <p id="current-song-description"></p>
        </div>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>

        <!-- NEW "Song Setup" Area -->
        <div class="song-setup-controls app-subsection">
            <h4>Song Setup</h4>
            <div class="controls">
                <label for="progression-select">Select Progression:</label>
                <select id="progression-select" aria-label="Select chord progression">
                    <optgroup label="Practice Progressions">
                        <option value="I V7">I-V7</option>
                        <option value="2_5_1">II-V-I</option>
                        <option value="6_2_5_1">VI-II-V-I</option>
                        <option value="minor_2_5_1">Minor iim-V7-im</option>
                        <option value="ii_v_i_all_keys_cycle">ii-V-I All Keys Cycle</option>
                        <option value="same_old_blues">Same Old Blues</option>
                        <option value="key_to_the_highway">Key to the Highway (8 bar blues)</option>
                        <option value="jazz_blues">Jazz Blues</option>
                        <option value="minor_blues">Minor Blues</option>
                        <option value="bird_blues">Bird Blues (Parker Blues)</option>
                        <option value="nows_the_time">Now's The Time (Parker F Blues)</option>
                        <option value="tenor_madness">Tenor Madness (Rollins Bb Blues)</option>
                        <option value="blue_monk">Blue Monk</option>
                        <option value="straight_no_chaser">Straight, No Chaser</option>
                        <option value="rhythm_changes">Rhythm Changes (Standard)</option>
                        <option value="rhythm_changes_bebop">Rhythm Changes (Bebop)</option>
                        <option value="oleo">Oleo (Rhythm Changes)</option>
                    </optgroup>
                    <optgroup label="Easy Jazz Standards">
                        <option value="all_of_me">All of Me</option>
                        <option value="autumn_leaves">Autumn Leaves</option>
                        <option value="blue_bossa">Blue Bossa</option>
                        <option value="embraceable_you">Embraceable You</option>
                        <option value="girl_from_ipanema">Girl From Ipanema (Authentic Bossa)</option>
                        <option value="girl_from_ipanema_jazz">Girl From Ipanema (Jazz Variant)</option>
                        <option value="in_a_sentimental_mood">In a Sentimental Mood</option>
                        <option value="just_friends">Just Friends</option>
                        <option value="misty">Misty</option>
                        <option value="my_funny_valentine">My Funny Valentine</option>
                        <option value="someday_my_prince_will_come">Someday My Prince Will Come</option>
                        <option value="summertime">Summertime</option>
                        <option value="take_the_a_train">Take the "A" Train</option>
                        <option value="there_will_never_be_another_you">There Will Never Be Another You</option>
                    </optgroup>
                    <optgroup label="Gypsy Jazz Standards">
                        <option value="after_youve_gone_gypsy">After You've Gone (Gypsy)</option>
                        <option value="belleville_gypsy">Belleville (Gypsy)</option>
                        <option value="dark_eyes">Dark Eyes</option>
                        <option value="djangology">Djangology</option>
                        <option value="douce_ambiance_gypsy">Douce Ambiance (Gypsy)</option>
                        <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams (Django)</option>
                        <option value="ill_see_you_in_my_dreams_alternate">I'll See You In My Dreams (Django Alt.)</option>
                        <option value="jattendrai_gypsy">J'attendrai (Gypsy)</option>
                        <option value="limehouse_blues_gypsy">Limehouse Blues (Gypsy)</option>
                        <option value="minor_swing">Minor Swing</option>
                        <option value="nuages">Nuages</option>
                        <option value="rose_room_django">Rose Room (Django)</option>
                        <option value="sweet_georgia_brown_gypsy">Sweet Georgia Brown (Gypsy)</option>
                        <option value="swing_42_gypsy">Swing 42 (Gypsy)</option>
                    </optgroup>
                    <optgroup label="More Complex Jazz Standards">
                        <option value="a_night_in_tunisia">A Night in Tunisia</option>
                        <option value="all_the_things_you_are">All The Things You Are</option>
                        <option value="black_orpheus">Black Orpheus (Manhã de Carnaval)</option>
                        <option value="body_and_soul">Body and Soul</option>
                        <option value="caravan">Caravan</option>
                        <option value="cherokee">Cherokee</option>
                        <option value="coltrane_changes">Coltrane Changes (Giant Steps Cycle)</option>
                        <option value="confirmation">Confirmation</option>
                        <option value="days_of_wine_and_roses">Days of Wine and Roses</option>
                        <option value="dolphin_dance">Dolphin Dance (Main 16-bar theme)</option>
                        <option value="donna_lee">Donna Lee</option>
                        <option value="footprints">Footprints (12-bar modal blues)</option>
                        <option value="how_high_the_moon">How High the Moon</option>
                        <option value="impressions">Impressions</option>
                        <option value="moments_notice">Moment's Notice (Main 16-bar theme)</option>
                        <option value="on_green_dolphin_street">On Green Dolphin Street</option>
                        <option value="recorda_me">Recorda Me (Main 16-bar theme)</option>
                        <option value="rose_room">Rose Room (Traditional)</option>
                        <option value="so_what">So What</option>
                        <option value="solar">Solar</option>
                        <option value="stella_by_starlight">Stella By Starlight</option>
                    </optgroup>
                     <optgroup label="Rock">
                        <option value="something_beatles">Something – The Beatles</option>
                        <option value="let_it_be">Let It Be – The Beatles</option>
                        <option value="here_comes_the_sun">Here Comes the Sun – The Beatles</option>
                        <option value="hey_jude">Hey Jude – The Beatles</option>
                        <option value="althea_dead">Althea – Grateful Dead</option>
                        <option value="loser_dead">Loser – Grateful Dead</option>
                        <option value="dead_flowers_stones">Dead Flowers – Rolling Stones</option>
                        <option value="honky_tonk_woman">Honky Tonk Woman – Rolling Stones</option>
                        <option value="black_magic_woman">Black Magic Woman – Santana</option>
                        <option value="bittersweet_bhtm">Bittersweet – Big Head Todd & the Monsters</option>
                    </optgroup>
                </select>
                <label for="keySelect">Select Key:</label>
                <select id="keySelect" aria-label="Select key">
                  <option value="C">C</option> <option value="Cm">Cm</option> <option value="Db">Db</option> <option value="Dbm">Dbm</option> <option value="D">D</option> <option value="Dm">Dm</option> <option value="Eb">Eb</option> <option value="Ebm">Ebm</option> <option value="E">E</option> <option value="Em">Em</option> <option value="F">F</option> <option value="Fm">Fm</option> <option value="Gb">Gb</option> <option value="Gbm">Gbm</option> <option value="G">G</option> <option value="Gm">Gm</option> <option value="Ab">Ab</option> <option value="Abm">Abm</option> <option value="A">A</option> <option value="Am">Am</option> <option value="Bb">Bb</option> <option value="Bbm">Bbm</option> <option value="B">B</option> <option value="Bm">Bm</option>
                </select>
                <button id="loop-selected-toggle" class="toggle-button" aria-label="Toggle measure looping">Looping Off</button>
            </div>
        </div>

        <div id="user-songs-section" class="controls">
            <label for="user-progression-select">Your Saved Songs:</label>
            <select id="user-progression-select" aria-label="Select your saved chord progression">
                <option value="">-- Select a saved song --</option>
            </select>
            <button id="delete-user-song-button" class="danger">Delete Selected Song</button>
        </div>

        <div id="measures"></div>

        <div class="controls">
            <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
            <button onclick="removeMeasure()" aria-label="Remove measure">Remove Last Measure</button>
            <button id="save-progression-button" class="secondary" aria-label="Save current progression">Save Current Progression</button>
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.5" aria-label="Chord volume">
        </div>
        <div class="control-group">
              <label for="reverb-dial">Reverb</label>
              <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
              <span id="reverb-dial-value">20</span>%
         </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <div class="fretboards-grid"></div>
</div>
    <div id="loading-indicator"></div>
    <script>
// ==================================
// === UTILITY FUNCTIONS ==========
// ==================================

/**
 * Logs a message to the console with a prefix.
 * @param {string} message - The message to log.
 */
function log(message) {
    console.log(`[Bebop Blueprint Debug] ${message}`);
}

/**
 * Updates and shows/hides a loading indicator.
 * @param {string} message - The message to display in the indicator.
 * @param {boolean} [isVisible=true] - Whether the indicator should be visible.
 */
function updateLoadingStatus(message, isVisible = true) {
    let i = document.getElementById('loading-indicator');
    if (!i) {
        i = document.createElement('div');
        i.id = 'loading-indicator';
        document.body.appendChild(i);
    }
    i.textContent = message;
    i.style.display = isVisible ? 'block' : 'none';
}

// ==================================
// === MUSICAL CONSTANTS ==========
// ==================================

const NOTES = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
const NOTES_CHROMATIC = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
const ALL_NOTES_FOR_SAMPLES = ["a", "as", "b", "c", "cs", "d", "ds", "e", "f", "fs", "g", "gs"];
const OCTAVES_FOR_SAMPLES = [2, 3, 4, 5];
const PLAYBACK_OCTAVES = [3, 4]; // Preferred octaves for chord playback
const FILE_FORMAT = "wav";

const SAMPLE_NOTE_MAP = {
  C: "c", Db: "cs", "C#": "cs", D: "d", Eb: "ds", "D#": "ds", E: "e", F: "f",
  Gb: "fs", "F#": "fs", G: "g", Ab: "gs", "G#": "gs", A: "a", Bb: "as", "A#": "as", B: "b",
  CS: "cs", DS: "ds", FS: "fs", GS: "gs", AS: "as",
};

const FRETBOARD_NOTES_OCTAVES = {
  string1: ["E4", "F4", "Fs4", "G4", "Gs4", "A4", "As4", "B4", "C5", "Cs5", "D5", "Ds5", "E5"],
  string2: ["B3", "C4", "Cs4", "D4", "Ds4", "E4", "F4", "Fs4", "G4", "Gs4", "A4", "As4", "B4"],
  string3: ["G3", "Gs3", "A3", "As3", "B3", "C4", "Cs4", "D4", "Ds4", "E4", "F4", "Fs4", "G4"],
  string4: ["D3", "Ds3", "E3", "F3", "Fs3", "G3", "Gs3", "A3", "As3", "B3", "C4", "Cs4", "D4"],
  string5: ["A2", "As2", "B2", "C3", "Cs3", "D3", "Ds3", "E3", "F3", "Fs3", "G3", "Gs3", "A3"],
  string6: ["E2", "F2", "Fs2", "G2", "Gs2", "A2", "As2", "B2", "C3", "Cs3", "D3", "Ds3", "E3"],
};

const SCALES = {
  major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10],
  harmonicMinor: [0, 2, 3, 5, 7, 8, 11], melodicMinor: [0, 2, 3, 5, 7, 9, 11],
  dorian: [0, 2, 3, 5, 7, 9, 10], phrygian: [0, 1, 3, 5, 7, 8, 10],
  lydian: [0, 2, 4, 6, 7, 9, 11], mixolydian: [0, 2, 4, 5, 7, 9, 10],
  locrian: [0, 1, 3, 5, 6, 8, 10], bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11],
  bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11], bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10],
  bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10], altered: [0, 1, 3, 4, 6, 8, 10],
  lydianDominant: [0, 2, 4, 6, 7, 9, 10], diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11],
  diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10], wholeTone: [0, 2, 4, 6, 8, 10],
  pentatonicMajor: [0, 2, 4, 7, 9], pentatonicMinor: [0, 3, 5, 7, 10],
  blues: [0, 3, 5, 6, 7, 10], majorBlues: [0, 2, 3, 4, 7, 9],
  harmonicMajor: [0, 2, 4, 5, 7, 8, 11], doubleHarmonic: [0, 1, 4, 5, 7, 8, 11],
  enigmatic: [0, 1, 4, 6, 8, 10, 11], persian: [0, 1, 4, 5, 6, 8, 11],
  arabic: [0, 2, 4, 5, 6, 8, 10], japanese: [0, 2, 5, 7, 8],
  egyptian: [0, 2, 5, 7, 10],
};

const TUNINGS = {
  standard: ["E", "A", "D", "G", "B", "E"], // Low E to High E
  dropD:    ["D", "A", "D", "G", "B", "E"],
  openG:    ["D", "G", "D", "G", "B", "D"],
  DADGAD:   ["D", "A", "D", "G", "A", "D"],
  openE:    ["E", "B", "E", "Ab", "B", "E"],
};

const CHORD_INTERVALS = {
  maj: [0, 4, 7], min: [0, 3, 7], dim: [0, 3, 6], aug: [0, 4, 8],
  sus4: [0, 5, 7], sus2: [0, 2, 7],
  maj7: [0, 4, 7, 11], dom7: [0, 4, 7, 10], min7: [0, 3, 7, 10],
  min7b5: [0, 3, 6, 10], dim7: [0, 3, 6, 9],
  maj6: [0, 4, 7, 9], min6: [0, 3, 7, 9],
  dom7b9: [0, 4, 7, 10, 1],
  "dom7#9": [0, 4, 7, 10, 3],
  dom7b5: [0, 4, 6, 10],
  alt: [0, 4, 1, 6, 10], // Typically Root, 3rd, b9, #11 (or b5), b7
  dom7sus: [0, 5, 7, 10],
  maj9: [0, 4, 7, 11, 2],
  dom9: [0, 4, 7, 10, 2],
  min9: [0, 3, 7, 10, 2],
  imaj7: [0, 3, 7, 11], // minor-major 7th
  "6": [0, 4, 7, 9], // Same as maj6
  "m6": [0, 3, 7, 9], // Same as min6
  "6/9": [0, 4, 7, 9, 2], // Maj6 add 9
  "7#11": [0, 4, 7, 10, 6], // Dominant 7 #11
  "maj7#11": [0, 4, 7, 11, 6], // Major 7 #11
  "7b13": [0, 4, 7, 10, 8], // Dominant 7 b13
  unknown: [0, 4, 7, 10], // Default to dom7 if quality is truly unknown
};

const drumSoundSets = [
  { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" },
  { name: "Makaya", snare: "Snare2.wav", hihat: "HiHat2.wav", kick: "Kick2.wav" },
  { name: "PhillyJoe", kick: "jazzkick.wav", snare: "jazzsnare.wav", hihat: "jazzhat.wav" },
];

const progressions = {
  "I V7": {
    defaultKey: "C",
    displayName: "I-V7",
    progression: ["Imaj7", "V7"],
    description: "A classic two-chord progression often used in jazz standards for a simple, elegant harmonic resolution.",
  },
  jazz_blues: {
    defaultKey: "Bb",
    displayName: "Jazz Blues",
    progression: [
      "Bb7", "Eb7", "Bb7", "Bb7",
      "Eb7", "Eb7", "Bb7", "G7",
      "Cm7", "F7", "Bb7", "F7"
    ],
    description: "A swinging 12-bar blues with jazzy substitutions, perfect for improvisation and soulful melodies.",
  },
  minor_blues: {
    defaultKey: "Cm",
    displayName: "Minor Blues",
    progression: [
      "Cm7", "Cm7", "Cm7", "Cm7",
      "Fm7", "Fm7", "Cm7", "Cm7",
      "G7alt", "G7alt", "Cm7", "G7alt"
    ],
    description: "A moody minor blues progression with a melancholic vibe, ideal for expressive solos.",
  },
  rhythm_changes: { 
    defaultKey: "Bb",
    displayName: "Rhythm Changes (Standard)",
    progression: [
      "Bbmaj7 G7",    "Cm7 F7", "Bbmaj7 G7",    "Cm7 F7", // A1 (measures 1-4)
      "Bbmaj7 G7",    "Cm7 F7", "Bbmaj7 Bb7",   "Ebmaj7 Edim7", // A2 (measures 5-8)
      "Dm7 G7",    "Cm7 F7", "Bbmaj7 F7",  "Bbmaj7 F7", // B (measures 9-12, some variations exist for last 2)
      "Bbmaj7 G7",    "Cm7 F7", "Bbmaj7 G7",    "Cm7 F7"  // A3 (measures 13-16)
    ],
     description: "A fast-paced, iconic jazz structure based on Gershwin's 'I Got Rhythm,' great for bebop. This is the standard 32-bar AABA form with traditional changes. (Showing 16 bars, repeat for full form)"
  },
  rhythm_changes_bebop: { 
    defaultKey: "Bb",
    displayName: "Rhythm Changes (Bebop)",
    progression: [
      "Bbmaj7 Bdim7", "Cm7 F7", "Dm7 G7",    "Cm7 F7",
      "Bbmaj7 Bdim7", "Cm7 F7", "Dm7 Db7",   "Cm7 F7", // Some use G7 Db7 here
      "D7",     "D7",    "G7",     "G7", 
      "C7",     "C7",    "F7",     "F7",
      "Bbmaj7 Bdim7", "Cm7 F7", "Dm7 G7",    "Cm7 F7"
    ],
    description: "A bebop-oriented variation of Rhythm Changes with more sophisticated substitutions and a dominant cycle bridge, commonly used in jam sessions and bebop performances. (Showing common 20 bar variant, full AABA is 32)"
  },
  "2_5_1": {
    defaultKey: "C",
    displayName: "II-V-I",
    progression: ["iim7", "V7", "Imaj7", "Imaj7"],
    description: "The quintessential jazz turnaround, providing a smooth and satisfying resolution.",
  },
  "6_2_5_1": {
    defaultKey: "C",
    displayName: "VI-II-V-I",
    progression: ["vim7", "iim7", "V7", "Imaj7"],
    description: "An extended version of the 2-5-1, starting on the vi minor for a richer harmonic journey.",
  },
  minor_2_5_1: {
    defaultKey: "Gm", 
    displayName: "Minor iim-V7-im",
    progression: ["Am7b5", "D7alt", "Gm7", "Gm7"],
    description: "A dramatic minor key progression, often used for intense and emotional resolutions.",
  },
 "ii_v_i_all_keys_cycle": {
    defaultKey: "C",
    displayName: "251 All Keys Cycle",
    progression: [
      // Key of C
      "Dm7", "G7", "Cmaj7", "Cmaj7",
      "Dm7", "G7", "Cmaj7", "Cmaj7",
      // Key of F
      "Gm7", "C7", "Fmaj7", "Fmaj7",
      "Gm7", "C7", "Fmaj7", "Fmaj7",
      // Key of Bb
      "Cm7", "F7", "Bbmaj7", "Bbmaj7",
      "Cm7", "F7", "Bbmaj7", "Bbmaj7",
      // Key of Eb
      "Fm7", "Bb7", "Ebmaj7", "Ebmaj7",
      "Fm7", "Bb7", "Ebmaj7", "Ebmaj7",
      // Key of Ab
      "Bbm7", "Eb7", "Abmaj7", "Abmaj7",
      "Bbm7", "Eb7", "Abmaj7", "Abmaj7",
      // Key of Db
      "Ebm7", "Ab7", "Dbmaj7", "Dbmaj7",
      "Ebm7", "Ab7", "Dbmaj7", "Dbmaj7",
      // Key of Gb
      "Abm7", "Db7", "Gbmaj7", "Gbmaj7",
      "Abm7", "Db7", "Gbmaj7", "Gbmaj7",
      // Key of B
      "C#m7", "F#7", "Bmaj7", "Bmaj7",
      "C#m7", "F#7", "Bmaj7", "Bmaj7",
      // Key of E
      "F#m7", "B7", "Emaj7", "Emaj7",
      "F#m7", "B7", "Emaj7", "Emaj7",
      // Key of A
      "Bm7", "E7", "Amaj7", "Amaj7",
      "Bm7", "E7", "Amaj7", "Amaj7",
      // Key of D
      "Em7", "A7", "Dmaj7", "Dmaj7",
      "Em7", "A7", "Dmaj7", "Dmaj7",
      // Key of G
      "Am7", "D7", "Gmaj7", "Gmaj7",
      "Am7", "D7", "Gmaj7", "Gmaj7"
    ],
    description: "A comprehensive workout cycling the ii-V-I-I progression through all twelve keys via the circle of fourths. Each key's progression is played twice."
  }, 
  same_old_blues: {
    defaultKey: "D",
    displayName: "Same Old Blues",
    progression: [
      "D", "F#7", "Bm", "Bm",
      "D", "F#7", "Bm", "Am7 D9",
      "G", "G#dim", "D/A D/C", "B7", // D/A D/C implies D/A for 2 beats, D/C for 2 beats
      "E7", "A7", "D", "A+"
    ],
    description: "Freddie King's soulful blues in D, blending major, minor, and diminished chords for a melancholic yet expressive vibe, perfect for soulful solos.",
  },
  key_to_the_highway: {
    defaultKey: "A",
    displayName: "Key to the Highway",
    progression: [
      "A7", "E7", "D7", "D7",
      "A7", "E7", "A7", "E7"
    ],
    description: "An 8-bar blues in A, popularized by various artists, with a laid-back groove ideal for vocal and instrumental interplay.",
  },
  dark_eyes: { 
    defaultKey: "Dm",
    displayName: "Dark Eyes",
    progression: [
      "Dm", "Dm", "A7", "A7", "A7", "A7", "Bbmaj7", "Bbmaj7", 
      "Gm", "Gm", "Dm", "Dm", "A7", "A7", "Dm", "Dm"
    ],
    description: "A passionate, Gypsy jazz-inspired progression with a fiery, Eastern European flair.",
  },
  ill_see_you_in_my_dreams: { 
    defaultKey: "F", 
    displayName: "I'll See You In My Dreams (Django)",
     progression: [ 
      "F6", "F6", "Fm6", "Fm6", "C6",  "B7", "C6",  "C6",
      "A7", "A7", "D7", "D7", "G7", "G7", "C7", "C7",
      "F6", "F6", "Fm6", "Fm6", "C6",  "B7", "F6",  "D7",
      "Gm7", "C7", "F6", "F6" 
    ],
    description: "A popular Django Reinhardt arrangement, characterized by 6th chords."
  },
  ill_see_you_in_my_dreams_alternate: { 
    defaultKey: "Bb",
    displayName: "I'll See You In My Dreams (Django Alt.)",
    progression: [
      "Bbmaj6 G7",     "Cm7 F7",     "Bbmaj6 Bbmin6", "Fmaj6 F7",
      "Bbmaj6 D7",     "Gm7 C7",     "Fmaj6 F#dim7", "Bbmaj6 F7",
      "Bbmaj6 G7",     "Cm7 F7",     "Bbmaj6 Bbmin6", "Fmaj6 F7",
      "Bbmaj6 D7",     "Gm7 C7",     "Fmaj6 F7",     "Bbmaj6 Bbmaj6"
    ],
    description: "An alternate Django-style arrangement featuring both the characteristic 6th chords and the passing diminished chords often used in Gypsy jazz interpretations."
  },
  rose_room: { 
    defaultKey: "Ab", 
    displayName: "Rose Room (Traditional)",
    progression: [ 
      "Abmaj7","Abmaj7","Dbmaj7","Dbmaj7", "Abmaj7","Eb7",   "Abmaj7","Abmaj7",
      "Abmaj7","Abmaj7","Dbmaj7","Dbmaj7", "Fm7",   "Bb7",   "Ebmaj7","Eb7",
      "Abmaj7","Abmaj7","Dbmaj7","Dbmaj7", "Abmaj7","Cm7b5 F7","Bbm7",  "Eb7",
      "Abmaj7","Dbmaj7","Abmaj7","F7",     "Bbm7",  "Eb7",   "Abmaj7","(Eb7)"
    ],
    description: "The authentic 'Rose Room' progression with the traditional harmonization favored by swing and early jazz players."
  },
  rose_room_django: { 
    defaultKey: "Ab", 
    displayName: "Rose Room (Django)",
    progression: [
      "Ab6",    "Eb7",    "Ab6", "Ab6", "Bbm6",   "Eb7",    "Ab6", "Ab6",
      "Ab6",    "C7",     "Fm6", "Fm6", "Bbm7",   "Eb7",    "Ab6", "Eb7",
      "Db6",    "Dbm6",   "Ab6", "F7",  "Bbm7",   "Eb7",    "Ab6", "Eb7",
      "Ab6",    "C7",     "Fm6", "Bb7", "Bbm7",   "Eb7",    "Ab6", "Ab6"
    ],
    description: "A Django Reinhardt-influenced version of 'Rose Room' with characteristic Gypsy jazz voicings and substitutions."
  },
  black_orpheus: { 
    defaultKey: "Am",
    displayName: "Black Orpheus (Manhã de Carnaval)",
    progression: [
      "Am7",  "Am7", "Bm7b5 E7b9", "Am7",  "Dm7",    "G7",   "Cmaj7",
      "Fmaj7","Bm7b5", "E7b9", "Am7","Am7", "A7",    "Dm7",   "G7",
      "Cmaj7","Fmaj7", "Bm7b5 E7b9","Am7",  "E7b9", "Am7",   "Am7"
    ],
    description: "A bossa nova classic with a haunting minor key, inspired by Brazilian rhythms."
  },
  all_the_things_you_are: {
    defaultKey: "Ab",
    displayName: "All The Things You Are",
    progression: [
        "Fm7",    "Bbm7",   "Eb7",    "Abmaj7",
        "Dbmaj7", "Dm7b5",  "G7",     "Cmaj7",
        "Cm7",    "Fm7",    "Bb7",    "Ebmaj7",
        "Abmaj7", "Am7b5",  "D7b9",   "Gmaj7",
        "Gmaj7",  "Am7",    "D7",     "Gmaj7", 
        "Gmaj7",  "F#m7b5", "B7b9",   "Emaj7", 
        "Emaj7",  "Am7 D7", "Gmaj7 C7","Fm7 Bb7", 
        "Ebmaj7 Abmaj7","Dbmaj7 G7","Cmaj7", "(Cmaj7)" 
    ],
    description: "Kern & Hammerstein standard. A cornerstone of the jazz repertoire known for its modulations.",
  },
  all_of_me: { 
    defaultKey: "C",
    displayName: "All of Me",
    progression: [
      "Cmaj7", "E7",    "A7",    "Dm7",
      "E7",    "Am7",   "D7",    "Dm7 G7",
      "Cmaj7", "E7",    "A7",    "Dm7",
      "Fmaj7", "Fm6",   "Cmaj7", "G7", 
      "C6" ,   "A7" ,   "Dm7",    "G7" 
    ],
    description: "A cheerful, upbeat standard with a catchy progression, great for vocal jazz.",
  },
  stella_by_starlight: { 
    defaultKey: "Bb",
    displayName: "Stella By Starlight",
    progression: [
      "Em7b5 A7alt",  "Cm7 F7",
      "Fm7 Bb7",    "Ebmaj7 Ab7", 
      "Dm7b5 G7alt",  "Cmaj7 Am7 D7", 
      "Gm7 C7",     "Fm7 Bb7",
      "Ebmaj7 Ebdim7", "Dm7 G7alt",
      "Cm7 F7",     "Bbmaj7", "Bbmaj7 (Em7b5 A7alt for repeat)"
    ],
    description: "A lush, cinematic progression with a romantic and introspective feel."
  },
  autumn_leaves: { 
    defaultKey: "Gm", 
    displayName: "Autumn Leaves",
    progression: [
      "Cm7 F7",    "Bbmaj7 Ebmaj7",
      "Am7b5 D7alt", "Gm7",    "Gm7 (C7 for turnaround to F7)", // Second Gm7 is often a C7
      "Cm7 F7",    "Bbmaj7 Ebmaj7",
      "Am7b5 D7alt", "Gm7 G7alt", "Cm7 F7 (or Gm for end)" 
    ],
    description: "A melancholic jazz standard evoking falling leaves and wistful nostalgia."
  },
  summertime: { 
    defaultKey: "Am", 
    displayName: "Summertime",
    progression: [
      "Am7", "Am7", "E7",  "E7",
      "Am7", "Am7", "Dm7", "Am7",
      "Dm7", "Am7", "E7",  "Am7 (E7alt for repeat)",
      "Am7" 
    ],
    description: "A sultry, soulful progression from Gershwin's opera, perfect for laid-back grooves."
  },
  girl_from_ipanema: { 
    defaultKey: "F",
    displayName: "Girl From Ipanema (Authentic Bossa)",
    progression: [
      "Fmaj7",  "Fmaj7",  "G7", "G7", 
      "Gm7",    "Gb7#11",    "Fmaj7", "Gb7#11", 
      "Fmaj7",  "Fmaj7",  "G7", "G7",
      "Gm7",    "C7",     "Fmaj7", "Fmaj7", 
      "F#maj7", "F#maj7", "B7",   "B7",    
      "Bm7",    "E7",     "Amaj7","Amaj7",
      "Abm7",   "Db7",    "Gbmaj7","Gbmaj7",
      "Gm7",    "C7",     "Fmaj7", "Fmaj7"  
    ],
    description: "The authentic bossa nova classic by Antonio Carlos Jobim with the traditional modulation."
  },
  girl_from_ipanema_jazz: { 
    defaultKey: "F",
    displayName: "Girl From Ipanema (Jazz Variant)",
    progression: [
      "Fmaj7",  "D7alt",  "Gm9",    "C13",
      "Am9",    "D7b9",   "Gm9",    "C13", 
      "Fmaj7",  "D7alt",  "Gm9",    "C13",
      "Am9",    "D7b9",   "Gm9",    "C13",
      "F#maj7", "C#7alt", "Bbm9",   "Eb13", 
      "Abm9",   "Db7b9",  "Bbm9",   "Eb13",
      "Fmaj7",  "D7alt",  "Gm9",    "C13",  
      "Am9",    "D7b9",   "Gm9",    "C13"
    ],
    description: "A jazzier interpretation of 'Girl From Ipanema' with extended harmonies and common jazz substitutions."
  },
  coltrane_changes: { 
    defaultKey: "Bb", 
    displayName: "Coltrane Changes (Giant Steps Cycle)",
    progression: [
      "Bbmaj7 D7",    "Gmaj7 Bb7",
      "Ebmaj7 Gb7",   "Cbmaj7 E7", 
      "Amaj7 C7",    "Fmaj7 Ab7",
      "Dbmaj7 E7",    "Amaj7 C7" 
    ],
    description: "A challenging, innovative progression from John Coltrane, with rapid key shifts based on major thirds."
  },
  bird_blues: { 
    defaultKey: "F",
    displayName: "Bird Blues (Parker Blues)",
    progression: [ 
      "Fmaj7",  "Em7b5 A7alt", "Dm7 G7alt", "Cm7 F7",
      "Bbmaj7", "Bbm7 Eb7",    "Am7 D7alt", "Abm7 Db7",
      "Gm7",    "C7alt",       "Fmaj7 D7alt", "Gm7 C7alt"
    ],
    description: "A bebop blues progression inspired by Charlie Parker, full of energy and drive."
  },
  just_friends: { 
    defaultKey: "F", 
    displayName: "Just Friends",
    progression: [
      "Fmaj7", "A7",    "Dm7", "G7",
      "Gm7",   "C7",    "Fmaj7", "C7",
      "Fmaj7", "A7",    "Dm7", "G7",
      "Gm7",   "C7",    "Fmaj7", "Fmaj7",
      "Bbmaj7","Bbm7",  "Fmaj7", "D7",
      "Gm7",   "C7",    "Am7 D7", "Gm7 C7", 
      "Fmaj7", "A7",    "Dm7", "G7",
      "Gm7",   "C7",    "Fmaj7", "Fmaj7"
    ],
    description: "A lively, upbeat standard with a playful harmonic structure, great for swing."
  },
  blue_bossa: { 
    defaultKey: "Cm",
    displayName: "Blue Bossa",
    progression: [
      "Cm7",  "Cm7",  "Fm7",  "Fm7",
      "Dm7b5 G7alt","Cm7",  "Cm7 (Ab7 for bridge)", 
      "Ebm7 Ab7",  "Dbmaj7","Dbmaj7",
      "Dm7b5 G7alt","Cm7",  "(G7alt for repeat or Cm7 for end)"
    ],
    description: "A cool, Latin-jazz progression with a relaxed yet groovy bossa nova feel."
  },
  on_green_dolphin_street: { 
    defaultKey: "Eb", 
    displayName: "On Green Dolphin Street",
    progression: [
      "Ebmaj7", "Ebmaj7", "Ebm7 Ab7",   
      "Dbmaj7", "Dbmaj7", "Dm7b5 G7alt",
      "Cm7",    "Cm7",    "Fm7 Bb7",
      "Ebmaj7", "Am7b5 D7b9", "Gm7 C7alt", 
      "Fm7 Bb7",    "Ebmaj7", "Ebmaj7"
    ],
    description: "A modal, cinematic progression with a mysterious and captivating atmosphere."
  },
  solar: { 
    defaultKey: "Cm",
    displayName: "Solar",
    progression: [
      "Cm(maj7)", "Cm(maj7)", "Gm7b5 C7alt",
      "Fmaj7",    "Fmaj7",    "Fm7 Bb7",
      "Ebmaj7",   "Ebmaj7",   "Am7b5 D7alt", 
      "Gm7 C7alt",    "Fmaj7",  "Fmaj7 (or turnaround)"
    ],
    description: "A contemplative, Miles Davis original with a flowing, introspective harmonic line."
  },
  misty: { 
    defaultKey: "Eb",
    displayName: "Misty",
    progression: [
      "Ebmaj7", "Bbm7 Eb7",   "Abmaj7",
      "Abm7 Db7",   "Ebmaj7 Cm7",
      "Fm7 Bb7",   "Gm7 C7alt",
      "Fm7 Bb7",   "Ebmaj7","(Fm7 Bb7 for repeat or Eb6 for end)"
    ],
    description: "A tender, romantic ballad progression, evoking misty-eyed sentimentality."
  },
  days_of_wine_and_roses: { 
    defaultKey: "F",
    displayName: "Days of Wine and Roses",
    progression: [
      "Fmaj7", "Eb7#11", "Dm7 G7#11", 
      "Cm7 F7",     "Bbmaj7","Bbm7 Eb7",
      "Am7 D7",     "Gm7 C7",
      "Fmaj7", "Dm7 Gm7","C7sus C7","F6"
    ],
    description: "A bittersweet, elegant progression with a waltzing, reflective quality."
  },
  cherokee: { 
    defaultKey: "Bb",
    displayName: "Cherokee",
    progression: [ 
      "Bbmaj7", "Bbmaj7","Bbmaj7", "Bbmaj7", "Cm7 F7",    "Bbmaj7", "Bbmaj7",
      "Bbmaj7", "Bbmaj7","Bbmaj7", "Bbmaj7", "Cm7 F7",    "Bbmaj7", "Bb7", 
      "Bmaj7",  "Bmaj7", "Emaj7",  "Emaj7",  "Amaj7",  "Amaj7", "Dmaj7",  "Dmaj7",
      "Gmaj7",  "Gmaj7", "Cmaj7",  "Cmaj7",  "Fmaj7",  "Fmaj7", "Bb7",    "Bb7",
      "Bbmaj7", "Bbmaj7","Bbmaj7", "Bbmaj7", "Cm7 F7",    "Bbmaj7", "Bbmaj7"
    ],
    description: "A high-energy bebop standard with a fast-moving, adventurous harmonic structure."
  },
  caravan: { 
    defaultKey: "Fm",
    displayName: "Caravan",
    progression: [ 
      "Fm7", "Fm7", "Fm7", "C7b9", "Fm7", "Fm7", "C7b9","Fm7", 
      "Abmaj7","Abmaj7","Dbmaj7","Dbmaj7","Gm7b5 C7b9",  "Fm7",   "Fm7"  
    ],
    description: "An exotic, Latin-tinged progression with a hypnotic, caravan-like rhythm."
  },
  nows_the_time: { 
    defaultKey: "F",
    displayName: "Now's The Time (Parker F Blues)",
    progression: [ 
      "F7", "Bb7", "F7", "F7",
      "Bb7","Bb7", "F7", "D7alt",
      "Gm7 C7",  "F7", "(Gm7 C7 or F7)"
    ],
    description: "A gritty, straightforward blues progression by Charlie Parker, full of soul."
  },
  tenor_madness: { 
    defaultKey: "Bb",
    displayName: "Tenor Madness (Rollins Bb Blues)",
    progression: [ 
      "Bb7", "Eb7", "Bb7", "Bb7",
      "Eb7", "Eb7", "Bb7", "G7alt",
      "Cm7 F7",  "Bb7", "(Cm7 F7 or Bb7)"
    ],
    description: "A hard-swinging blues progression, ideal for fiery tenor sax battles."
  },
  embraceable_you: {
    defaultKey: "G",
    displayName: "Embraceable You",
    progression: [
      "Gmaj7", "Gmaj7", "Em7 A7", "Am7 D7",
      "Gmaj7", "Gmaj7", "Em7 A7", "G6 D7alt",
      "Gmaj7", "Gmaj7", "Em7 A7", "Am7 D7",
      "Gmaj7", "Gmaj7", "Em7 A7", "G6",
      "Gm7 C7", "Fmaj7", "Fmaj7",
      "Bb7", "Bb7", "Ebmaj7 D7", "Gmaj7 E7",
      "Am7 D7", "Gmaj7", "Gmaj7",
      "Gmaj7 E7", "Am7 D7", "G6 (D7)"
    ],
    description: "George Gershwin's timeless ballad, a favorite for its tender melody and rich harmonies."
  },
  body_and_soul: {
    defaultKey: "Db",
    displayName: "Body and Soul",
    progression: [
      "Ebm7 Ab7", "Dbmaj7", "Ebm7 A7", "Dbmaj7",
      "Ebm7 Ab7", "Dbmaj7", "Bbm7", "Eb7 Ab7",
      "Ebm7 Ab7", "Dbmaj7", "Ebm7 A7", "Dbmaj7",
      "Ebm7 Ab7", "Dbmaj7", "Bbm7", "Eb7 Ab7",
      "Dm7", "Dm7", "G7", "G7",
      "Cmaj7", "Cmaj7", "Cm7 F7", "Bb7 Eb7",
      "Ebm7 Ab7", "Dbmaj7", "Ebm7 A7", "Dbmaj7",
      "Ebm7 Ab7", "Dbmaj7", "Bbm7", "Dbmaj7"
    ],
    description: "A quintessential jazz ballad by Johnny Green, known for its challenging bridge and emotional depth."
  },
  take_the_a_train: {
    defaultKey: "C",
    displayName: "Take the A Train",
    progression: [
      "Cmaj7", "Cmaj7", "D7", "D7",
      "Dm7 G7", "Cmaj7 A7", "Dm7 G7", "C6 (G7)",
      "Cmaj7", "Cmaj7", "D7", "D7",
      "Dm7 G7", "Cmaj7 A7", "Dm7 G7", "C6 (G7)",
      "Fmaj7", "Fmaj7", "Fmaj7", "Fmaj7",
      "D7", "G7", "Cmaj7 (A7)", "Dm7 G7",
      "Cmaj7", "Cmaj7", "D7", "D7",
      "Dm7 G7", "Cmaj7 A7", "Dm7 G7", "C6"
    ],
    description: "Duke Ellington's signature tune, an upbeat swing classic with a memorable melody."
  },
  so_what: {
    defaultKey: "Dm",
    displayName: "So What",
    progression: [
      "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7",
      "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7",
      "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7",
      "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7"
    ],
    description: "Miles Davis's modal jazz masterpiece, characterized by its spacious harmony and iconic bassline."
  },
  impressions: {
    defaultKey: "Dm", 
    displayName: "Impressions",
    progression: [
      "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7",
      "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7",
      "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7", "Ebm7",
      "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7", "Dm7"
    ],
    description: "John Coltrane's high-energy modal piece, sharing the harmonic structure of 'So What'."
  },
  how_high_the_moon: {
    defaultKey: "G",
    displayName: "How High the Moon",
    progression: [
      "Gmaj7", "Gmaj7", "Gm7 C7",
      "Fmaj7", "Fmaj7", "Fm7 Bb7",
      "Ebmaj7", "Am7b5 D7", "Gmaj7", 
      "Gmaj7", "Gm7 C7", "Fmaj7",   
      "Fmaj7", "Fm7 Bb7", "Ebmaj7",
      "Am7b5 D7alt", "Gmaj7", "Gmaj7 (D7alt)"
    ],
    description: "A popular jazz standard with a memorable cycle of dominants, a favorite for bebop improvisers."
  },
  a_night_in_tunisia: {
    defaultKey: "Dm", 
    displayName: "A Night in Tunisia",
    progression: [ 
      "Eb7 Dm7", "Eb7 Dm7", 
      "Eb7 Dm7", "Eb7 Dm7",
      "Gm7 C7", "Fmaj7", "Fmaj7", 
      "Em7b5 A7alt", "Dm7", "A7alt"  
    ],
    description: "Dizzy Gillespie's Afro-Cuban jazz classic, known for its exotic melody and rhythm. (Solo changes shown)"
  },
  blue_monk: {
    defaultKey: "Bb",
    displayName: "Blue Monk",
    progression: [
      "Bb7", "Eb7", "Bb7", "Bb7",
      "Eb7", "Edim7", "Bb7 G7alt", "Cm7 F7alt",
      "Bb7 Eb7", "Bb7 F7alt", "Bb7", "Bb7 (F7alt)"
    ],
    description: "Thelonious Monk's quirky and infectious blues, a staple in jazz repertoire."
  },
  straight_no_chaser: {
    defaultKey: "F",
    displayName: "Straight, No Chaser",
    progression: [
      "F7", "Bb7", "F7", "F7",
      "Bb7", "Bdim7", "F7 D7alt", "Gm7 C7alt",
      "F7", "Gm7 C7alt", "F7", "F7 (C7alt)"
    ],
    description: "Another iconic Thelonious Monk blues, featuring his signature angular melodies and rhythmic displacement."
  },
  confirmation: {
    defaultKey: "F",
    displayName: "Confirmation",
    progression: [
      "Fmaj7", "Em7b5 A7alt", "Dm7 G7alt", "Cm7 F7",
      "Bbmaj7", "Am7 Dm7", "Gm7 C7", "Fmaj7 (Gm7 C7)",
      "Fmaj7", "Em7b5 A7alt", "Dm7 G7alt", "Cm7 F7",
      "Bbmaj7", "Am7 Dm7", "Gm7 C7", "Fmaj7 (Gm7 C7)",
      "Em7b5 A7alt", "Dm7", "Dbm7 Gb7", "Bmaj7", 
      "Bbm7 Eb7", "Abmaj7", "Gm7 C7", "Fmaj7 (Gm7 C7)",
      "Fmaj7", "Em7b5 A7alt", "Dm7 G7alt", "Cm7 F7",
      "Bbmaj7", "Am7 Dm7", "Gm7 C7", "Fmaj7"
    ],
    description: "Charlie Parker's bebop masterpiece, a challenging and exhilarating tune for improvisers."
  },
  donna_lee: {
    defaultKey: "Ab",
    displayName: "Donna Lee",
    progression: [
      "Abmaj7", "Abmaj7", "Fm7 Bb7", "Eb7",
      "Abmaj7", "F7", "Bbm7", "Eb7",
      "Abmaj7", "Abmaj7", "Fm7 Bb7", "Eb7",
      "Abmaj7", "F7", "Bbm7", "Abmaj7 (Ebm7 Ab7)",
      "Dbmaj7", "Dbmaj7", "Dbm7 Gb7", "Bmaj7", 
      "Bbm7 Eb7", "Abmaj7", "F7", "Bbm7 Eb7",
      "Abmaj7", "Abmaj7", "Fm7 Bb7", "Eb7",
      "Abmaj7", "F7", "Bbm7", "Abmaj7"
    ],
    description: "A quintessential bebop head attributed to Charlie Parker, based on the changes of 'Indiana'."
  },
  moments_notice: { 
    defaultKey: "Eb", 
    displayName: "Moment's Notice",
    progression: [ 
      "Ebm7 Ab7", "Dbmaj7 Gb7",
      "Bmaj7", "Am7b5 D7b9", "Gm7 C7b9", 
      "Fm7 Bb7", "Ebmaj7 A7b9",
      "Dmaj7", "Am7 D7", "Gm7 C7alt", "Fm7 Bb7" 
    ],
    description: "John Coltrane's intricate composition with rapid key center shifts, a test of harmonic navigation."
  },
  recorda_me: { 
    defaultKey: "Am",
    displayName: "Recorda Me",
    progression: [ 
      "Am7", "Am7", "Cm7 F7",
      "Bbmaj7", "Bbmaj7", "Ebm7 Ab7",
      "Am7", "Am7", "Cm7 F7",
      "Bbmaj7", "Ebm7 Ab7", "Dm7 G7", "Cmaj7 Fmaj7" 
    ],
    description: "Joe Henderson's Bossa-influenced classic, known for its smooth melody and distinctive harmony."
  },
  my_funny_valentine: {
    defaultKey: "Cm",
    displayName: "My Funny Valentine",
    progression: [
      "Cm7", "Cm(maj7)", "Cm7", "C7alt",
      "Fm7 Bb7", "Ebmaj7", "Abmaj7", "Dm7b5 G7alt",
      "Cm7", "Cm(maj7)", "Cm7", "C7alt",
      "Fm7 Bb7", "Ebmaj7", "Abmaj7", "Dm7b5 G7alt",
      "Cm7", "Cm7", "Fm7", "Fm7",
      "Bb7", "Bb7", "Ebmaj7", "Abmaj7",
      "Dm7b5 G7alt", "Cm7", "Fm7",
      "Cm7 G7alt", "Cm7", "Cm7 G7alt", "Cm7" 
    ],
    description: "Richard Rodgers' iconic ballad, famed for its melancholic beauty and poignant lyrics."
  },
  someday_my_prince_will_come: {
    defaultKey: "Bb",
    displayName: "Someday My Prince Will Come",
    progression: [
      "Bbmaj7", "Gm7", "Cm7 F7",
      "Ebmaj7 Edim7", "Dm7 G7", "Cm7 F7",
      "Bbmaj7", "Gm7", "Cm7 F7",
      "Ebmaj7 Edim7", "Dm7 G7", "Cm7 F7",
      "Am7 D7", "Gm7 C7", "Fmaj7 A7", "Dm7 G7",
      "Cm7 F7", "Bbmaj7 D7", "Gm7 C7", "F7 Bbmaj7",
      "Bbmaj7", "Gm7", "Cm7 F7",
      "Ebmaj7 Edim7", "Dm7 G7", "Cm7 F7"
    ],
    description: "A charming waltz from Disney's 'Snow White,' transformed into a beloved jazz standard."
  },
  footprints: { 
    defaultKey: "Cm",
    displayName: "Footprints",
    progression: [ 
      "Cm11", "Cm11", "Cm11", "Cm11",
      "Fm11", "Fm11", "Cm11", "Cm11", 
      "D7#9#5", "D7#9#5", "Cm11", "G7alt" 
    ],
    description: "Wayne Shorter's influential modal jazz composition, often played in a 6/4 feel."
  },
  in_a_sentimental_mood: {
    defaultKey: "Dm", 
    displayName: "In a Sentimental Mood",
    progression: [
      "Dm7 G7", "Cmaj7 Fmaj7", "Dm7 G7", "Cmaj7 A7alt",
      "Dm7 G7", "Cmaj7 Fmaj7", "Bbmaj7 E7alt", "A7alt",
      "Dm7 G7", "Cmaj7 Fmaj7", "Dm7 G7", "Cmaj7 A7alt",
      "Dm7 G7", "Cmaj7 Fmaj7", "Bbmaj7 E7alt", "A7alt",
      "Gm7 C7", "Fmaj7", "Fmaj7",
      "Ebm7 Ab7", "Dbmaj7", "Gm7 C7",
      "Dm7 G7", "Cmaj7 Fmaj7", "Dm7 G7", "Cmaj7 A7alt",
      "Dm7 G7", "Cmaj7 Fmaj7", "Bbmaj7 Gm7 C7", "F6"
    ],
    description: "Duke Ellington's beautiful ballad, evoking a feeling of tender nostalgia."
  },
  dolphin_dance: { 
    defaultKey: "Eb",
    displayName: "Dolphin Dance",
    progression: [ 
      "Eb7sus", "Ab7alt/Eb", "Dm7b5/Eb", "G7alt/Eb", 
      "Cm7", "F9sus F7b9", "Bbmaj7sus", "Bb7",
      "Ebm7", "Ab7sus Ab7", "Dbmaj7", "Am7 D7",
      "Gm7", "C7sus C7", "Fm7 Bb7", "Ebmaj7"
    ],
    description: "Herbie Hancock's sophisticated post-bop piece from 'Maiden Voyage,' with flowing, modern harmony."
  },
  oleo: { 
    defaultKey: "Bb",
    displayName: "Oleo (Rhythm Changes)",
    progression: [
      "Bbmaj7 G7", "Cm7 F7", "Bbmaj7 G7", "Cm7 F7",
      "Dm7 G7", "Cm7 F7", "Bbmaj7", "Cm7 F7",
      "Bbmaj7 G7", "Cm7 F7", "Bbmaj7 G7", "Cm7 F7",
      "Dm7 G7", "Cm7 F7", "Bbmaj7", "Bb7",
      "D7", "D7", "G7", "G7",
      "C7", "C7", "F7", "F7",
      "Bbmaj7 G7", "Cm7 F7", "Bbmaj7 G7", "Cm7 F7",
      "Dm7 G7", "Cm7 F7", "Bbmaj7", "F7" 
    ],
    description: "Sonny Rollins' classic bebop head written over the 'Rhythm Changes' progression."
  },
  there_will_never_be_another_you: {
    defaultKey: "Eb",
    displayName: "There Will Never Be Another You",
    progression: [
      "Ebmaj7", "Ebmaj7", "Fm7 Bb7",
      "Ebmaj7 Cm7", "F7 Bb7",
      "Ebmaj7", "Ebmaj7", "Fm7 Bb7",
      "Ebmaj7 Cm7", "Fm7 Bb7", "Ebmaj7",
      "Ebm7 Ab7", "Dbmaj7", "Dbmaj7",
      "Dbm7 Gb7", "Bmaj7", "Bb7sus Bb7", 
      "Ebmaj7", "Ebmaj7", "Fm7 Bb7",
      "Ebmaj7 Cm7", "Fm7 Bb7", "Ebmaj7"
    ],
    description: "A popular jazz standard by Harry Warren, loved for its beautiful melody and flowing changes."
  },
  minor_swing: {
    defaultKey: "Am",
    displayName: "Minor Swing",
    progression: [ 
      "Am", "Am", "Dm", "Dm",
      "E7", "E7", "Am", "Am",
      "Dm", "Dm", "Am", "Am",
      "E7", "E7", "Am", "E7", 
      "Am", "Am", "Dm", "Dm",
      "E7", "E7", "Am", "Am",
      "Dm", "Dm", "Am", "Am",
      "E7", "E7", "Am", "Am"
    ],
    description: "Django Reinhardt and Stéphane Grappelli's iconic Gypsy Jazz anthem, simple yet profound."
  },
  nuages: { 
    defaultKey: "G", 
    displayName: "Nuages",
    progression: [
      "G6", "G6", "Cm6", "Cm6",
      "G6", "D7", "G6", "Gdim7", 
      "G6", "G6", "Cm6", "Cm6",
      "G6", "D7", "G6", "D7",
      "Eb6", "Eb6", "Bbm6", "Bbm6",
      "G6", "E7", "Am7 D7",
      "G6", "G6", "Cm6", "Cm6",
      "G6", "D7", "G6", "G6"
    ],
    description: "Django Reinhardt's evocative masterpiece, meaning 'Clouds,' known for its beautiful, melancholic melody."
  },
  djangology: {
    defaultKey: "G",
    displayName: "Djangology",
    progression: [
      "G6", "G6", "C6", "C6",
      "G6", "D7", "G6", "D7",
      "G6", "G6", "C6", "C6",
      "G6", "D7", "G6", "G6",
      "Am7 D7", "G6 E7",
      "Am7 D7", "G6 D7",
      "G6", "G6", "C6", "C6",
      "G6", "D7", "G6", "G6"
    ],
    description: "A lively and swinging Django Reinhardt composition, a staple of the Gypsy Jazz repertoire."
  },
  sweet_georgia_brown_gypsy: { 
    defaultKey: "Ab", 
    displayName: "Sweet Georgia Brown (Gypsy)",
    progression: [
      "Eb7", "Eb7", "Ab6", "Ab6",
      "Eb7", "Eb7", "Ab6", "Ab6",
      "Eb7", "Eb7", "Ab6", "Ab6",
      "C7", "C7", "F6", "F6", // Usually B section starts on F7 in standard, F6 in gypsy is common
      "C7", "C7", "F6", "F6",
      "C7", "C7", "F6", "F6",
      "C7", "C7", "F6", "F6",
      "C7", "C7", "F6", "F6"
    ],
    description: "A classic jazz tune frequently played in the Gypsy Jazz style, known for its key changes."
  },
  after_youve_gone_gypsy: {
    defaultKey: "C",
    displayName: "After You've Gone (Gypsy)",
    progression: [
      "C6", "C6", "G7", "G7",
      "C6", "C6", "G7", "G7",
      "E7", "E7", "Am", "Am",
      "D7", "D7", "G7", "G7",
      "C6", "C6", "G7", "G7",
      "C6", "C6", "G7", "G7",
      "F6", "F#dim7", "C6/G A7", "Dm7 G7", 
      "C6 Fm6", "C6 G7", "C6", "C6"
    ],
    description: "A popular early jazz standard given a vibrant treatment in the Gypsy Jazz tradition."
  },
  limehouse_blues_gypsy: {
    defaultKey: "G", 
    displayName: "Limehouse Blues (Gypsy)",
    progression: [
      "G", "G", "C", "G",
      "D7", "D7", "G", "D7",
      "G", "G", "C", "G",
      "D7", "D7", "G", "G",
      "F", "F", "Bb", "F", 
      "C7", "C7", "F", "C7",
      "G", "G", "C", "G",
      "D7", "D7", "G", "G"
    ],
    description: "A fast-paced, exciting tune with an oriental flavor, a favorite for Gypsy Jazz improvisers."
  },
  belleville_gypsy: {
    defaultKey: "D",
    displayName: "Belleville (Gypsy)",
    progression: [
      "D6", "D6", "G6", "G6",
      "D6", "A7", "D6", "A7",
      "D6", "D6", "G6", "G6",
      "D6", "A7", "D6", "D6",
      "Em7 A7", "D6 B7",
      "Em7 A7", "D6 A7",
      "D6", "D6", "G6", "G6",
      "D6", "A7", "D6", "D6"
    ],
    description: "A charming and melodic Django Reinhardt composition, named after the Parisian neighborhood."
  },
  swing_42_gypsy: {
    defaultKey: "C",
    displayName: "Swing 42 (Gypsy)",
    progression: [
      "C6", "C6", "G7", "G7",
      "G7", "G7", "C6", "C6",
      "C6", "C6", "G7", "G7",
      "G7", "G7", "C6", "C6",
      "F6", "F6", "C6", "C6",
      "D7", "D7", "G7", "G7",
      "C6", "C6", "G7", "G7",
      "G7", "G7", "C6", "C6"
    ],
    description: "A classic Django Reinhardt swing tune from 1941 (Swing '42), often played with a driving rhythm."
  },
  douce_ambiance_gypsy: {
    defaultKey: "Am", 
    displayName: "Douce Ambiance (Gypsy)",
    progression: [
      "Am6", "Dm6", "Am6", "E7",
      "Am6", "Dm6", "Am6 E7", "Am6",
      "Am6", "Dm6", "Am6", "E7",
      "Am6", "Dm6", "Am6 E7", "Am6",
      "Dm6 G7", "Cmaj7 Fmaj7", 
      "Bm7b5 E7", "Am6 E7",
      "Am6", "Dm6", "Am6", "E7",
      "Am6", "Dm6", "Am6 E7", "Am6"
    ],
    description: "Meaning 'Sweet Atmosphere,' this is a beautiful and lyrical Django Reinhardt waltz."
  },
  jattendrai_gypsy: { 
    defaultKey: "C",
    displayName: "J'attendrai (Gypsy)",
    progression: [
      "Cmaj7", "Cmaj7", "G7", "G7",
      "G7", "G7", "Cmaj7", "Cmaj7",
      "Cmaj7", "Cmaj7", "G7", "G7",
      "G7", "G7", "Cmaj7", "Cmaj7",
      "Fmaj7", "Fmaj7", "Cmaj7", "Cmaj7",
      "Dm7 G7", "Cmaj7 G7", "Cmaj7",
      "Cmaj7", "Cmaj7", "G7", "G7",
      "G7", "G7", "Cmaj7", "Cmaj7"
    ],
    description: "A popular French song adopted into the Gypsy Jazz repertoire, known for its romantic melody."
  },
  something_beatles: {
    defaultKey: "C",
    displayName: "Something – The Beatles",
    progression: ["C", "Cmaj7", "C7", "F", "D", "G", "Am", "Am", "Am7", "D", "F", "Eb", "G" ],
    description: "A lush, romantic progression with chromatic movement and rich major 7th harmonies.",
  },
  althea_dead: {
    defaultKey: "E",
    displayName: "Althea – Grateful Dead",
    progression: ["E", "A", "B", "C#m", "F#m", "G#7"],
    description: "Laid-back and groovy with a bluesy foundation and modal flavor in E major.",
  },
  dead_flowers_stones: {
    defaultKey: "D",
    displayName: "Dead Flowers – Rolling Stones",
    progression: ["D", "A", "G"],
    description: "A country-tinged three-chord song with classic Rolling Stones swagger.",
  },
  honky_tonk_woman: {
    defaultKey: "G",
    displayName: "Honky Tonk Woman – Rolling Stones",
    progression: ["G", "C", "D", "F"],
    description: "Blues-rock riff-based progression with a gritty, swaggering feel.",
  },
  loser_dead: {
    defaultKey: "B",
    displayName: "Loser – Grateful Dead",
    progression: ["B", "F#", "E", "C#m", "A", "G#m"],
    description: "Minor-key narrative groove with chromatic flavor and storytelling drama.",
  },
  black_magic_woman: {
    defaultKey: "Dm",
    displayName: "Black Magic Woman – Santana",
    progression: ["Dm", "Am", "Gm", "A7"],
    description: "A Latin-blues vamp in D minor with a hypnotic, mystical feel.",
  },
  let_it_be: {
    defaultKey: "C",
    displayName: "Let It Be – The Beatles",
    progression: ["C", "G", "Am", "F", "C/E", "Dm"],
    description: "Gospel-inspired progression with emotional warmth and sing-along appeal.",
  },
  here_comes_the_sun: {
    defaultKey: "A",
    displayName: "Here Comes the Sun – The Beatles",
    progression: ["A", "E", "F#m", "D", "Bm", "G", "A7"],
    description: "Bright, optimistic chords with interesting meter changes and melodic movement.",
  },
  hey_jude: {
    defaultKey: "F",
    displayName: "Hey Jude – The Beatles",
    progression: ["F", "C", "C7", "Bb", "Dm", "Gm", "F7"],
    description: "Classic pop anthem with rich voice leading and a powerful outro vamp.",
  },
  bittersweet_bhtm: {
    defaultKey: "A",
    displayName: "Bittersweet – Big Head Todd",
    progression: ["A", "E", "F#m", "D"],
    description: "Emotive and melodic four-chord progression perfect for dynamic builds.",
  }
};
        
// ==================================
// === APPLICATION STATE ==========
// ==================================
const AppState = {
    isPlaying: false,
    currentBeat: 0, // Current UI beat subdivision being played (0-7 for 4/4 eighths)
    currentMeasure: 0,
    tempo: 120,
    audioInitialized: false,
    intervalId: null,
    lastTapTime: 0,
    tapTempoTimestamps: [],
    guideTonesActive: false,
    loopingActive: false,
    loopStartMeasure: -1,
    loopEndMeasure: -1,
    currentRhythmicStyle: "standardSwing", // NEW: Default style
    currentStylePatternBeat: 0,        // NEW: Index within the *style's* pattern
    currentStyleBar: 0,                // NEW: For multi-bar patterns like Clave (0 or 1)
    listeners: [], 

    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};

// NEW: Rhythmic Style Definitions
const RHYTHMIC_STYLES = {
    quarterNotes: {
        displayName: "Quarter Notes",
        beatsPerPattern: 8, // 1 bar of 4/4, 8 eighth-note subdivisions
        pattern: [ // Index is the 8th note subdivision
            { sound: 'kick', volume: 1.0, color: '#1F618D' }, null, // 1
            { sound: 'kick', volume: 0.7, color: '#5DADE2' }, null, // 2
            { sound: 'kick', volume: 0.7, color: '#5DADE2' }, null, // 3
            { sound: 'kick', volume: 0.7, color: '#5DADE2' }, null  // 4
        ]
    },
    standardSwing: {
        displayName: "Standard Swing",
        beatsPerPattern: 8,
        pattern: [
            { sound: 'kick,hihat', volume: 1.0, color: '#1F618D' }, { sound: 'hihat', volume: 0.3, color: '#9E9E9E' }, // 1, 1&
            { sound: 'snare,hihat', volume: 0.8, color: '#D9534F' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }, // 2, 2& (Hihat on 2 is strong)
            { sound: 'kick,hihat', volume: 0.7, color: '#5DADE2' }, { sound: 'hihat', volume: 0.3, color: '#9E9E9E' }, // 3, 3&
            { sound: 'snare,hihat', volume: 0.8, color: '#D9534F' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }  // 4, 4& (Hihat on 4 is strong)
        ]
    },
    freddieGreen: {
        displayName: "Freddie Green",
        beatsPerPattern: 8,
        // Simulates a solid 4 feel with hi-hat typical for this guitar style support
        pattern: [
            { sound: 'kick,hihat', volume: 1.0, color: '#1F618D' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' },
            { sound: 'snare,hihat', volume: 0.7, color: '#D9534F' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }, // Snare as sidestick
            { sound: 'kick,hihat', volume: 0.8, color: '#5DADE2' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' },
            { sound: 'snare,hihat', volume: 0.7, color: '#D9534F' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }
        ]
    },
    charleston: {
        displayName: "Charleston",
        beatsPerPattern: 8, // Accents on 1 and "and" of 2
        pattern: [
            { sound: 'kick,hihat', volume: 1.0, color: '#1F618D' }, null, // 1
            null, { sound: 'snare,hihat', volume: 0.9, color: '#D9534F' }, // "and" of 2
            null, null, null, null // Rest of the bar is quiet or has light hi-hat placeholder
        ]
    },
    bossaNova: {
        displayName: "Bossa Nova",
        beatsPerPattern: 8,
        // Kick on 1, "and" of 2 (implied by 2nd kick), Sidestick on 2 & 4
        pattern: [
            { sound: 'kick,hihat', volume: 1.0, color: '#1F618D' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }, // 1
            { sound: 'snare,hihat', volume: 0.7, color: '#D9534F' }, { sound: 'kick,hihat', volume: 0.8, color: '#5DADE2' }, // 2, "and" of 2 (kick)
            { sound: 'hihat', volume: 0.5, color: '#9E9E9E' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }, // 3
            { sound: 'snare,hihat', volume: 0.7, color: '#D9534F' }, { sound: 'hihat', volume: 0.4, color: '#9E9E9E' }  // 4
        ]
    },
    sonClave32: {
        displayName: "Son Clave (3:2)",
        beatsPerPattern: 16, // Spans TWO bars of 4/4 (16 eighth-note subdivisions)
        // Using snare for clave hits when "Drums" is selected.
        pattern: [
            // Bar 1 (3-side)
            { sound: 'snare,kick,hihat', volume: 1.0, color: '#1F618D' }, null, // 1
            null, { sound: 'snare,hihat', volume: 0.9, color: '#D9534F' },    // "and" of 2
            null, null,                                                     // 3
            { sound: 'snare,kick,hihat', volume: 0.9, color: '#D9534F' }, null, // 4
            // Bar 2 (2-side) - starts at index 8
            null, null,                                                     // 1 of bar 2
            { sound: 'snare,kick,hihat', volume: 0.9, color: '#D9534F' }, null, // 2 of bar 2
            { sound: 'snare,hihat', volume: 0.9, color: '#D9534F' }, null,    // 3 of bar 2
            null, null                                                      // 4 of bar 2
        ]
    }
};

let currentFunctionalProgression = [];
let currentProgressionName = "";
let currentDrumSetIndex = 0;
let previousPlayedVoicingNotesWithOctaves = null;

// ==================================
// === UI MANAGEMENT & DOM ELEMENTS ===
// ==================================
const UI = {
    elements: {},
    init() {
        this.elements = {
            chordFretboardSection: document.getElementById('chord-fretboard-section'),
            metronomeSection: document.getElementById('metronome-section'),
            chordProgressionSection: document.getElementById('chord-progression-section'),
            fretflowSection: document.getElementById('fretflow-section'),
            measures: document.getElementById('measures'),
            fretboardsGrid: document.querySelector('.fretboards-grid'),
            chordFretboard: document.getElementById('chord-fretboard'),
            chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
            chordTuning: document.getElementById('chord-tuning'),
            scaleDisplay: document.getElementById('scale-display'),
            nextChordDisplay: document.getElementById('next-chord-display'),
            currentSongTitleFretboard: document.getElementById('current-song-title-fretboard'),
            currentSongDescriptionFretboard: document.getElementById('current-song-description-fretboard'),
            guideTonesToggle: document.getElementById('guide-tones-toggle'),
            timeSignature: document.getElementById('time-signature'),
            soundType: document.getElementById('sound-type'),
            drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
            tempo: document.getElementById('tempo'),
            tempoDisplay: document.getElementById('tempo-display'),
            tapTempo: document.getElementById('tap-tempo'),
            startStopButton: document.getElementById('start-stop'),
            metronomeVolumeControlsStack: document.getElementById('metronome-volume-controls-stack'),
            metronomeVolume: document.getElementById('metronome-volume'),
            kickVolumeContainer: document.getElementById('kick-volume-container'),
            kickVolume: document.getElementById('kick-volume'),
            snareVolumeContainer: document.getElementById('snare-volume-container'),
            snareVolume: document.getElementById('snare-volume'),
            hihatVolumeContainer: document.getElementById('hihat-volume-container'),
            hihatVolume: document.getElementById('hihat-volume'),
            accentIntensity: document.getElementById('accent-intensity'),
            beatsContainer: document.querySelector('.beats-container'),
            progressionSelect: document.getElementById('progression-select'),
            keySelect: document.getElementById('keySelect'),
            loopSelectedToggle: document.getElementById('loop-selected-toggle'),
            userProgressionSelect: document.getElementById('user-progression-select'),
            deleteUserSongButton: document.getElementById('delete-user-song-button'),
            saveProgressionButton: document.getElementById('save-progression-button'),
            chordsEnabled: document.getElementById('chordsEnabled'),
            chordVolume: document.getElementById('chord-volume'),
            reverbDial: document.getElementById('reverb-dial'),
            reverbDialValue: document.getElementById('reverb-dial-value'),
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            loadingIndicator: document.getElementById('loading-indicator'),
            rhythmicStyleContainer: document.getElementById('rhythmic-style-container'),
            rhythmicStyleSelect: document.getElementById('rhythmic-style-select'),
            swingToggle: document.getElementById('swing-toggle'),
            noteNamingConvention: document.getElementById('note-naming-convention'),
        };
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element && !['currentSongTitle', 'currentSongDescription', 'swingToggle', 'noteNamingConvention'].includes(key)) {
                 console.error(`[UI Init - CRITICAL] Missing DOM element by ID: '${key}'. Element is ${element}.`);
            }
        });
        log("UI elements cached.");
    }
};

// ==================================
// === AUDIO MANAGEMENT ===========
// ==================================
const AudioContextManager = { 
    context: null,
    soundBuffers: {},
    pianoSampleBuffers: {},
    reverbNode: null,
    samplesLoaded: false,
    reverbAmount: 0.2,
    currentChordGain: null,
    secondaryLoadStarted: false,
    reverbNodeConnected: false
};

AudioContextManager.initialize = async function() {
    if (this.context && this.context.state !== 'closed') {
        return this.context;
    }
    try {
        this.context = new (window.AudioContext || window.webkitAudioContext)();
        log("AudioContext created/resumed.");
        updateLoadingStatus("Loading essential sounds...", true);
        await this.loadInitialSounds(); 
        AppState.audioInitialized = true;
        log("AudioContextManager initial sounds loaded.");
        await this.setupReverb();

        if (this.context.state === 'suspended') {
            await this.context.resume(); 
            log("AudioContext resumed from suspended state.");
        }
        setTimeout(() => this.loadSecondarySounds(), 100);

    } catch (error) {
        console.error("Error initializing AudioContextManager:", error);
        alert("Failed to initialize audio. Please ensure your browser supports Web Audio API and allow autoplay if prompted.");
        AppState.audioInitialized = false;
        throw error; 
    }
    return this.context;
};
AudioContextManager.ensureAudioContext = async function() {
    if (!this.context || this.context.state === 'suspended') {
        return await this.initialize();
    }
    if (this.context.state === 'closed') {
        console.warn("AudioContext was closed, attempting to re-initialize.");
        return await this.initialize();
    }
    return this.context;
};
AudioContextManager.loadInitialSounds = async function() {
    try {
        const response = await fetch('./Click.wav');
        if (!response.ok) throw new Error(`HTTP error ${response.status} for Click.wav`);
        const arrayBuffer = await response.arrayBuffer();
        this.soundBuffers['click'] = await this.context.decodeAudioData(arrayBuffer);
        log("Successfully loaded Click.wav");
    } catch (e) {
        console.error("Failed to load Click.wav:", e);
        this.soundBuffers['click'] = await this.createDrumSound('click'); 
        log("Using synthetic fallback for click sound.");
    }
    await this.loadPianoSamplesSpecific(PLAYBACK_OCTAVES);
    this.samplesLoaded = Object.keys(this.pianoSampleBuffers).length > 0;
    if (this.samplesLoaded) {
        log(`Initial piano samples (Octaves ${PLAYBACK_OCTAVES.join(',')}) loaded.`);
    } else {
        console.warn(`Initial piano samples (Octaves ${PLAYBACK_OCTAVES.join(',')}) failed to load any samples.`);
    }
};
AudioContextManager.loadSecondarySounds = async function() {
    if (this.secondaryLoadStarted) return;
    this.secondaryLoadStarted = true;
    log("Starting secondary background sound loading...");
    updateLoadingStatus("Loading additional sounds...", true);

    const loadPromises = [];
    const soundsToLoad = {
        'woodblock': 'woodblock.wav', 'hihat': 'HiHat.wav', 
        'kick': 'Kick.wav', 'snare': 'Snare.wav'
    };
    for (let [type, filename] of Object.entries(soundsToLoad)) {
        if (!this.soundBuffers[type]) { 
            loadPromises.push(this.loadSingleSound(type, filename));
        }
    }
    const remainingOctaves = OCTAVES_FOR_SAMPLES.filter(o => !PLAYBACK_OCTAVES.includes(o));
    if (remainingOctaves.length > 0) {
        loadPromises.push(this.loadPianoSamplesSpecific(remainingOctaves));
    }
    await Promise.allSettled(loadPromises);
    log("Secondary background sound loading complete.");
    updateLoadingStatus("All sounds loaded.", true);
    setTimeout(() => updateLoadingStatus("", false), 1500);
};
AudioContextManager.loadSingleSound = async function(type, filename) {
    try {
        const response = await fetch(`./${filename}`);
        if (!response.ok) throw new Error(`HTTP error ${response.status} for ${filename}`);
        const arrayBuffer = await response.arrayBuffer();
        this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
        log(`Successfully loaded secondary sound: ${filename}`);
    } catch (e) {
        console.error(`Failed to load secondary sound ${filename}:`, e);
        this.soundBuffers[type] = await this.createDrumSound(type); 
        log(`Using synthetic fallback for secondary sound: ${type}`);
    }
};
AudioContextManager.loadPianoSamplesSpecific = async function(octavesToLoad) {
    let loadedCount = 0;
    const promises = [];
    for (const note of ALL_NOTES_FOR_SAMPLES) { 
        for (const octave of octavesToLoad) {
            if (!OCTAVES_FOR_SAMPLES.includes(octave)) continue; 
            const sampleKey = `${note}${octave}`;
            if (this.pianoSampleBuffers[sampleKey]) continue; 

            const filename = getSampleFileName(note, octave);
            promises.push(
                fetch(filename)
                    .then(response => {
                        if (!response.ok) return Promise.reject(new Error(`HTTP error ${response.status} for ${filename}`));
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => this.context.decodeAudioData(arrayBuffer))
                    .then(buffer => {
                        this.pianoSampleBuffers[sampleKey] = buffer;
                        loadedCount++;
                    })
                    .catch(error => { /* console.warn(`Failed to load piano sample: ${filename}`, error.message); */ })
            );
        }
    }
    await Promise.allSettled(promises);
    if (loadedCount > 0) {
        log(`Loaded ${loadedCount} new piano samples for octaves: [${octavesToLoad.join(', ')}]`);
    }
    this.samplesLoaded = Object.keys(this.pianoSampleBuffers).length > 0;
};
AudioContextManager.createDrumSound = async function(type) { 
    if (!this.context) { 
        console.warn("AudioContext not available for createDrumSound, attempting init.");
        await this.ensureAudioContext();
        if (!this.context) {
            console.error("AudioContext could not be initialized for createDrumSound.");
            return new AudioBuffer({length:1, sampleRate: 44100}); 
        }
    }
    const sampleRate = this.context.sampleRate;
    const duration = type === 'hihat' ? 0.05 : 0.2; 
    const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
    const data = buffer.getChannelData(0);
    let x;
    switch (type) {
        case 'click': 
            for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
            break;
        case 'hihat': 
            for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
            break;
        case 'kick': 
            for (let i = 0; i < data.length; i++) {
                x = i / sampleRate;
                data[i] = Math.sin(2 * Math.PI * 100 * Math.exp(-x * 5) * x) * Math.exp(-x * 10) * 2; 
            }
            break;
        case 'snare': 
             for (let i = 0; i < data.length; i++) {
                x = i / sampleRate;
                data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * x)) * Math.exp(-x * 10) * 1.5;
            }
            break;
        case 'woodblock': 
            for (let i = 0; i < data.length; i++) {
                x = i / sampleRate;
                data[i] = Math.sin(2 * Math.PI * 800 * x) * Math.exp(-x * 20);
            }
            break;
        default: 
            for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
    }
    return buffer;
};
AudioContextManager.setupReverb = async function() {
    if (!this.context) return;
    if (!this.reverbNode) {
        try {
            this.reverbNode = this.context.createConvolver();
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 2.5; 
            const impulse = this.context.createBuffer(2, length, sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5); 
                }
            }
            this.reverbNode.buffer = impulse;
            log("Reverb node created with synthetic impulse response.");

            if (this.context.destination && !this.reverbNodeConnected) {
                 this.reverbNode.connect(this.context.destination);
                 this.reverbNodeConnected = true;
                 log("Reverb node connected to destination.");
            }
        } catch (e) {
            console.error("Failed to create reverb node:", e);
            this.reverbNode = null; 
        }
    }
};

// ==================================
// === MUSIC THEORY HELPERS =======
// ==================================
function transposeChordData(chordData, originalSongKeyRoot, targetGlobalKeyRoot) {
    const originalKeyRootIndex = NOTES_CHROMATIC.indexOf(standardizeNoteName(originalSongKeyRoot));
    const targetKeyRootIndex = NOTES_CHROMATIC.indexOf(standardizeNoteName(targetGlobalKeyRoot));
    if (originalKeyRootIndex === -1 || targetKeyRootIndex === -1) {
        console.error(`Invalid key for transposition: Original '${originalSongKeyRoot}', Target '${targetGlobalKeyRoot}'. Returning original chord.`);
        return { ...chordData };
    }
    const transpositionInterval = (targetKeyRootIndex - originalKeyRootIndex + 12) % 12;
    const originalChordRootIndex = NOTES_CHROMATIC.indexOf(standardizeNoteName(chordData.root));
    if (originalChordRootIndex === -1) {
        console.error(`Invalid original chord root for transposition: '${chordData.root}'. Returning original chord.`);
        return { ...chordData };
    }
    const transposedChordRootIndex = (originalChordRootIndex + transpositionInterval + 12) % 12;
    const transposedRoot = NOTES_CHROMATIC[transposedChordRootIndex];
    return { root: transposedRoot, quality: chordData.quality };
}  
        
function standardizeNoteName(note) {
    if (!note || typeof note !== 'string') return '';
    let standardized = note.trim().replace('♭', 'b').replace('♯', '#');
    if (standardized === "Bbb" || standardized === "bbb") return "A";
    if (standardized === "E##" || standardized === "e##") return "Gb";
    if (standardized === "B##" || standardized === "b##") return "Db";
    standardized = standardized.toUpperCase();
    const sharpToFlatMap = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
    if (sharpToFlatMap[standardized]) {
        return sharpToFlatMap[standardized];
    }
    const foundNote = NOTES_CHROMATIC.find(n_chromatic => n_chromatic.toUpperCase() === standardized);
    if (foundNote) return foundNote;
    if (NOTES_CHROMATIC.includes(note.charAt(0).toUpperCase() + note.slice(1))) {
        return note.charAt(0).toUpperCase() + note.slice(1);
    }
    return standardized;
}

function standardizeNoteNameForSamples(note) {
    const stdNote = standardizeNoteName(note);
    return SAMPLE_NOTE_MAP[stdNote] || SAMPLE_NOTE_MAP[note.toUpperCase()] || note.toLowerCase();
}

function getStandardQuality(rawQualityInput) {
    if (!rawQualityInput || typeof rawQualityInput !== 'string') return 'maj';
    let quality = rawQualityInput.toLowerCase().trim();
    quality = quality.split('/')[0].trim(); // Ignore slash bass notes for quality lookup
    if (quality === 'alt' || quality === '7alt') return 'alt';
    if (quality === '7b9' || quality === 'dom7b9') return 'dom7b9';
    if (quality === '7#9' || quality === 'dom7#9') return 'dom7#9';
    if (quality === '7b5' || quality === 'dom7b5') return 'dom7b5';
    if (quality === '7sus' || quality === '7sus4' || quality === 'dom7sus') return 'dom7sus';
    if (quality === 'imaj7' || quality === 'm(maj7)' || quality === 'minmaj7' || quality === 'mmaj7') return 'imaj7';
    if (quality === 'm7b5' || quality === 'min7b5' || quality === 'ø' || quality === 'mi7b5' || quality.startsWith('m7b5')) return 'min7b5';
    if (quality === 'dim7' || quality === '°7' || (quality.startsWith('dim') && quality.includes('7'))) return 'dim7';
    if (quality === 'maj7' || quality === 'ma7' || quality === 'Δ' || quality.startsWith('maj7') || quality.startsWith('ma7')) return 'maj7';
    if (quality === '7' || quality === 'dom7' || quality === 'dom' || (quality.startsWith('7') && !quality.startsWith('7b') && !quality.startsWith('7#') && !quality.startsWith('7s'))) return 'dom7';
    if (quality === 'm7' || quality === 'min7' || quality === 'mi7' || quality.startsWith('m7') || quality.startsWith('min7')) return 'min7';
    if (quality === 'maj6' || quality === 'ma6' || quality === '6' || quality.startsWith('maj6') || quality.startsWith('ma6')) return 'maj6';
    if (quality === 'm6' || quality === 'min6' || quality === 'mi6' || quality.startsWith('m6') || quality.startsWith('min6')) return 'min6';
    if (quality === '6/9' || quality.startsWith('6/9')) return '6/9'; // Keep 6/9 distinct
    if (quality === 'maj' || quality === '') return 'maj';
    if (quality === 'm' || quality === 'min' || quality === 'mi') return 'min';
    if (quality === 'dim' || quality === '°') return 'dim';
    if (quality === 'aug' || quality === '+') return 'aug';
    if (quality === 'sus4' || quality === 'sus') return 'sus4';
    if (quality === 'sus2') return 'sus2';
    // Check direct match after processing
    if (CHORD_INTERVALS[rawQualityInput]) return rawQualityInput;
    if (CHORD_INTERVALS[quality]) return quality;
    console.warn(`getStandardQuality: Unstandardized quality "${rawQualityInput}". Defaulting to 'maj7'.`);
    return 'maj7';
}

function parseChord(chordString) {
    if (typeof chordString !== 'string' || !chordString.trim()) {
        return null;
    }
    chordString = chordString.trim();
    // Match root note (C, Db, F#, etc.) and the rest as quality string
    const match = chordString.match(/^([A-G][#b]?)(.*)$/);
    if (!match) {
        return null; // Does not start with a valid note name
    }
    const root = standardizeNoteName(match[1]);
    const qualityString = match[2].trim(); 
    
    // If qualityString itself is a valid root note, then it's not a quality (e.g. "C D" is not "C" with quality "D")
    // This helps distinguish "Am7 D7" (two chords) from "C aug" (one chord)
    if (qualityString && parseChord(qualityString) && NOTES_CHROMATIC.includes(standardizeNoteName(qualityString.match(/^([A-G][#b]?)/)?.[1] || ""))) {
         // This means qualityString looks like another chord, so the original chordString was probably just a root.
         // e.g. if chordString was "C", match[1]="C", match[2]="". qualityString is empty.
         // if chordString was "C D", match[1]="C", match[2]=" D". qualityString is "D". parseChord("D") is valid.
         // We only want to return null if the *entire* original string was just a root, and it's part of a two-chord string.
         // This check is tricky here. Simpler: parseChord should only parse *one* chord.
         // If "Am7 D7" is passed, it should parse "Am7". The " D7" is excess.
         // The calling function (loadProgression) will handle splitting "Am7 D7" into two calls to parseChord.
    }

    const quality = getStandardQuality(qualityString);
    return { root: root, quality: quality, originalString: chordString };
}

function parseRomanNumeralToAbsoluteChord(romanString, key) {
    const isMinorKey = key.includes('m');
    const normalizedKeyRoot = standardizeNoteName(key.replace('m', ''));
    const keyRootIndex = NOTES_CHROMATIC.indexOf(normalizedKeyRoot);
    if (keyRootIndex === -1) {
        console.error(`Invalid key for Roman numeral parsing: ${key}`);
        return { root: 'C', quality: 'maj7', originalRoman: romanString };
    }
    const firstChordInSplit = romanString.split('/')[0].trim(); // Handle cases like V7/ii (secondary dominant)
    
    // Attempt to parse as an absolute chord first
    const absoluteChordAttempt = parseChord(firstChordInSplit);
    if (absoluteChordAttempt && absoluteChordAttempt.root && CHORD_INTERVALS[absoluteChordAttempt.quality]) {
        return { ...absoluteChordAttempt, originalRoman: romanString };
    }

    // If not an absolute chord, try Roman numeral parsing
    const romanMatch = firstChordInSplit.match(/^(b|#)?([IViv]+)(.*)$/);
    if (!romanMatch) {
        // If it doesn't match Roman numeral pattern either, return default or log error
        console.warn(`Could not parse "${firstChordInSplit}" as Roman numeral or absolute chord. Defaulting.`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }
    const accidental = romanMatch[1];
    const numeral = romanMatch[2];
    let qualitySuffix = romanMatch[3].trim();

    const majorScaleIntervals = { 'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11 };
    const minorScaleIntervals = { 'i': 0, 'ii': 2, 'III': 3, 'iv': 5, 'v': 7, 'VI': 8, 'VII': 10 }; // Natural minor for reference
    
    let degreeInterval;
    const isUpperCaseNumeral = numeral === numeral.toUpperCase();

    if (isMinorKey) {
        // In minor keys, V is often major/dominant, III can be major, VI and VII can be major too (harmonic/melodic minor)
        if (isUpperCaseNumeral) { // E.g., V7, IIImaj7, IVmaj7, VImaj7, VIImaj7 in minor context
             degreeInterval = majorScaleIntervals[numeral.toUpperCase()]; // Use major scale interval if uppercase
        } else { // e.g. i, ii°, iv, v
             degreeInterval = minorScaleIntervals[numeral.toLowerCase()];
        }
    } else { // Major key
        degreeInterval = majorScaleIntervals[numeral.toUpperCase()];
    }

    if (degreeInterval === undefined) {
        console.warn(`Unknown Roman numeral base: ${numeral} in "${firstChordInSplit}". Assuming I of key.`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }

    let chordRootIndex = (keyRootIndex + degreeInterval) % 12;
    if (accidental === 'b') chordRootIndex = (chordRootIndex - 1 + 12) % 12;
    else if (accidental === '#') chordRootIndex = (chordRootIndex + 1) % 12;
    const chordRoot = NOTES_CHROMATIC[chordRootIndex];

    let finalQuality = getStandardQuality(qualitySuffix);

    // If no quality suffix, infer default from Roman numeral style and key
    if (!qualitySuffix) {
        if (isMinorKey) {
            if (numeral.toLowerCase() === 'v' && isUpperCaseNumeral) finalQuality = 'dom7'; // V7 in minor
            else if (numeral.toLowerCase() === 'vii' && isUpperCaseNumeral) finalQuality = 'dim7'; // VII°7 (leading tone dim7)
            else if (numeral.toLowerCase() === 'ii' && !isUpperCaseNumeral) finalQuality = 'min7b5'; // ii°7 or iim7b5
            else finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7'; // Default for others
        } else { // Major key
            if (numeral.toLowerCase() === 'v') finalQuality = 'dom7'; // V7 in major
            else if (numeral.toLowerCase() === 'vii') finalQuality = 'min7b5'; // vii°7 or viim7b5
            else finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7';
        }
    } else if (!CHORD_INTERVALS[finalQuality]) { // Suffix was present but not fully resolved
        console.warn(`Quality suffix "${qualitySuffix}" for Roman ${firstChordInSplit} not fully resolved. Defaulting based on numeral case.`);
        finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7';
    }
    return { root: chordRoot, quality: finalQuality, originalRoman: romanString };
}

function getChordNotes(root, quality) {
    let intervals = CHORD_INTERVALS[quality];
    if (!intervals) {
        console.warn(`Quality "${quality}" for root "${root}" not found. Defaulting to dom7 intervals.`);
        intervals = CHORD_INTERVALS['dom7'];
    }
    const standardizedRoot = standardizeNoteName(root);
    const rootIndex = NOTES.indexOf(standardizedRoot);
    if (rootIndex === -1) {
        console.error(`Invalid root note for getChordNotes: ${root}`);
        return [standardizedRoot];
    }
    return intervals.map(interval => NOTES[(rootIndex + interval + 12) % 12]);
}

function suggestScaleForQuality(quality) {
    const scaleMap = {
        'maj7': 'major', 'maj': 'major', 'maj6': 'major', 'maj9': 'major', '6/9': 'major',
        'dom7': 'mixolydian', 'dom9': 'mixolydian', 'dom7b9': 'diminishedHW', // HW for dom func
        'dom7#9': 'altered', 'alt': 'altered', 'dom7sus': 'mixolydian',
        '7#11': 'lydianDominant', 'maj7#11': 'lydian',
        'min7': 'dorian', 'min': 'dorian', 'min9': 'dorian', 'min6': 'dorian',
        'min7b5': 'locrian', // or Locrian #2
        'dim7': 'diminishedWH', // WH for dim func
        'imaj7': 'melodicMinor', 
    };
    return scaleMap[quality] || 'major'; // Default to major if no specific mapping
}

// ==================================
// === CHORD VOICING HELPERS ======
// ==================================
function generateInversions(baseNotes) {
    const voicings = [];
    voicings.push([...baseNotes]); 
    for (let i = 1; i < baseNotes.length; i++) {
        voicings.push([...baseNotes.slice(i), ...baseNotes.slice(0, i)]);
    }
    return voicings;
}

function generateDrop2Voicing(rootPositionNotes) {
    if (rootPositionNotes.length !== 4) return null;
    return [ rootPositionNotes[0], rootPositionNotes[2], rootPositionNotes[3], rootPositionNotes[1] ];
}

function getChordVoicing(baseNotesInRootPosition, quality) {
    let potentialVoicings = [];
    const simpleInversions = generateInversions(baseNotesInRootPosition);
    potentialVoicings.push(...simpleInversions);

    if (baseNotesInRootPosition.length === 4) {
        if (Math.random() < 0.25) { 
            const drop2 = generateDrop2Voicing(baseNotesInRootPosition);
            if (drop2) potentialVoicings.push(drop2);
        }
        if (Math.random() < 0.10) { 
            potentialVoicings.push([ baseNotesInRootPosition[0], baseNotesInRootPosition[3], baseNotesInRootPosition[1], baseNotesInRootPosition[2] ]);
        }
    }
    return potentialVoicings[Math.floor(Math.random() * potentialVoicings.length)];
}

// ==================================
// === DOM UTILITIES & UI UPDATERS ==
// ==================================
function createKeyOptions(selectedKey = 'C') {
    return NOTES.map(note =>
        `<option value="${note}"${note === standardizeNoteName(selectedKey) ? ' selected' : ''}>${note}</option>`
    ).join('');
}

function createQualityOptions(selectedQuality = 'maj7') {
    const qualityDisplayOrder = [
        { value: 'maj7', label: 'maj7' }, { value: 'dom7', label: '7' }, { value: 'min7', label: 'm7' },
        { value: 'min7b5', label: 'm7b5' }, { value: 'dim7', label: 'dim7' }, { value: 'maj6', label: 'maj6' },
        { value: 'min6', label: 'm6' }, { value: 'dom7b9', label: '7b9' }, { value: 'dom7#9', label: '7#9' },
        { value: 'dom7b5', label: '7b5' }, { value: 'alt', label: 'alt' }, { value: 'dom7sus', label: '7sus' },
        { value: 'imaj7', label: 'm(maj7)' }, { value: 'maj', label: 'maj' }, { value: 'min', label: 'min' },
        { value: 'dim', label: 'dim' }, { value: 'aug', label: 'aug' }, { value: 'sus4', label: 'sus4' },
        { value: 'sus2', label: 'sus2' }, { value: '6/9', label: '6/9'},
        { value: '7#11', label: '7#11'}, { value: 'maj7#11', label: 'maj7#11'}
    ];
    return qualityDisplayOrder.map(q =>
        `<option value="${q.value}"${q.value === selectedQuality ? ' selected' : ''}>${q.label}</option>`
    ).join('');
}

function createScaleOptions(selectedScale = 'major') {
    return Object.keys(SCALES).map(scaleName => {
        const displayName = scaleName.replace(/([A-Z]+)/g, ' $1').replace(/([A-Z][a-z])/g, ' $1')
                                   .split(' ').map(s => s.charAt(0).toUpperCase() + s.substring(1)).join(' ').trim();
        return `<option value="${scaleName}"${scaleName === selectedScale ? ' selected' : ''}>${displayName}</option>`;
    }).join('');
}

function getSampleFileName(note, octave) {
  return `${note}${octave}.${FILE_FORMAT}`;
}

// ==================================
// === AUDIO PLAYBACK =============
// ==================================
async function ensureAudioInitializedUserInteraction() {
    if (!AppState.audioInitialized) {
        try {
            await AudioContextManager.initialize();
            log("Audio context initialized on user interaction.");
        } catch (e) {
            console.error('Audio initialization failed on user interaction:', e);
        }
    }
}

function playNote(noteNameWithOctave, volume = 0.5, duration = 500) {
    if (!AudioContextManager.context || !AudioContextManager.samplesLoaded || !noteNameWithOctave) {
        return;
    }
    const match = noteNameWithOctave.match(/^([A-G][#bs]?)(\d)$/i);
    if (!match) {
        console.warn(`Invalid note format for playback: ${noteNameWithOctave}`);
        return;
    }
    let [, pitchClass, octaveStr] = match;
    const samplePitchClass = standardizeNoteNameForSamples(pitchClass);
    const octave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], parseInt(octaveStr)));
    const sampleKey = `${samplePitchClass}${octave}`;
    const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

    if (!buffer) return;

    try {
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.setValueAtTime(volume, AudioContextManager.context.currentTime);
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);
        source.start(AudioContextManager.context.currentTime);
        source.stop(AudioContextManager.context.currentTime + duration / 1000);
    } catch (e) {
        console.error('Error playing note:', e);
    }
}

function playChordInstance(notesWithOctavesToPlay, instanceStartTime, instanceDuration, connectToGainNode) {
    if (!notesWithOctavesToPlay || notesWithOctavesToPlay.length === 0) {
        return;
    }
    notesWithOctavesToPlay.forEach(noteWithOctave => {
        const match = noteWithOctave.match(/^([A-G][#bs]?)(\d)$/i);
        if (!match) {
            console.warn(`Invalid note format in playChordInstance: ${noteWithOctave}`);
            return;
        }
        let [, pitchClass, octaveStr] = match;
        const samplePitchClass = standardizeNoteNameForSamples(pitchClass);
        const finalSampleOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], parseInt(octaveStr)));

        const sampleKey = `${samplePitchClass}${finalSampleOctave}`;
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
        if (!buffer) { return; }

        try {
            const source = AudioContextManager.context.createBufferSource();
            source.buffer = buffer;
            source.connect(connectToGainNode);
            const timingVariance = Math.random() * 0.03; 
            source.start(instanceStartTime + timingVariance);
            source.stop(instanceStartTime + instanceDuration + timingVariance);
        } catch (e) {
            console.error(`Error playing sample ${sampleKey}:`, e);
        }
    });
}

function getMidiNoteNumber(noteNameWithOctave) {
    if (!noteNameWithOctave) return -1000; 
    const match = noteNameWithOctave.match(/^([A-G][#bs]?)(\d)$/i);
    if (!match) return -1000;

    let [, pitchClassStd, octaveStr] = match;
    pitchClassStd = standardizeNoteName(pitchClassStd); 
    const octave = parseInt(octaveStr);
    const noteVal = NOTES_CHROMATIC.indexOf(pitchClassStd);

    if (noteVal === -1) return -1000;
    return (octave * 12) + noteVal; 
}

function getBestVoicing_VoiceLed(baseNotesInRootPosition, quality,
                                 prevVoicingWithOctaves, targetOctaveRange,
                                 allowMoreVariationForRhythmicHit = false) {

    let candidatePCVoicings = [];
    const inversions = generateInversions(baseNotesInRootPosition);
    candidatePCVoicings.push(...inversions);

    if (baseNotesInRootPosition.length === 4) {
        const drop2 = generateDrop2Voicing(baseNotesInRootPosition);
        if (drop2) candidatePCVoicings.push(drop2);
    }
    candidatePCVoicings = [...new Set(candidatePCVoicings.map(v => JSON.stringify(v.slice().sort())))].map(s => JSON.parse(s));

    let scoredVoicings = [];

    for (const pcVoicing of candidatePCVoicings) {
        for (let octaveStartAttempt = targetOctaveRange[0]; octaveStartAttempt <= targetOctaveRange[0] + 1; octaveStartAttempt++) {
            let currentRealizedVoicing = [];
            let tempPcVoicingSorted = [...pcVoicing].sort((a, b) => NOTES_CHROMATIC.indexOf(standardizeNoteName(a)) - NOTES_CHROMATIC.indexOf(standardizeNoteName(b)));

            let currentOctave = octaveStartAttempt;
            currentRealizedVoicing.push(`${tempPcVoicingSorted[0]}${currentOctave}`);

            for (let i = 1; i < tempPcVoicingSorted.length; i++) {
                let noteName = tempPcVoicingSorted[i];
                let prevNoteMidi = getMidiNoteNumber(currentRealizedVoicing[i-1]);
                let currentNoteMidi = getMidiNoteNumber(`${noteName}${currentOctave}`);
                while (currentNoteMidi <= prevNoteMidi) {
                    currentOctave++;
                    currentNoteMidi = getMidiNoteNumber(`${noteName}${currentOctave}`);
                }
                if (currentNoteMidi > prevNoteMidi + 12 && getMidiNoteNumber(`${noteName}${currentOctave-1}`) > prevNoteMidi) {
                    currentOctave--;
                }
                currentRealizedVoicing.push(`${noteName}${currentOctave}`);
            }

            const minMidi = getMidiNoteNumber(currentRealizedVoicing[0]);
            const maxMidi = getMidiNoteNumber(currentRealizedVoicing[currentRealizedVoicing.length - 1]);
            const minSampleOctave = OCTAVES_FOR_SAMPLES[0];
            const maxSampleOctave = OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length-1];

            if (maxMidi - minMidi > 36) continue;
            if (maxMidi > getMidiNoteNumber(`${NOTES_CHROMATIC[11]}${maxSampleOctave}`) || minMidi < getMidiNoteNumber(`${NOTES_CHROMATIC[0]}${minSampleOctave}`)) continue;


            let score = 0;
            if (prevVoicingWithOctaves && prevVoicingWithOctaves.length === currentRealizedVoicing.length) {
                let totalMovement = 0;
                let commonTones = 0;
                let heldTones = 0;

                const sortedPrev = [...prevVoicingWithOctaves].sort((a, b) => getMidiNoteNumber(a) - getMidiNoteNumber(b));
                const sortedCurr = [...currentRealizedVoicing].sort((a, b) => getMidiNoteNumber(a) - getMidiNoteNumber(b));

                for (let k = 0; k < sortedCurr.length; k++) {
                    const prevNoteMIDI = getMidiNoteNumber(sortedPrev[k]);
                    const currNoteMIDI = getMidiNoteNumber(sortedCurr[k]);
                    totalMovement += Math.abs(currNoteMIDI - prevNoteMIDI);
                    if (prevNoteMIDI === currNoteMIDI) heldTones++;
                    if ((prevNoteMIDI % 12) === (currNoteMIDI % 12)) commonTones++;
                }
                score = (heldTones * 25) + (commonTones * 10) - totalMovement;
            } else {
                score = Math.random() * -5;
            }
            scoredVoicings.push({ voicing: currentRealizedVoicing, score });
        }
    }

    if (scoredVoicings.length === 0) {
        let fallbackOctave = targetOctaveRange[Math.floor(targetOctaveRange.length / 2)];
        if (!OCTAVES_FOR_SAMPLES.includes(fallbackOctave)) fallbackOctave = OCTAVES_FOR_SAMPLES[0];
        return baseNotesInRootPosition.map(note => `${note}${fallbackOctave}`);
    }

    scoredVoicings.sort((a, b) => b.score - a.score);

    if (allowMoreVariationForRhythmicHit && scoredVoicings.length > 1 && Math.random() < 0.6) {
        return scoredVoicings[Math.min(1, scoredVoicings.length - 1)].voicing;
    }

    if (Math.random() < 0.80 || scoredVoicings.length === 1) {
        return scoredVoicings[0].voicing;
    } else {
        return scoredVoicings[1].voicing;
    }
}

async function playChord(root, quality, startTime, duration) {
    if (!UI.elements.chordsEnabled.classList.contains('active') || !AudioContextManager.samplesLoaded) {
        previousPlayedVoicingNotesWithOctaves = null;
        return;
    }
    await AudioContextManager.ensureAudioContext();
    if (!AudioContextManager.context) {
        console.error("AudioContext not available in playChord");
        return;
    }

    const baseNotesInRootPosition = getChordNotes(root, quality);
    if (!baseNotesInRootPosition || baseNotesInRootPosition.length === 0) {
        console.warn(`Cannot play chord for ${root}${quality}: No notes found.`);
        previousPlayedVoicingNotesWithOctaves = null;
        return;
    }

    const overallVolume = parseFloat(UI.elements.chordVolume.value) * 0.7;
    if (overallVolume <= 0.001) {
        previousPlayedVoicingNotesWithOctaves = null;
        return;
    }

    if (AudioContextManager.currentChordGain) {
        try {
            if (typeof AudioContextManager.currentChordGain.gain.value === 'number' && isFinite(AudioContextManager.currentChordGain.gain.value)) {
                AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, startTime);
                AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
            } else {
                AudioContextManager.currentChordGain.gain.setValueAtTime(0.001, startTime + 0.05);
            }
        } catch (e) { console.warn("Error fading out previous chord gain:", e); }
    }

    const chordMasterGain = AudioContextManager.context.createGain();
    chordMasterGain.gain.setValueAtTime(0, startTime);
    chordMasterGain.gain.linearRampToValueAtTime(overallVolume, startTime + 0.02);

    if (AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0.001) {
        const dryGain = AudioContextManager.context.createGain();
        const wetGain = AudioContextManager.context.createGain();
        dryGain.gain.value = 1.0;
        wetGain.gain.value = AudioContextManager.reverbAmount;

        chordMasterGain.connect(dryGain);
        dryGain.connect(AudioContextManager.context.destination);
        chordMasterGain.connect(wetGain);
        wetGain.connect(AudioContextManager.reverbNode);

        if (!AudioContextManager.reverbNodeConnected && AudioContextManager.context.destination) {
            try { AudioContextManager.reverbNode.disconnect(); } catch(e) {} 
            AudioContextManager.reverbNode.connect(AudioContextManager.context.destination);
            AudioContextManager.reverbNodeConnected = true;
        }
    } else {
        chordMasterGain.connect(AudioContextManager.context.destination);
    }
    AudioContextManager.currentChordGain = chordMasterGain;

    const firstVoicingNotesWithOctaves = getBestVoicing_VoiceLed(
        baseNotesInRootPosition,
        quality,
        previousPlayedVoicingNotesWithOctaves,
        PLAYBACK_OCTAVES
    );

    if (!firstVoicingNotesWithOctaves || firstVoicingNotesWithOctaves.length === 0) {
        console.warn("getBestVoicing_VoiceLed returned no notes for first hit.");
        previousPlayedVoicingNotesWithOctaves = null;
        return;
    }
    
    playChordInstance(firstVoicingNotesWithOctaves, startTime, duration, chordMasterGain);
    previousPlayedVoicingNotesWithOctaves = [...firstVoicingNotesWithOctaves];

    const beatDurationSec = 60 / AppState.tempo;
    const timeSigNum = parseInt(UI.elements.timeSignature.value);
    const isLikelyFullMeasureChord = (timeSigNum === 4 && duration > (beatDurationSec * 2.5)) || (timeSigNum !== 4 && duration > (beatDurationSec * (timeSigNum / 2 + 0.5)));

    if (isLikelyFullMeasureChord) {
        const secondVoicingNotesWithOctaves = getBestVoicing_VoiceLed(
            baseNotesInRootPosition,
            quality,
            firstVoicingNotesWithOctaves,
            PLAYBACK_OCTAVES,
            true
        );
        if (!secondVoicingNotesWithOctaves || secondVoicingNotesWithOctaves.length === 0) {
             console.warn("getBestVoicing_VoiceLed returned no notes for second hit.");
        } else {
            const secondHitStartTime = startTime + duration / 2;
            playChordInstance(secondVoicingNotesWithOctaves, secondHitStartTime, duration / 2, chordMasterGain);
        }
    }
}
        
async function playMetronomeSound(volumeForThisTick, soundsForThisTickString) { 
    if (!AudioContextManager.context || !soundsForThisTickString) return;

    const metronomeOverallVolume = parseFloat(UI.elements.metronomeVolume.value);
    const selectedSoundType = UI.elements.soundType.value; 

    const soundsToPlayArray = soundsForThisTickString.split(',');
    
    const beatElement = UI.elements.beatsContainer.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    const isStrongStyledBeat = beatElement ? (parseFloat(beatElement.dataset.baseVolume) >= 0.9) : false;
    const accentMultiplier = isStrongStyledBeat ? parseFloat(UI.elements.accentIntensity?.value || 1.0) : 1.0;

    for (let soundKey of soundsToPlayArray) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;

        let bufferToPlay;
        let effectiveSoundKey = soundKey;
        let soundSpecificMixLevel = 1.0; 

        if (selectedSoundType === 'drums') { 
            const currentDrumSet = drumSoundSets[currentDrumSetIndex];
            let soundFilename;
            switch (soundKey) { 
                case 'kick':
                    soundFilename = currentDrumSet.kick;
                    if (UI.elements.kickVolume) soundSpecificMixLevel = parseFloat(UI.elements.kickVolume.value);
                    break;
                case 'snare':
                    soundFilename = currentDrumSet.snare;
                    if (UI.elements.snareVolume) soundSpecificMixLevel = parseFloat(UI.elements.snareVolume.value);
                    break;
                case 'hihat':
                    soundFilename = currentDrumSet.hihat;
                    if (UI.elements.hihatVolume) soundSpecificMixLevel = parseFloat(UI.elements.hihatVolume.value);
                    break;
                default: 
                    effectiveSoundKey = 'click'; 
                    soundFilename = null; 
                    soundSpecificMixLevel = 1.0; 
                    break;
            }

            if (soundFilename) { 
                effectiveSoundKey = soundFilename; 
                if (!AudioContextManager.soundBuffers[soundFilename]) {
                    try {
                        const response = await fetch(`./${soundFilename}`);
                        if (!response.ok) throw new Error(`HTTP ${response.status} for ${soundFilename}`);
                        const arrayBuffer = await response.arrayBuffer();
                        AudioContextManager.soundBuffers[soundFilename] = await AudioContextManager.context.decodeAudioData(arrayBuffer);
                    } catch (e) {
                        console.error(`Failed to load drum sample ${soundFilename} on-the-fly:`, e);
                        bufferToPlay = AudioContextManager.soundBuffers[soundKey] || AudioContextManager.soundBuffers['click'];
                        effectiveSoundKey = soundKey; 
                    }
                }
                bufferToPlay = AudioContextManager.soundBuffers[soundFilename];
            } else { 
                 bufferToPlay = AudioContextManager.soundBuffers[effectiveSoundKey] || AudioContextManager.soundBuffers['click'];
            }
        } else { 
            effectiveSoundKey = selectedSoundType; 
            bufferToPlay = AudioContextManager.soundBuffers[selectedSoundType] || AudioContextManager.soundBuffers['click'];
            soundSpecificMixLevel = 1.0; 
        }

        if (!bufferToPlay) continue;
        
        let actualFinalVolume = metronomeOverallVolume * volumeForThisTick * soundSpecificMixLevel * accentMultiplier;
        actualFinalVolume = Math.min(Math.max(actualFinalVolume, 0), 1.0); 

        if (actualFinalVolume <= 0.001) continue; 

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = bufferToPlay;
        const gainNode = AudioContextManager.context.createGain();

        gainNode.gain.setValueAtTime(actualFinalVolume, AudioContextManager.context.currentTime);
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);

        if (selectedSoundType === 'drums' && AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0.01) {
            const reverbSendGain = AudioContextManager.context.createGain();
            reverbSendGain.gain.setValueAtTime(0.05 * AudioContextManager.reverbAmount, AudioContextManager.context.currentTime); 
            gainNode.connect(reverbSendGain); 
            reverbSendGain.connect(AudioContextManager.reverbNode);
            if (!AudioContextManager.reverbNodeConnected && AudioContextManager.context.destination) {
                 try { AudioContextManager.reverbNode.disconnect(); } catch(e) {}
                 AudioContextManager.reverbNode.connect(AudioContextManager.context.destination);
                 AudioContextManager.reverbNodeConnected = true;
            }
        }
        source.start(AudioContextManager.context.currentTime);
    }
}

// ==================================
// === FRETBOARD UI ===============
// ==================================
function createFretboard(fretboardContainer, tuningArray) {
    if (!(fretboardContainer instanceof HTMLElement)) {
        console.error("Invalid fretboard container provided to createFretboard.");
        return;
    }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) {
        console.error("Invalid or empty tuning array provided to createFretboard.");
        return;
    }

    fretboardContainer.innerHTML = '';
    const numFrets = 12;
    const numStrings = tuningArray.length;

    const nutElement = document.createElement('div');
    nutElement.className = 'fret-line';
    nutElement.style.left = '0%';
    nutElement.style.width = '4px';
    nutElement.style.backgroundColor = '#4A3B31';
    nutElement.style.zIndex = '1';
    fretboardContainer.appendChild(nutElement);

    for (let i = 1; i <= numFrets; i++) {
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`;
        fretboardContainer.appendChild(fretLine);

        const fretNumber = document.createElement('div');
        fretNumber.className = 'fret-number';
        fretNumber.textContent = i;
        fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
        fretboardContainer.appendChild(fretNumber);
    }

    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        const stringYPosition = (((numStrings - 1 - stringIndex) / (numStrings - 1)) * 96) + 2;
        stringLine.style.top = `${stringYPosition}%`;
        fretboardContainer.appendChild(stringLine);
    }

    const markerPositions = [3, 5, 7, 9, 12];
    markerPositions.forEach(fretPos => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((fretPos - 0.5) / numFrets) * 100}%`;
        if (fretPos === 12) {
            const topMarker = marker.cloneNode(true);
            topMarker.style.top = `33%`;
            fretboardContainer.appendChild(topMarker);
            marker.style.top = `67%`;
        } else {
            marker.style.top = '50%';
        }
        fretboardContainer.appendChild(marker);
    });
}

function updateFretboardNotes(fretboardContainer, rootNote, scaleName, tuningArray, measureContext = null) {
    if (!(fretboardContainer instanceof HTMLElement)) { console.error('Invalid fretboardContainer'); return; }
    const standardizedRoot = standardizeNoteName(rootNote);
    if (!NOTES.includes(standardizedRoot)) { console.error(`Invalid scale root: ${rootNote}`); return; }
    const scaleData = SCALES[scaleName];
    if (!scaleData) { console.error(`Invalid scale: ${scaleName}`); return; }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) { console.error('Invalid tuning array'); return; }

    clearGuideToneHighlights();
    fretboardContainer.querySelectorAll('.note').forEach(el => el.remove());

    if (fretboardContainer.id === 'chord-fretboard' && UI.elements.scaleDisplay) {
        let displayScaleTypeName = scaleName;
        const tempScaleSelect = document.createElement('select');
        tempScaleSelect.innerHTML = createScaleOptions(scaleName);
        const selectedOptionEl = tempScaleSelect.querySelector(`option[value="${scaleName}"]`);
        displayScaleTypeName = selectedOptionEl ? selectedOptionEl.textContent : scaleName.replace(/([A-Z])/g, ' $1').split(' ').map(s => s.charAt(0).toUpperCase() + s.substring(1)).join(' ').trim();

        let chordRootForDisplay = "", chordQualityTextForDisplay = "";
        let actualMeasurePartContext = measureContext;
        if (measureContext && measureContext.classList.contains('measure')) {
            actualMeasurePartContext = measureContext.querySelector('.measure-part.part-active') || measureContext.querySelector('.measure-part');
        }

        if (actualMeasurePartContext) {
            chordRootForDisplay = actualMeasurePartContext.querySelector('.chord-controls .root-note')?.value;
            const chordQualityRaw = actualMeasurePartContext.querySelector('.chord-controls .chord-quality')?.value;
            const qualityOptionEl = actualMeasurePartContext.querySelector(`.chord-controls .chord-quality option[value="${chordQualityRaw}"]`);
            chordQualityTextForDisplay = qualityOptionEl ? qualityOptionEl.textContent : (chordQualityRaw || "");
        } else {
            const firstMeasurePart = UI.elements.measures.children[0]?.querySelector('.measure-part');
            if (firstMeasurePart) {
                chordRootForDisplay = firstMeasurePart.querySelector('.chord-controls .root-note')?.value;
                const chordQualityRaw = firstMeasurePart.querySelector('.chord-controls .chord-quality')?.value;
                const qualityOptionEl = firstMeasurePart.querySelector(`.chord-controls .chord-quality option[value="${chordQualityRaw}"]`);
                chordQualityTextForDisplay = qualityOptionEl ? qualityOptionEl.textContent : (chordQualityRaw || "");
            }
        }
        UI.elements.scaleDisplay.textContent = chordRootForDisplay && chordQualityTextForDisplay ?
            `${standardizedRoot} ${displayScaleTypeName} over ${chordRootForDisplay}${chordQualityTextForDisplay}` :
            `${standardizedRoot} ${displayScaleTypeName}`;
    }

    const rootIndex = NOTES.indexOf(standardizedRoot); 
    const notesInScale = scaleData.map(interval => NOTES[(rootIndex + interval) % 12]); 
    const numStrings = tuningArray.length;
    const numFrets = 12; 

    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) {
        const openStringNote = standardizeNoteName(tuningArray[stringIndex]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);
        if (openStringNoteIndex === -1) { console.warn(`Invalid open string: ${tuningArray[stringIndex]}`); continue; }

        const FNO_Key = `string${numStrings - stringIndex}`; 

        for (let fret = 0; fret <= numFrets; fret++) {
            const currentNoteNameOnString = NOTES[(openStringNoteIndex + fret + 12) % 12];
            if (notesInScale.includes(currentNoteNameOnString)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNoteNameOnString;
                noteElement.style.left = (fret === 0) ? `-2%` : `${((fret - 0.5) / numFrets) * 100}%`;
                
                const stringYPosition = (((numStrings - 1 - stringIndex) / (numStrings - 1)) * 96) + 2;
                noteElement.style.top = `${stringYPosition}%`;

                noteElement.style.backgroundColor = (currentNoteNameOnString === standardizedRoot) ? '#BD2031' : 
                    (notesInScale.indexOf(currentNoteNameOnString) % 2 === 0) ? '#006400' : '#4CAF50';
                
                let noteOctaveForPlayback = `${currentNoteNameOnString}3`;
                const isStandardGuitarTuning = tuningArray.length === 6 && tuningArray.join('') === "EADGBE";
                if (isStandardGuitarTuning && FRETBOARD_NOTES_OCTAVES[FNO_Key] && fret < FRETBOARD_NOTES_OCTAVES[FNO_Key].length) {
                    noteOctaveForPlayback = FRETBOARD_NOTES_OCTAVES[FNO_Key][fret];
                } else {
                    let approxOctave = PLAYBACK_OCTAVES[0];
                    if (stringIndex >= numStrings * 2/3 ) approxOctave = PLAYBACK_OCTAVES[PLAYBACK_OCTAVES.length -1];
                    else if (stringIndex >= numStrings / 3) approxOctave = PLAYBACK_OCTAVES[Math.floor(PLAYBACK_OCTAVES.length / 2)];
                    if (fret > 7 && approxOctave < OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1]) {
                        approxOctave = Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], approxOctave + 1);
                    }
                    approxOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], approxOctave));
                    noteOctaveForPlayback = `${currentNoteNameOnString}${approxOctave}`;
                }
                noteElement.dataset.note = noteOctaveForPlayback;

                noteElement.addEventListener('click', async (event) => {
                    event.stopPropagation(); 
                    await AudioContextManager.ensureAudioContext();
                    const volume = fretboardContainer.id.startsWith('fretflow-fretboard') ? 0.4 : parseFloat(UI.elements.chordFretboardVolume.value);
                    playNote(noteElement.dataset.note, volume, 500); 
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                    setTimeout(() => {
                        const isHighlighted = noteElement.classList.contains('guide-tone-highlight') || noteElement.classList.contains('root-highlight-for-guides');
                        noteElement.style.transform = `translate(-50%, -50%) scale(${isHighlighted ? 0.95 : 1})`;
                    }, 150);
                });
                fretboardContainer.appendChild(noteElement);
            }
        }
    }
    if (AppState.guideTonesActive && fretboardContainer.id === 'chord-fretboard') {
        highlightGuideTones(measureContext);
    }
}

// ==================================
// === METRONOME UI & LOGIC =======
// ==================================
function createBeats() {
    const beatsContainer = UI.elements.beatsContainer;
    if (!beatsContainer) { console.error("Beats container not found"); return; }
    beatsContainer.innerHTML = '';

    const timeSignatureNum = parseInt(UI.elements.timeSignature.value);
    const selectedSoundType = UI.elements.soundType.value;
    const isDrumStyleActive = selectedSoundType === 'drums' && timeSignatureNum === 4;
    const currentStyleKey = isDrumStyleActive ? AppState.currentRhythmicStyle : "quarterNotes"; // Fallback for non-drum styles
    const styleDefinition = RHYTHMIC_STYLES[currentStyleKey] || RHYTHMIC_STYLES.quarterNotes;

    let beatsToDisplay = timeSignatureNum;
    let subdivisionFactor = 1;
    if (timeSignatureNum === 4) {
        beatsToDisplay = 8; // We always show 8 subdivisions for 4/4
        subdivisionFactor = 2;
    } else if (timeSignatureNum === 6 || timeSignatureNum === 12) {
        beatsToDisplay = timeSignatureNum;
        subdivisionFactor = 3;
    } else {
        beatsToDisplay = timeSignatureNum;
        subdivisionFactor = 1;
    }

    for (let i = 0; i < beatsToDisplay; i++) {
        const beatDiv = document.createElement('div');
        beatDiv.className = 'beat';
        beatDiv.dataset.beat = i;

        let beatLabel = `${Math.floor(i / subdivisionFactor) + 1}`;
        if (subdivisionFactor === 2 && (i % subdivisionFactor !== 0)) {
            beatLabel = (i % 2 === 1) ? "&" : `${Math.floor(i / 2) + 1}`;
        } else if (subdivisionFactor > 1 && (i % subdivisionFactor !== 0)) {
            // Could add more specific labeling for triplets if needed
        }
        beatDiv.innerHTML = beatLabel;

        let sound = 'silent';
        let volume = 0.1;
        let color = '#666666';

        if (isDrumStyleActive) { // Drum styles (e.g., standardSwing, bossaNova)
            const patternIndexInStyle = i % styleDefinition.beatsPerPattern;
            const beatData = styleDefinition.pattern[patternIndexInStyle];

            if (beatData) {
                sound = beatData.sound;
                volume = beatData.volume;
                color = beatData.color;
            } else {
                sound = 'silent';
                volume = 0.0;
                color = '#444444';
            }
        } else { // Non-drum sound type (click, woodblock) OR not 4/4 time for drums
            if (i % subdivisionFactor === 0) { // Main beat
                sound = selectedSoundType; // 'click' or 'woodblock'
                volume = (i === 0) ? 1.0 : 0.7; // Beat 1 is loudest, others softer
                color = (i === 0) ? '#1F618D' : '#5DADE2';
            } else { // This is a subdivision (e.g., the "&" in 4/4)
                sound = 'silent'; // Explicitly make subdivisions silent for click/woodblock
                volume = 0.0;     // Ensure it's truly silent
                color = '#888888'; // A slightly different color for silent subdivisions
            }
        }

        beatDiv.dataset.sound = sound;
        beatDiv.dataset.baseVolume = volume; // Store the style's/default's original volume
        beatDiv.dataset.volume = volume;     // Current volume (can be changed by user click)
        beatDiv.style.backgroundColor = color;
        
        beatDiv.addEventListener('click', () => {
            toggleBeatAccent(beatDiv, selectedSoundType, subdivisionFactor > 1 && (i % subdivisionFactor !== 0), isDrumStyleActive);
        });
        beatsContainer.appendChild(beatDiv);
    }
}
        
function toggleBeatAccent(beatElement, currentSoundType, isSubdivision, isDrumStyleActive) {
    const currentVolume = parseFloat(beatElement.dataset.volume);
    let newVolume, newSound, newColor;

    if (isDrumStyleActive) { 
        const drumCycle = [
            { sound: 'silent',      volume: 0,   color: '#444' }, 
            { sound: 'hihat',       volume: 0.3, color: '#9E9E9E' },
            { sound: 'snare',       volume: 0.8, color: '#D9534F' }, 
            { sound: 'kick',        volume: 1.0, color: '#1F618D' }, 
            { sound: 'snare,hihat', volume: 0.8, color: '#D35400' },
            { sound: 'kick,hihat',  volume: 1.0, color: '#27AE60' }
        ];
        let currentIndex = drumCycle.findIndex(s => s.sound === beatElement.dataset.sound && Math.abs(s.volume - currentVolume) < 0.01);
        if (currentIndex === -1) { 
            currentIndex = drumCycle.findIndex(s => s.sound.startsWith(beatElement.dataset.sound.split(',')[0])) || 0;
        }

        let nextIndex = (currentIndex + 1) % drumCycle.length;
        
        if (isSubdivision && (drumCycle[nextIndex].sound.includes('kick') || drumCycle[nextIndex].sound.includes('snare,'))) {
             if (!beatElement.dataset.sound.includes('kick') && !beatElement.dataset.sound.includes('snare')) {
                nextIndex = drumCycle.findIndex(s => s.sound === 'hihat') ?? 1;
             }
        }
        newSound = drumCycle[nextIndex].sound; 
        newVolume = drumCycle[nextIndex].volume; 
        newColor = drumCycle[nextIndex].color;
    } else { 
        const simpleCycle = [
            { volume: 0,   sound: 'silent',         color: '#666' },
            { volume: 0.3, sound: currentSoundType, color: '#9E9E9E' },
            { volume: 1.0, sound: currentSoundType, color: '#1F618D' }
        ];
        let currentIndex = simpleCycle.findIndex(s => Math.abs(s.volume - currentVolume) < 0.01 && (s.sound === beatElement.dataset.sound || (s.sound === 'silent' && currentVolume === 0)));
        if (currentIndex === -1) currentIndex = (currentVolume > 0.5) ? 2 : (currentVolume > 0) ? 1 : 0;
        
        const nextState = simpleCycle[(currentIndex + 1) % simpleCycle.length];
        newVolume = nextState.volume; newSound = nextState.sound; newColor = nextState.color;
    }
    beatElement.dataset.volume = newVolume;
    beatElement.dataset.sound = newSound;
    beatElement.style.backgroundColor = newColor;
}

function onMetronomeInstrumentChange(selectedInstrument) {
    const showDrumsUI = selectedInstrument === "drums";
    if (UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.style.display = showDrumsUI ? "inline-block" : "none";
    if (UI.elements.kickVolumeContainer) UI.elements.kickVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    if (UI.elements.snareVolumeContainer) UI.elements.snareVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    if (UI.elements.hihatVolumeContainer) UI.elements.hihatVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    createBeats();
}

// ==================================
// === PLAYBACK ENGINE ============
// ==================================
async function playBeat() {
    const beatsUI = UI.elements.beatsContainer.querySelectorAll('.beat');
    const measures = UI.elements.measures.children;
    if (beatsUI.length === 0) return;

    const timeSignatureNum = parseInt(UI.elements.timeSignature.value);
    const selectedSoundType = UI.elements.soundType.value;
    const isDrumStyleActive = selectedSoundType === 'drums' && timeSignatureNum === 4;
    const activeStyleKey = isDrumStyleActive ? AppState.currentRhythmicStyle : "quarterNotes";
    const activeStyle = RHYTHMIC_STYLES[activeStyleKey] || RHYTHMIC_STYLES.quarterNotes;

    beatsUI.forEach(b => b.classList.remove('active'));
    const currentUIBeatElement = beatsUI[AppState.currentBeat]; 
    if (currentUIBeatElement) {
        currentUIBeatElement.classList.add('active');
    }
    
    const stylePatternData = activeStyle.pattern[AppState.currentStylePatternBeat];
    let soundToPlay, volumeToPlay;

    if (currentUIBeatElement) { 
        soundToPlay = currentUIBeatElement.dataset.sound;
        volumeToPlay = parseFloat(currentUIBeatElement.dataset.volume);
    } else if (stylePatternData) { 
        soundToPlay = stylePatternData.sound;
        volumeToPlay = stylePatternData.volume;
    } else { 
        soundToPlay = 'silent';
        volumeToPlay = 0;
    }
    
    if (volumeToPlay > 0 || (selectedSoundType === 'drums' && soundToPlay !== 'silent') ) { 
        await playMetronomeSound(volumeToPlay, soundToPlay); 
    }

    if (measures.length > 0) {
        let measureToPlayIndex = AppState.currentMeasure;
         if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            if (AppState.currentMeasure < AppState.loopStartMeasure || AppState.currentMeasure > AppState.loopEndMeasure) {
                AppState.currentMeasure = AppState.loopStartMeasure;
            }
            measureToPlayIndex = AppState.currentMeasure;
        }

        const currentMeasureElement = measures[measureToPlayIndex];
        if (currentMeasureElement) {
            Array.from(measures).forEach((m, idx) => m.classList.toggle('active', idx === measureToPlayIndex));
            
            const isSplitMeasure = currentMeasureElement.dataset.isSplit === 'true';
            const is44Time = timeSignatureNum === 4; 
            const numDisplayedBeats = beatsUI.length; 

            let activePartIndex = 0;
            let playChordOnThisBeat = AppState.currentBeat === 0; 
            if (is44Time && isSplitMeasure && numDisplayedBeats === 8) {
                activePartIndex = (AppState.currentBeat < 4) ? 0 : 1; 
                playChordOnThisBeat = (AppState.currentBeat === 0 || AppState.currentBeat === 4);
            }
            
            currentMeasureElement.querySelectorAll('.measure-part').forEach((part, idx) => {
                part.classList.toggle('part-active', idx === activePartIndex);
            });

            const activeMeasurePart = currentMeasureElement.querySelectorAll('.measure-part')[activePartIndex];
            if (activeMeasurePart && playChordOnThisBeat) { 
                const root = activeMeasurePart.querySelector('.root-note')?.value;
                const quality = activeMeasurePart.querySelector('.chord-quality')?.value;
                const scaleRoot = activeMeasurePart.querySelector('.second-key')?.value;
                const scaleType = activeMeasurePart.querySelector('.scale-select')?.value;

                if (root && quality && scaleRoot && scaleType) {
                    const tuning = TUNINGS[UI.elements.chordTuning.value];
                    updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning, activeMeasurePart);
                    if (AppState.guideTonesActive) highlightGuideTones(activeMeasurePart);
                    
                    const beatDurationSec = 60 / AppState.tempo;
                    let chordPlayDurationSec = beatDurationSec * (timeSignatureNum === 4 && numDisplayedBeats === 8 ? 4 : timeSignatureNum) ; 
                    if (is44Time && isSplitMeasure && numDisplayedBeats === 8) {
                         chordPlayDurationSec = beatDurationSec * 2; 
                    }
                    await playChord(root, quality, AudioContextManager.context.currentTime, chordPlayDurationSec);
                }
            }
        }
    }

    AppState.currentBeat = (AppState.currentBeat + 1) % beatsUI.length; 
    AppState.currentStylePatternBeat = (AppState.currentStylePatternBeat + 1) % activeStyle.beatsPerPattern; 

    if (AppState.currentBeat === 0) { 
        AppState.currentStyleBar = (AppState.currentStyleBar + 1) % (activeStyle.beatsPerPattern / beatsUI.length || 1); 

        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            AppState.currentMeasure = (AppState.currentMeasure >= AppState.loopEndMeasure) ? AppState.loopStartMeasure : AppState.currentMeasure + 1;
        } else if (measures.length > 0) {
            AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
        }
        
        if (AppState.currentStylePatternBeat === 0) {
            AppState.currentStyleBar = 0;
        }
        updateNextChordDisplay();
    }
}

async function startPlayback() {
    try {
        await AudioContextManager.ensureAudioContext();
        if (AppState.isPlaying) return;

        const timeSignatureNumerator = parseInt(UI.elements.timeSignature.value);
        let intervalMs = (60 / AppState.tempo) * 1000;
        if (timeSignatureNumerator === 4 && UI.elements.beatsContainer.querySelectorAll('.beat').length === 8) {
            intervalMs /= 2; 
        } else if ((timeSignatureNumerator === 6 || timeSignatureNumerator === 12) && UI.elements.beatsContainer.querySelectorAll('.beat').length === timeSignatureNumerator){
        }

        if (!AppState.intervalId) { 
            AppState.currentBeat = 0;
            AppState.currentStylePatternBeat = 0;
            AppState.currentStyleBar = 0;
            AppState.currentMeasure = (AppState.loopingActive && AppState.loopStartMeasure !== -1) ? AppState.loopStartMeasure : 0;
        }
        
        await playBeat(); 
        clearInterval(AppState.intervalId); 
        AppState.intervalId = setInterval(async () => { await playBeat(); }, intervalMs);

        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started.");
    } catch (e) {
        console.error('Failed to start playback:', e);
        stopPlayback();
        alert("Error starting playback. Audio system might not be available.");
    }
}

function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false });
    previousPlayedVoicingNotesWithOctaves = null;

    UI.elements.beatsContainer.querySelectorAll('.beat.active').forEach(b => b.classList.remove('active'));
    UI.elements.measures.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));
    UI.elements.measures.querySelectorAll('.measure-part.part-active').forEach(p => p.classList.remove('part-active'));

    if (AudioContextManager.currentChordGain && AudioContextManager.context) {
        try {
            const now = AudioContextManager.context.currentTime;
            if (AudioContextManager.currentChordGain.gain) {
                AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, now);
                AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            }
        } catch (rampError) { console.warn("Gain ramp error on stop:", rampError.message); }
        finally { AudioContextManager.currentChordGain = null; }
    }
    if (UI.elements.nextChordDisplay) UI.elements.nextChordDisplay.textContent = "";
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped.");
}
function updateRhythmicStyleUIVisibility() {
    const soundType = UI.elements.soundType.value;
    const timeSig = UI.elements.timeSignature.value;
    const styleContainer = UI.elements.rhythmicStyleContainer;

    if (soundType === 'drums' && timeSig === '4') {
        styleContainer.style.display = 'inline-flex'; 
    } else {
        styleContainer.style.display = 'none';
    }
}

// ==================================
// === PROGRESSION MANAGEMENT =====
// ==================================
function updateNextChordDisplay(currentMeasureIndex = AppState.currentMeasure) {
    const nextChordDisplayElement = UI.elements.nextChordDisplay;
    if (!nextChordDisplayElement) return;

    const measures = UI.elements.measures.children;
    if (measures.length === 0) {
        nextChordDisplayElement.textContent = ""; return;
    }

    let upcomingChords = [];
    let displayCount = 0;
    let tempMeasureIdx = currentMeasureIndex;
    let tempPartIdx = 0;
    const displayedBeats = UI.elements.beatsContainer.querySelectorAll('.beat'); 

    const currentMeasureEl = measures[currentMeasureIndex];
    if (currentMeasureEl && currentMeasureEl.dataset.isSplit === 'true' && parseInt(UI.elements.timeSignature.value) === 4 && displayedBeats.length === 8) {
        if (AppState.currentBeat < 4) { 
            tempPartIdx = 1; 
        } else { 
            tempMeasureIdx = (currentMeasureIndex + 1);
            tempPartIdx = 0;
        }
    } else { 
        tempMeasureIdx = (currentMeasureIndex + 1);
        tempPartIdx = 0;
    }

    while (displayCount < 4) {
        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            if (tempMeasureIdx > AppState.loopEndMeasure || tempMeasureIdx < AppState.loopStartMeasure) {
                tempMeasureIdx = AppState.loopStartMeasure;
                tempPartIdx = 0;
            }
        } else {
            if (tempMeasureIdx >= measures.length) {
                if (measures.length === 0) break; 
                tempMeasureIdx = 0; 
                tempPartIdx = 0;
            }
        }
        
        if (tempMeasureIdx >= measures.length) break; 

        const measureElement = measures[tempMeasureIdx];
        if (!measureElement) break;

        const measureParts = measureElement.querySelectorAll('.measure-part');
        const isSplit = measureElement.dataset.isSplit === 'true' && parseInt(UI.elements.timeSignature.value) === 4;

        for (let pIdx = tempPartIdx; pIdx < (isSplit ? 2 : 1) && displayCount < 4; pIdx++) {
            const partElement = measureParts[pIdx];
            if (!partElement) continue;

            const root = partElement.querySelector('.root-note')?.value;
            const qualityRaw = partElement.querySelector('.chord-quality')?.value;

            if (root && qualityRaw) {
                const qualityOption = partElement.querySelector(`.chord-quality option[value="${qualityRaw}"]`);
                const qualityDisplay = qualityOption ? qualityOption.textContent : qualityRaw;
                upcomingChords.push(`${root}${qualityDisplay}`);
                displayCount++;
            }
        }
        
        tempMeasureIdx++; 
        tempPartIdx = 0;  

        if (displayCount >= 4) break;
        if (measures.length > 0 && tempMeasureIdx === currentMeasureIndex && !AppState.loopingActive && measures.length > 1 && upcomingChords.length >= measures.length * (isSplit ? 2:1) ) break; 
        if (AppState.loopingActive && tempMeasureIdx > AppState.loopEndMeasure && AppState.loopStartMeasure === AppState.loopEndMeasure && upcomingChords.length > 0) break;
    }

    nextChordDisplayElement.textContent = upcomingChords.length > 0 ? `Next: ${upcomingChords.join(', ')}` : "";
}

function loadProgression(progressionName, overrideKey = null, isUserSong = false) {
    previousPlayedVoicingNotesWithOctaves = null;
    const songTitleElem = UI.elements.currentSongTitleFretboard;
    const songDescElem = UI.elements.currentSongDescriptionFretboard;

    let progressionData;
    if (isUserSong) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        progressionData = userSongs[progressionName];
    } else {
        progressionData = progressions[progressionName];
    }

    if (!progressionName || !progressionData) {
        currentProgressionName = "";
        currentFunctionalProgression = [];
        UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
        if (songTitleElem) songTitleElem.textContent = "";
        if (songDescElem) songDescElem.textContent = "";
        if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "Select a progression and key.";
        updateNextChordDisplay();
        resetLoop();
        return;
    }

    currentProgressionName = progressionName;
    currentFunctionalProgression = progressionData.progression; 
    
    const targetGlobalKey = overrideKey || progressionData.defaultKey || "C";
    const originalSongDefaultKey = progressionData.defaultKey || "C"; 

    const originalSongDefaultKeyRoot = standardizeNoteName(originalSongDefaultKey.replace('m', ''));
    const targetGlobalKeyRoot = standardizeNoteName(targetGlobalKey.replace('m', ''));

    if (songTitleElem) songTitleElem.textContent = progressionData.displayName || progressionName.replace(/_/g, ' ');
    if (songDescElem) songDescElem.textContent = progressionData.description || "";
    if (UI.elements.keySelect) UI.elements.keySelect.value = targetGlobalKey; 

    UI.elements.measures.innerHTML = '';
    resetLoop();

    currentFunctionalProgression.forEach((rawChordStringFromDefinition, index) => {
        let partsToProcessBasedOnOriginalDefinition = [];
        let isSplitInOriginalDefinition = false;

        if (isUserSong && progressionData.parts && progressionData.parts[index]) {
            isSplitInOriginalDefinition = progressionData.splitStatus[index];
            progressionData.parts[index].forEach(userPartData => {
                const parsedOriginal = parseRomanNumeralToAbsoluteChord(userPartData.originalRoman || `${userPartData.root}${userPartData.quality}`, originalSongDefaultKey);
                partsToProcessBasedOnOriginalDefinition.push({
                    parsedInOriginalContext: parsedOriginal,
                    originalScaleRoot: userPartData.scaleRoot,
                    originalScaleType: userPartData.scaleType
                });
            });
        } else {
            let effectiveChordString = rawChordStringFromDefinition.trim();
            if (effectiveChordString.startsWith("(") && effectiveChordString.endsWith(")")) {
                effectiveChordString = effectiveChordString.substring(1, effectiveChordString.length - 1).trim();
            }

            const spaceParts = effectiveChordString.split(/\s+/);
            let chord1ForSpaceSplit = null;
            let chord2ForSpaceSplit = null;
            let identifiedAsSpaceSplit = false;

            if (spaceParts.length === 2) { // e.g. "Am7 D7"
                if (parseChord(spaceParts[0]) && parseChord(spaceParts[1])) {
                    chord1ForSpaceSplit = spaceParts[0];
                    chord2ForSpaceSplit = spaceParts[1];
                    identifiedAsSpaceSplit = true;
                }
            } else if (spaceParts.length === 4) { // e.g. "C maj7 G dom7"
                 const firstCandidate = `${spaceParts[0]} ${spaceParts[1]}`;
                 const secondCandidate = `${spaceParts[2]} ${spaceParts[3]}`;
                 if (parseChord(firstCandidate) && parseChord(secondCandidate)) {
                     chord1ForSpaceSplit = firstCandidate;
                     chord2ForSpaceSplit = secondCandidate;
                     identifiedAsSpaceSplit = true;
                 }
            }

            if (identifiedAsSpaceSplit) {
                isSplitInOriginalDefinition = true;
                partsToProcessBasedOnOriginalDefinition.push({
                    parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(chord1ForSpaceSplit, originalSongDefaultKey)
                });
                partsToProcessBasedOnOriginalDefinition.push({
                    parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(chord2ForSpaceSplit, originalSongDefaultKey)
                });
            } else {
                const potentialSlashSplit = effectiveChordString.split('/');
                const rawIsComplexSingleChord = parseChord(rawChordStringFromDefinition.trim());

                if (potentialSlashSplit.length === 2 &&
                    !rawIsComplexSingleChord && 
                    parseChord(potentialSlashSplit[0].trim()) && parseChord(potentialSlashSplit[1].trim())) {
                    
                    isSplitInOriginalDefinition = true;
                    partsToProcessBasedOnOriginalDefinition.push({
                        parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(potentialSlashSplit[0].trim(), originalSongDefaultKey)
                    });
                    partsToProcessBasedOnOriginalDefinition.push({
                        parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(potentialSlashSplit[1].trim(), originalSongDefaultKey)
                    });
                } else {
                    isSplitInOriginalDefinition = false;
                    partsToProcessBasedOnOriginalDefinition.push({
                        parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(effectiveChordString, originalSongDefaultKey)
                    });
                }
            }
        }

        let finalPartsDataForMeasure = [];
        partsToProcessBasedOnOriginalDefinition.forEach(originalPart => {
            const transposedChord = transposeChordData(originalPart.parsedInOriginalContext, originalSongDefaultKeyRoot, targetGlobalKeyRoot);
            
            let finalScaleRoot, finalScaleType;
            if (originalPart.originalScaleRoot && originalPart.originalScaleType) {
                const originalScaleRootData = { root: originalPart.originalScaleRoot, quality: 'maj' }; // Assume maj for scale root transposition
                const transposedScaleRootInfo = transposeChordData(originalScaleRootData, originalSongDefaultKeyRoot, targetGlobalKeyRoot);
                finalScaleRoot = transposedScaleRootInfo.root;
                finalScaleType = originalPart.originalScaleType;
            } else {
                finalScaleRoot = transposedChord.root;
                finalScaleType = suggestScaleForQuality(transposedChord.quality);
            }

            finalPartsDataForMeasure.push({
                root: transposedChord.root,
                quality: transposedChord.quality,
                scaleRoot: finalScaleRoot,
                scaleType: finalScaleType
            });
        });
        
        if (isSplitInOriginalDefinition && finalPartsDataForMeasure.length === 1) {
            // If logic determined it should be split but only one part was generated (e.g. from a single Roman Numeral)
            // duplicate the part. This shouldn't happen with the new logic if two distinct chords are parsed.
            finalPartsDataForMeasure.push({ ...finalPartsDataForMeasure[0] });
        }
        
        addMeasure(
            finalPartsDataForMeasure[0].root,
            finalPartsDataForMeasure[0].quality,
            finalPartsDataForMeasure[0].scaleRoot,
            finalPartsDataForMeasure[0].scaleType,
            isSplitInOriginalDefinition,
            finalPartsDataForMeasure.length > 1 ? finalPartsDataForMeasure[1] : null
        );
    });

    updateMeasureNumbers();
    addFirstChordListener(); 
    updateNextChordDisplay();
    log(`Loaded ${isUserSong ? 'user song' : 'standard progression'}: ${progressionName} in key ${targetGlobalKey}`);
}

function updateProgressionKey(newKey) {
    previousPlayedVoicingNotesWithOctaves = null;
    if (!currentFunctionalProgression || currentFunctionalProgression.length === 0 || UI.elements.measures.children.length === 0) {
        const targetGlobalKeyRoot_noProg = standardizeNoteName(newKey.replace('m', ''));
        const initialTuning = TUNINGS[UI.elements.chordTuning.value];
        let defaultScaleType = 'major';
        const firstMeasurePartForDefault = UI.elements.measures.children[0]?.querySelector('.measure-part');
        if (firstMeasurePartForDefault) {
            defaultScaleType = firstMeasurePartForDefault.querySelector('.scale-select')?.value || 'major';
        }
        
        updateFretboardNotes(UI.elements.chordFretboard, targetGlobalKeyRoot_noProg, defaultScaleType, initialTuning, firstMeasurePartForDefault);
        if (UI.elements.scaleDisplay) {
            const scaleTypeName = firstMeasurePartForDefault ? (UI.elements.chordFretboard.querySelector('.scale-select option:checked')?.textContent || defaultScaleType) : 'Major';
            UI.elements.scaleDisplay.textContent = `${targetGlobalKeyRoot_noProg} ${scaleTypeName}`;
        }
        log(`No active progression. Fretboard updated for key: ${newKey}`);
        return;
    }

    const songDataForOriginalKey = progressions[currentProgressionName] ||
                                  JSON.parse(localStorage.getItem('userBebopProgressions') || '{}')[currentProgressionName];

    if (!songDataForOriginalKey || !songDataForOriginalKey.defaultKey) {
        console.warn(`Cannot re-key progression '${currentProgressionName}': Original defaultKey information is missing. Fretboard might not update correctly for all chords.`);
        const firstMeasurePart = UI.elements.measures.children[0]?.querySelector('.measure-part');
        if (firstMeasurePart) {
            const newTargetGlobalKeyRoot_fallback = standardizeNoteName(newKey.replace('m', ''));
            firstMeasurePart.querySelector('.root-note').value = newTargetGlobalKeyRoot_fallback;
            firstMeasurePart.querySelector('.second-key').value = newTargetGlobalKeyRoot_fallback;
            const quality = firstMeasurePart.querySelector('.chord-quality').value;
            firstMeasurePart.querySelector('.scale-select').value = suggestScaleForQuality(quality);
            handleMeasureControlChange(firstMeasurePart, firstMeasurePart.querySelector('.root-note'));
        }
        return;
    }

    const originalSongDefaultKey = songDataForOriginalKey.defaultKey;
    const originalSongDefaultKeyRoot = standardizeNoteName(originalSongDefaultKey.replace('m', ''));
    const newTargetGlobalKeyRoot = standardizeNoteName(newKey.replace('m', ''));

    Array.from(UI.elements.measures.children).forEach((measureElement, measureIndex) => {
        if (measureIndex < currentFunctionalProgression.length) {
            const rawChordStringFromDefinition = currentFunctionalProgression[measureIndex];
            const measurePartsUI = measureElement.querySelectorAll('.measure-part');
            
            let originalPartsToProcess = [];
             // let isSplitInOriginalDefinition = false; // Not needed here, UI already reflects split status

            if (isUserSongCurrentlyLoaded() && songDataForOriginalKey.parts && songDataForOriginalKey.parts[measureIndex]) {
                songDataForOriginalKey.parts[measureIndex].forEach(userPartData => {
                    const parsedOriginal = parseRomanNumeralToAbsoluteChord(userPartData.originalRoman || `${userPartData.root}${userPartData.quality}`, originalSongDefaultKey);
                    originalPartsToProcess.push({
                        parsedInOriginalContext: parsedOriginal,
                        originalScaleRoot: userPartData.scaleRoot,
                        originalScaleType: userPartData.scaleType
                    });
                });
            } else {
                let effectiveChordString = rawChordStringFromDefinition.trim();
                if (effectiveChordString.startsWith("(") && effectiveChordString.endsWith(")")) {
                    effectiveChordString = effectiveChordString.substring(1, effectiveChordString.length - 1).trim();
                }

                const spaceParts = effectiveChordString.split(/\s+/);
                let chord1ForSpaceSplit = null;
                let chord2ForSpaceSplit = null;
                let identifiedAsSpaceSplit = false;

                if (spaceParts.length === 2) {
                    if (parseChord(spaceParts[0]) && parseChord(spaceParts[1])) {
                        chord1ForSpaceSplit = spaceParts[0];
                        chord2ForSpaceSplit = spaceParts[1];
                        identifiedAsSpaceSplit = true;
                    }
                } else if (spaceParts.length === 4) {
                    const firstCandidate = `${spaceParts[0]} ${spaceParts[1]}`;
                    const secondCandidate = `${spaceParts[2]} ${spaceParts[3]}`;
                    if (parseChord(firstCandidate) && parseChord(secondCandidate)) {
                        chord1ForSpaceSplit = firstCandidate;
                        chord2ForSpaceSplit = secondCandidate;
                        identifiedAsSpaceSplit = true;
                    }
                }

                if (identifiedAsSpaceSplit) {
                    originalPartsToProcess.push({
                        parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(chord1ForSpaceSplit, originalSongDefaultKey)
                    });
                    originalPartsToProcess.push({
                        parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(chord2ForSpaceSplit, originalSongDefaultKey)
                    });
                } else {
                    const potentialSlashSplit = effectiveChordString.split('/');
                    const rawIsComplexSingleChord = parseChord(rawChordStringFromDefinition.trim());
                    if (potentialSlashSplit.length === 2 &&
                        !rawIsComplexSingleChord &&
                        parseChord(potentialSlashSplit[0].trim()) && parseChord(potentialSlashSplit[1].trim())) {
                        originalPartsToProcess.push({
                            parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(potentialSlashSplit[0].trim(), originalSongDefaultKey)
                        });
                        originalPartsToProcess.push({
                            parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(potentialSlashSplit[1].trim(), originalSongDefaultKey)
                        });
                    } else {
                        originalPartsToProcess.push({
                            parsedInOriginalContext: parseRomanNumeralToAbsoluteChord(effectiveChordString, originalSongDefaultKey)
                        });
                    }
                }
            }

            measurePartsUI.forEach((partElement, partIndex) => {
                if (partIndex < originalPartsToProcess.length) {
                    const originalPart = originalPartsToProcess[partIndex];
                    const transposedChord = transposeChordData(originalPart.parsedInOriginalContext, originalSongDefaultKeyRoot, newTargetGlobalKeyRoot);

                    partElement.querySelector('.root-note').value = transposedChord.root;
                    partElement.querySelector('.chord-quality').value = transposedChord.quality; 

                    let finalScaleRoot, finalScaleType;
                    if (originalPart.originalScaleRoot && originalPart.originalScaleType) {
                        const originalScaleRootData = { root: originalPart.originalScaleRoot, quality: 'maj' };
                        const transposedScaleRootInfo = transposeChordData(originalScaleRootData, originalSongDefaultKeyRoot, newTargetGlobalKeyRoot);
                        finalScaleRoot = transposedScaleRootInfo.root;
                        finalScaleType = originalPart.originalScaleType;
                    } else {
                        finalScaleRoot = transposedChord.root;
                        finalScaleType = suggestScaleForQuality(transposedChord.quality);
                    }
                    partElement.querySelector('.second-key').value = finalScaleRoot;
                    partElement.querySelector('.scale-select').value = finalScaleType;
                } else if (originalPartsToProcess.length > 0) { // Fallback if UI has more parts than definition (e.g. user split it)
                    const lastOriginalPart = originalPartsToProcess[originalPartsToProcess.length - 1];
                    const transposedChord = transposeChordData(lastOriginalPart.parsedInOriginalContext, originalSongDefaultKeyRoot, newTargetGlobalKeyRoot);
                     partElement.querySelector('.root-note').value = transposedChord.root;
                    partElement.querySelector('.chord-quality').value = transposedChord.quality;
                    partElement.querySelector('.second-key').value = transposedChord.root;
                    partElement.querySelector('.scale-select').value = suggestScaleForQuality(transposedChord.quality);
                }
            });
        } else { // Measure was added by user, not part of original loaded progression
            const previousGlobalKey = measureElement.dataset.lastKeyContext || originalSongDefaultKey; 
            const previousGlobalKeyRoot = standardizeNoteName(previousGlobalKey.replace('m', ''));
            
            measureElement.querySelectorAll('.measure-part').forEach(partElement => {
                const currentRoot = partElement.querySelector('.root-note').value;
                const currentQuality = partElement.querySelector('.chord-quality').value;
                const currentScaleRoot = partElement.querySelector('.second-key').value;
                const currentScaleType = partElement.querySelector('.scale-select').value;

                const chordToTranspose = { root: currentRoot, quality: currentQuality };
                const transposedChord = transposeChordData(chordToTranspose, previousGlobalKeyRoot, newTargetGlobalKeyRoot);
                
                partElement.querySelector('.root-note').value = transposedChord.root;
                partElement.querySelector('.chord-quality').value = transposedChord.quality;

                const scaleRootToTranspose = {root: currentScaleRoot, quality: 'maj'};
                const transposedScale = transposeChordData(scaleRootToTranspose, previousGlobalKeyRoot, newTargetGlobalKeyRoot);
                partElement.querySelector('.second-key').value = transposedScale.root;
                partElement.querySelector('.scale-select').value = currentScaleType; 
            });
            measureElement.dataset.lastKeyContext = newKey; 
        }
    });

    addFirstChordListener(); 
    updateNextChordDisplay();
    log(`Progression '${currentProgressionName}' re-keyed to: ${newKey}`);
}

function createMeasurePartHTML(data, partIndex = 0) {
    return `
        <div class="measure-part" data-part-index="${partIndex}">
            <div class="chord-controls">
                <select class="root-note">${createKeyOptions(data.root)}</select>
                <select class="chord-quality">${createQualityOptions(data.quality)}</select>
            </div>
            <div class="scale-controls">
                <select class="second-key">${createKeyOptions(data.scaleRoot)}</select>
                <select class="scale-select">${createScaleOptions(data.scaleType)}</select>
            </div>
        </div>`;
}

function addMeasure(root = 'C', quality = 'maj7', scaleRoot = 'C', scaleType = 'major', 
                    isInitiallySplit = false, secondPartData = null) {
    const measuresContainer = UI.elements.measures;
    const newMeasureIndex = measuresContainer.children.length;

    const measureDiv = document.createElement('div');
    measureDiv.className = 'measure';
    measureDiv.dataset.measureIndex = newMeasureIndex;
    measureDiv.dataset.isSplit = isInitiallySplit ? 'true' : 'false';
    if (isInitiallySplit) measureDiv.classList.add('split-active');

    measureDiv.dataset.lastKeyContext = UI.elements.keySelect.value;

    let measureHTML = `<div class="measure-header"><span class="measure-number">${newMeasureIndex + 1}</span></div>`;
    measureHTML += createMeasurePartHTML({ root, quality, scaleRoot, scaleType }, 0);
    if (isInitiallySplit) {
        const spData = secondPartData || { root, quality, scaleRoot, scaleType }; // Use provided or duplicate first
        measureHTML += createMeasurePartHTML(spData, 1);
    }
    measureHTML += `<div class="measure-footer"><button class="split-measure-button">${isInitiallySplit ? 'Unsplit' : 'Split'}</button></div>`;
    measureDiv.innerHTML = measureHTML;
    measuresContainer.appendChild(measureDiv);

    measureDiv.querySelectorAll('select').forEach(selectElement => {
        selectElement.addEventListener('change', (event) => {
            handleMeasureControlChange(event.target.closest('.measure-part'), event.target);
        });
    });
    
    measureDiv.querySelector('.measure-header').addEventListener('click', (event) => {
        if (event.target.tagName !== 'SELECT' && event.target.tagName !== 'BUTTON') {
            toggleMeasureLoopSelection(newMeasureIndex);
        }
    });
    
    const splitButton = measureDiv.querySelector('.split-measure-button');
    const is44Time = parseInt(UI.elements.timeSignature.value) === 4;
    splitButton.disabled = !is44Time;
    splitButton.title = is44Time ? "" : "Splitting measures only available in 4/4 time.";
    splitButton.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleSplitMeasure(measureDiv);
    });

    updateMeasureNumbers(); 
    if (newMeasureIndex === 0) addFirstChordListener();
    updateNextChordDisplay();
}

function toggleSplitMeasure(measureDiv) {
    if (parseInt(UI.elements.timeSignature.value) !== 4) {
        alert("Splitting measures is only available in 4/4 time.");
        return;
    }
    const isSplit = measureDiv.dataset.isSplit === 'true';
    const splitButton = measureDiv.querySelector('.split-measure-button');
    const firstPart = measureDiv.querySelector('.measure-part[data-part-index="0"]');

    if (isSplit) { 
        measureDiv.querySelector('.measure-part[data-part-index="1"]')?.remove();
        measureDiv.dataset.isSplit = 'false';
        measureDiv.classList.remove('split-active');
        splitButton.textContent = 'Split';
    } else { 
        if (!firstPart) return;
        const firstPartData = {
            root: firstPart.querySelector('.root-note').value,
            quality: firstPart.querySelector('.chord-quality').value,
            scaleRoot: firstPart.querySelector('.second-key').value,
            scaleType: firstPart.querySelector('.scale-select').value
        };
        measureDiv.querySelector('.measure-footer').insertAdjacentHTML('beforebegin', createMeasurePartHTML(firstPartData, 1));
        const newSecondPart = measureDiv.querySelector('.measure-part[data-part-index="1"]');
        newSecondPart.querySelectorAll('select').forEach(select => {
            select.addEventListener('change', (e) => handleMeasureControlChange(e.target.closest('.measure-part'), e.target));
        });
        measureDiv.dataset.isSplit = 'true';
        measureDiv.classList.add('split-active');
        splitButton.textContent = 'Unsplit';
    }
    updateNextChordDisplay();
    const currentActiveMeasure = UI.elements.measures.querySelector('.measure.active');
    if (currentActiveMeasure === measureDiv) {
        const activePart = measureDiv.querySelector('.measure-part.part-active') || firstPart;
        if (activePart) handleMeasureControlChange(activePart, activePart.querySelector('select'));
    }
}

function removeMeasure() {
    const measuresChildren = UI.elements.measures.children;
    if (measuresChildren.length > 0) {
        const removedMeasureIndex = measuresChildren.length - 1;
        if (AppState.loopStartMeasure === removedMeasureIndex || AppState.loopEndMeasure === removedMeasureIndex) {
            resetLoop(); 
        }
        if (AppState.loopEndMeasure >= measuresChildren.length -1) {
            AppState.loopEndMeasure = Math.max(-1, measuresChildren.length - 2);
            if (AppState.loopStartMeasure > AppState.loopEndMeasure) AppState.loopStartMeasure = AppState.loopEndMeasure;
            if (AppState.loopStartMeasure === -1 && AppState.loopEndMeasure > -1) AppState.loopStartMeasure = AppState.loopEndMeasure; 
             if (AppState.loopStartMeasure === -1 && AppState.loopEndMeasure === -1 && AppState.loopingActive) toggleLoopingMode(); 
        }

        measuresChildren[measuresChildren.length - 1].remove();
        updateMeasureNumbers();
        if (measuresChildren.length > 0) {
            addFirstChordListener();
        } else {
            if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "Select a progression and key.";
            resetLoop(); 
        }
        updateNextChordDisplay();
        log('Removed last measure');
    }
}

function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        measure.querySelector('.measure-number').textContent = index + 1;
        measure.dataset.measureIndex = index;
    });
}

function handleMeasureControlChange(measurePartDiv, changedElement) {
    const rootSelect = measurePartDiv.querySelector('.root-note');
    const qualitySelect = measurePartDiv.querySelector('.chord-quality');
    const scaleKeySelect = measurePartDiv.querySelector('.second-key');
    const scaleTypeSelect = measurePartDiv.querySelector('.scale-select');

    if (changedElement.classList.contains('root-note') || changedElement.classList.contains('chord-quality')) {
        scaleKeySelect.value = rootSelect.value;    
        scaleTypeSelect.value = suggestScaleForQuality(qualitySelect.value); 
    }

    updateFretboardNotes(
        UI.elements.chordFretboard,      
        scaleKeySelect.value,     
        scaleTypeSelect.value,    
        TUNINGS[UI.elements.chordTuning.value],
        measurePartDiv 
    );

    if (AppState.guideTonesActive) highlightGuideTones(measurePartDiv); 
    updateNextChordDisplay(); 
}

function saveCurrentProgression() {
    const measures = Array.from(UI.elements.measures.children);
    if (measures.length === 0) {
        alert("No progression to save!");
        return;
    }
    let suggestedName = "My Custom Song";
    if (currentProgressionName && (progressions[currentProgressionName] || JSON.parse(localStorage.getItem('userBebopProgressions') || '{}')[currentProgressionName])) {
        const currentSongData = progressions[currentProgressionName] || JSON.parse(localStorage.getItem('userBebopProgressions') || '{}')[currentProgressionName];
        suggestedName = currentSongData.displayName || currentProgressionName.replace(/_/g, ' ');
    }
    let progressionNameInput = prompt("Enter a name for this progression:", suggestedName);
    if (!progressionNameInput || progressionNameInput.trim() === "") {
        alert("Save cancelled or empty name provided.");
        return;
    }
    progressionNameInput = progressionNameInput.trim();
    const keyForSaving = UI.elements.keySelect.value;
    const savedProgressionData = {
        progression: [], parts: [], splitStatus: [],
        defaultKey: keyForSaving,
        description: `User saved song - ${new Date().toLocaleDateString()}`,
        displayName: progressionNameInput
    };
    measures.forEach(measureEl => {
        const isSplit = measureEl.dataset.isSplit === 'true';
        savedProgressionData.splitStatus.push(isSplit);
        const measurePartsDataForStorage = [];
        let measureCombinedString = "";
        measureEl.querySelectorAll('.measure-part').forEach((partEl, partIdx) => {
            const root = partEl.querySelector('.root-note').value;
            const qualityValue = partEl.querySelector('.chord-quality').value;
            const scaleRoot = partEl.querySelector('.second-key').value;
            const scaleType = partEl.querySelector('.scale-select').value;
            const qualityOption = partEl.querySelector(`.chord-quality option[value="${qualityValue}"]`);
            const qualityDisplayText = qualityOption ? qualityOption.textContent : qualityValue;
            const absoluteChordStringForStorage = `${root}${qualityDisplayText}`;
            measurePartsDataForStorage.push({
                root: root, quality: qualityValue,
                originalRoman: absoluteChordStringForStorage, // Store as absolute for easier re-keying if needed
                scaleRoot: scaleRoot, scaleType: scaleType
            });
            if (partIdx > 0) measureCombinedString += " / "; // Using slash for consistency in stored string
            measureCombinedString += absoluteChordStringForStorage;
        });
        savedProgressionData.parts.push(measurePartsDataForStorage);
        savedProgressionData.progression.push(measureCombinedString);
    });
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    userSongs[progressionNameInput] = savedProgressionData;
    localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));
    populateUserSongsDropdown();
    UI.elements.userProgressionSelect.value = progressionNameInput;
    currentProgressionName = progressionNameInput; // Update current loaded song to the one just saved
    currentFunctionalProgression = savedProgressionData.progression; // Update functional prog
    alert(`Progression "${progressionNameInput}" saved!`);
    log(`User progression saved: ${progressionNameInput} with defaultKey: ${keyForSaving}`);
}

function isUserSongCurrentlyLoaded() {
    if (!currentProgressionName) return false;
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    return userSongs.hasOwnProperty(currentProgressionName);
}

function populateUserSongsDropdown() {
    const selectElement = UI.elements.userProgressionSelect;
    if (!selectElement) return;
    selectElement.innerHTML = '<option value="">-- Select a saved song --</option>';
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    Object.keys(userSongs).sort().forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = userSongs[name].displayName || name;
        selectElement.appendChild(option);
    });
}

function deleteSelectedUserSong() {
    const selectedSongName = UI.elements.userProgressionSelect.value;
    if (!selectedSongName) { alert("Please select a saved song to delete."); return; }
    if (confirm(`Are you sure you want to delete "${selectedSongName}"? This cannot be undone.`)) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        delete userSongs[selectedSongName];
        localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));
        populateUserSongsDropdown();
        if (currentProgressionName === selectedSongName) {
            UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
            if(UI.elements.currentSongTitleFretboard) UI.elements.currentSongTitleFretboard.textContent = "";
            if(UI.elements.currentSongDescriptionFretboard) UI.elements.currentSongDescriptionFretboard.textContent = "";
            currentProgressionName = ""; currentFunctionalProgression = [];
            resetLoop();
        }
        alert(`Song "${selectedSongName}" deleted.`);
        log(`User song deleted: ${selectedSongName}`);
    }
}

function toggleMeasureLoopSelection(measureIndex) {
    if (!AppState.loopingActive) {
        toggleLoopingMode(); // This will activate looping and optionally alert the user
        if (!AppState.loopingActive) return; // If user somehow cancelled or it failed to activate
    }

    const measureElement = UI.elements.measures.children[measureIndex];
    if (!measureElement) return;

    measureElement.classList.toggle('loop-selected');

    // Recalculate loop range based on all currently selected measures
    const selectedIndices = Array.from(UI.elements.measures.children)
        .map((m, i) => m.classList.contains('loop-selected') ? i : -1)
        .filter(i => i !== -1).sort((a, b) => a - b);

    if (selectedIndices.length > 0) {
        AppState.loopStartMeasure = selectedIndices[0];
        AppState.loopEndMeasure = selectedIndices[selectedIndices.length - 1];
        // Ensure all measures between start and end are also visually selected
        Array.from(UI.elements.measures.children).forEach((m, i) => {
            m.classList.toggle('loop-selected', i >= AppState.loopStartMeasure && i <= AppState.loopEndMeasure);
        });
    } else {
        resetLoop(); // If no measures are selected, clear the loop
    }
    log(`Loop range: ${AppState.loopStartMeasure} to ${AppState.loopEndMeasure}`);
}

function resetLoop() {
    AppState.loopStartMeasure = -1; AppState.loopEndMeasure = -1;
    Array.from(UI.elements.measures.children).forEach(m => m.classList.remove('loop-selected'));
    log("Loop selection cleared.");
}

function toggleLoopingMode() {
    AppState.loopingActive = !AppState.loopingActive;
    UI.elements.loopSelectedToggle.textContent = AppState.loopingActive ? "Looping ON" : "Looping Off";
    UI.elements.loopSelectedToggle.classList.toggle('active', AppState.loopingActive);

    if (!AppState.loopingActive) {
        resetLoop();
    } else {
        alert("Looping ON. Click on measures to define the loop range (start and end). Click again to deselect.");
        // Optionally, auto-select the first measure if none are selected
        if (AppState.loopStartMeasure === -1 && UI.elements.measures.children.length > 0) {
           // toggleMeasureLoopSelection(0); // This could be a bit aggressive, user might prefer explicit selection
        }
    }
    log(`Looping mode: ${AppState.loopingActive ? 'ON' : 'OFF'}`);
}

function toggleGuideTones() {
    AppState.guideTonesActive = !AppState.guideTonesActive;
    UI.elements.guideTonesToggle.textContent = AppState.guideTonesActive ? "Guide Tones ON" : "Guide Tones Off";
    UI.elements.guideTonesToggle.classList.toggle('active', AppState.guideTonesActive);

    // Determine which measure part is currently "active" visually or contextually
    const currentMeasureEl = UI.elements.measures.children[AppState.currentMeasure];
    const activePart = currentMeasureEl?.querySelector('.measure-part.part-active') || currentMeasureEl?.querySelector('.measure-part');
    
    if (AppState.guideTonesActive) {
        highlightGuideTones(activePart);
    } else {
        clearGuideToneHighlights();
    }
    log(`Guide tones: ${AppState.guideTonesActive ? 'ON' : 'OFF'}`);
}

function highlightGuideTones(activeMeasurePartContext = null) {
    clearGuideToneHighlights();
    if (!AppState.guideTonesActive) return;

    let chordRootStr, chordQualityStr;

    if (activeMeasurePartContext) {
        chordRootStr = activeMeasurePartContext.querySelector('.root-note')?.value;
        chordQualityStr = activeMeasurePartContext.querySelector('.chord-quality')?.value;
    } else {
        // Fallback: if no specific part is active, try the first part of the first measure
        const firstMeasurePart = UI.elements.measures.children[0]?.querySelector('.measure-part');
        if (!firstMeasurePart) return; // No measures or parts to work with
        chordRootStr = firstMeasurePart.querySelector('.root-note')?.value;
        chordQualityStr = firstMeasurePart.querySelector('.chord-quality')?.value;
    }

    if (!chordRootStr || !chordQualityStr) return; // Not enough info

    const chordRootNote = standardizeNoteName(chordRootStr);
    const chordIntervals = CHORD_INTERVALS[chordQualityStr];
    if (!chordIntervals) return; // Unknown quality

    const rootNoteIndex = NOTES.indexOf(chordRootNote);
    if (rootNoteIndex === -1) return; // Invalid root

    const guideToneNotesSet = new Set();

    // Determine 3rd (or equivalent like b3)
    if (chordIntervals.includes(3)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 3) % 12]); // Minor 3rd
    else if (chordIntervals.includes(4)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 4) % 12]); // Major 3rd

    // Determine 7th (or 6th for 6th chords)
    if (chordQualityStr.includes('6') && !chordQualityStr.includes('7')) { // 6th chords (maj6, min6)
        if (chordIntervals.includes(9)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 9) % 12]); // Major 6th
    } else { // 7th chords
        if (chordIntervals.includes(11)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 11) % 12]); // Major 7th
        else if (chordIntervals.includes(10)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 10) % 12]); // Minor 7th (dominant or minor)
        else if (chordIntervals.includes(9) && chordQualityStr === 'dim7') { // Diminished 7th (bb7)
             guideToneNotesSet.add(NOTES[(rootNoteIndex + 9) % 12]);
        }
    }
    
    UI.elements.chordFretboard.querySelectorAll('.note').forEach(noteElement => {
        const noteName = noteElement.textContent;
        if (noteName === chordRootNote) {
            noteElement.classList.add('root-highlight-for-guides');
        } else if (guideToneNotesSet.has(noteName)) {
            noteElement.classList.add('guide-tone-highlight');
        }
    });
}

function clearGuideToneHighlights() {
    UI.elements.chordFretboard.querySelectorAll('.note').forEach(n => {
        n.classList.remove('guide-tone-highlight', 'root-highlight-for-guides');
        // Reset transform if it was scaled due to highlight
        if (n.style.transform.includes('scale(0.95)')) {
            n.style.transform = 'translate(-50%, -50%) scale(1)';
        }
    });
}

function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) { console.error("FretFlow grid not found."); return; }
    fretboardsGrid.innerHTML = ''; 
    for (let i = 0; i < 4; i++) {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'fretboard-section';
        sectionDiv.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group"><label for="ff-key-${i}">Key:</label><select id="ff-key-${i}" class="fretflow-key">${createKeyOptions()}</select></div>
                <div class="control-group"><label for="ff-scale-${i}">Scale:</label><select id="ff-scale-${i}" class="fretflow-scale">${createScaleOptions()}</select></div>
                <div class="control-group"><label for="ff-tuning-${i}">Tuning:</label><select id="ff-tuning-${i}" class="tuning-select">
                    <option value="standard">Std</option><option value="dropD">DropD</option><option value="openG">OpG</option>
                    <option value="DADGAD">DADGAD</option><option value="openE">OpE</option></select></div>
            </div>
            <div class="scale-display" id="ff-scale-display-${i}"></div>
            <div id="ff-fretboard-${i}" class="fretboard"></div>`;
        fretboardsGrid.appendChild(sectionDiv);
        const fretboardEl = sectionDiv.querySelector(`#ff-fretboard-${i}`);
        const keySelect = sectionDiv.querySelector(`#ff-key-${i}`);
        const scaleSelect = sectionDiv.querySelector(`#ff-scale-${i}`);
        const tuningSelect = sectionDiv.querySelector(`#ff-tuning-${i}`);
        const scaleDisplay = sectionDiv.querySelector(`#ff-scale-display-${i}`);
        const updateDisplay = () => {
            const tuningArr = TUNINGS[tuningSelect.value] || TUNINGS.standard;
            scaleDisplay.textContent = `${keySelect.value} ${scaleSelect.options[scaleSelect.selectedIndex].text}`;
            createFretboard(fretboardEl, tuningArr);
            updateFretboardNotes(fretboardEl, keySelect.value, scaleSelect.value, tuningArr);
        };
        [keySelect, scaleSelect, tuningSelect].forEach(el => el.addEventListener('change', updateDisplay));
        updateDisplay(); // Initial call
    }
    log("FretFlow initialized.");
}

function addFirstChordListener() {
    const firstMeasurePart = UI.elements.measures.firstElementChild?.querySelector('.measure-part[data-part-index="0"]');
    if (firstMeasurePart) {
        const scaleRootSelect = firstMeasurePart.querySelector('.scale-controls .second-key');
        const scaleTypeSelect = firstMeasurePart.querySelector('.scale-controls .scale-select');
        const updateFunc = () => {
            if (scaleRootSelect && scaleTypeSelect && UI.elements.chordTuning) {
                updateFretboardNotes(UI.elements.chordFretboard, scaleRootSelect.value, scaleTypeSelect.value, TUNINGS[UI.elements.chordTuning.value], firstMeasurePart);
            }
        };
        // Call immediately to set initial fretboard based on the first chord
        updateFunc();
    } else { // No measures yet, default display
        updateFretboardNotes(UI.elements.chordFretboard, "C", "major", TUNINGS[UI.elements.chordTuning.value]);
        if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "C Major (Default)";
    }
}

function safeAddEventListener(element, event, handler) {
    if (element && typeof element.addEventListener === 'function') {
        element.addEventListener(event, handler);
        return true;
    }
    // console.warn(`safeAddEventListener: Element for event '${event}' is invalid or has no addEventListener method. Element:`, element);
    return false;
}
        
function setupEventListeners() {
    try {
        // Check for critical elements that must exist for core functionality
        const requiredElements = [
            'startStopButton', 'tempo', 'tempoDisplay', 'timeSignature',
            'progressionSelect', 'keySelect', 'darkModeToggle', 'chordsEnabled',
            'soundType', 'rhythmicStyleSelect' // Added this to the check
        ];
        
        const missingElements = requiredElements.filter(id => {
            const element = UI.elements[id];
            return !element;
        });

        if (missingElements.length > 0) {
            const specificErrorMsg = `[CRITICAL] UI elements missing: ${missingElements.join(', ')}. Check HTML IDs and UI.init(). Execution of setupEventListeners will halt.`;
            console.error(specificErrorMsg);
            alert(specificErrorMsg); // User feedback
            updateLoadingStatus(specificErrorMsg, true); // Visual feedback
            return; // Halt further event listener setup
        }


        // --- Audio Initialization on User Interaction ---
        document.body.addEventListener('click', ensureAudioInitializedUserInteraction, { once: true });

        // --- Metronome Controls ---
        UI.elements.startStopButton.addEventListener('click', () => AppState.isPlaying ? stopPlayback() : startPlayback());
        
        if (UI.elements.drumSetToggleBtn) {
            UI.elements.drumSetToggleBtn.addEventListener('click', () => {
                currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
                UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
                log(`Drum set: ${drumSoundSets[currentDrumSetIndex].name}`);
            });
        }

        if (UI.elements.soundType) {
            UI.elements.soundType.addEventListener('change', (e) => {
                onMetronomeInstrumentChange(e.target.value);
                updateRhythmicStyleUIVisibility();
                createBeats(); // Recreate beats based on new sound type (especially for drums vs click/woodblock)
            });
        }
        
        // --- Dark Mode ---
        let currentDarkModeIndex = 0;
        const darkModeClasses = ['', 'dark-mode', 'dark-mode-2', 'dark-mode-3'];
        const activeToggleClasses = ['', 'active', 'active-2', 'active-3'];
        UI.elements.darkModeToggle.addEventListener('click', () => {
            currentDarkModeIndex = (currentDarkModeIndex + 1) % darkModeClasses.length;
            darkModeClasses.forEach(cls => { if (cls) document.body.classList.remove(cls); });
            activeToggleClasses.forEach(cls => { if (cls) UI.elements.darkModeToggle.classList.remove(cls); });
            if (currentDarkModeIndex > 0) {
                document.body.classList.add(darkModeClasses[currentDarkModeIndex]);
                UI.elements.darkModeToggle.classList.add(activeToggleClasses[currentDarkModeIndex]);
            }
            log(`Color mode: ${darkModeClasses[currentDarkModeIndex] || 'Light Mode'}`);
        });

        // --- Chords Enabled Toggle ---
        UI.elements.chordsEnabled.addEventListener('click', () => {
            const isActive = UI.elements.chordsEnabled.classList.toggle('active');
            UI.elements.chordsEnabled.textContent = isActive ? 'Chords Enabled' : 'Chords Disabled';
            log(`Chords ${isActive ? 'enabled' : 'disabled'}`);
        });

        // --- Tempo Controls ---
        UI.elements.tempo.addEventListener('input', () => {
            AppState.tempo = parseInt(UI.elements.tempo.value);
            UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
        });

        UI.elements.tapTempo.addEventListener('click', () => {
            const now = Date.now();
            AppState.tapTempoTimestamps.push(now);
            if (AppState.tapTempoTimestamps.length > 4) AppState.tapTempoTimestamps.shift(); // Keep last 4 taps
            if (AppState.tapTempoTimestamps.length > 1) {
                let totalInterval = 0;
                for (let i = 1; i < AppState.tapTempoTimestamps.length; i++) {
                    totalInterval += AppState.tapTempoTimestamps[i] - AppState.tapTempoTimestamps[i-1];
                }
                const avgInterval = totalInterval / (AppState.tapTempoTimestamps.length - 1);
                if (avgInterval > 0 && avgInterval < 3000) { // Avoid extreme values
                    AppState.tempo = Math.max(40, Math.min(220, Math.round(60000 / avgInterval)));
                    UI.elements.tempo.value = AppState.tempo;
                    UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                    if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
                }
            }
            // Reset tap array if too much time passes between taps
            setTimeout(() => { 
                if (AppState.tapTempoTimestamps.length > 0 && (Date.now() - AppState.tapTempoTimestamps[AppState.tapTempoTimestamps.length - 1] > 3000)) {
                    AppState.tapTempoTimestamps = []; 
                }
            }, 3100);
        });

        // --- Time Signature and Rhythmic Style ---
        UI.elements.timeSignature.addEventListener('change', () => {
            createBeats(); // Recreate beat buttons for the new time signature
            const is44 = parseInt(UI.elements.timeSignature.value) === 4;
            // Enable/disable split measure buttons based on time signature
            document.querySelectorAll('.measure .split-measure-button').forEach(btn => {
                btn.disabled = !is44;
                btn.title = is44 ? "" : "Splitting measures only available in 4/4 time.";
                // If not 4/4 and measure was split, unsplit it
                if (!is44 && btn.closest('.measure').dataset.isSplit === 'true') {
                    toggleSplitMeasure(btn.closest('.measure')); 
                }
            });
            updateRhythmicStyleUIVisibility();
            if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
        });

        const rhythmicSelectElement = UI.elements.rhythmicStyleSelect; 
        if (rhythmicSelectElement && typeof rhythmicSelectElement.addEventListener === 'function') {
            rhythmicSelectElement.addEventListener('change', (e) => {
                AppState.currentRhythmicStyle = e.target.value;
                AppState.currentStylePatternBeat = 0; // Reset pattern index
                AppState.currentStyleBar = 0; // Reset bar for multi-bar patterns
                createBeats(); // Recreate beats with the new style
                log(`Rhythmic style changed to: ${AppState.currentRhythmicStyle}`);
            });
        }

        // --- Reverb ---
        if (UI.elements.reverbDial) {
            UI.elements.reverbDial.addEventListener('input', (e) => {
                AudioContextManager.reverbAmount = parseInt(e.target.value, 10) / 100;
                UI.elements.reverbDialValue.textContent = e.target.value;
                log(`Reverb: ${AudioContextManager.reverbAmount}`);
            });
        }

        // --- Progression Loading & Key Changes ---
        UI.elements.progressionSelect.addEventListener('change', (e) => {
            loadProgression(e.target.value, null, false);
            if (UI.elements.userProgressionSelect) UI.elements.userProgressionSelect.value = ""; // Clear user song selection
        });

        if (UI.elements.userProgressionSelect) {
            UI.elements.userProgressionSelect.addEventListener('change', (e) => {
                if (e.target.value) { // If a user song is selected
                    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
                    const selectedSongData = userSongs[e.target.value];
                    loadProgression(e.target.value, selectedSongData?.defaultKey || UI.elements.keySelect.value, true);
                    if (UI.elements.progressionSelect) UI.elements.progressionSelect.value = ""; // Clear standard progression selection
                }
            });
        }

        UI.elements.keySelect.addEventListener('change', (e) => updateProgressionKey(e.target.value));
        
        // --- Fretboard Tuning ---
        if (UI.elements.chordTuning) {
            UI.elements.chordTuning.addEventListener('change', () => { 
                addFirstChordListener(); // Re-render main fretboard with new tuning
                initializeFretFlow(); // Re-render FretFlow fretboards
            });
        }

        // --- User Progression Management ---
        if (UI.elements.saveProgressionButton) {
            UI.elements.saveProgressionButton.addEventListener('click', saveCurrentProgression);
        }

        if (UI.elements.deleteUserSongButton) {
            UI.elements.deleteUserSongButton.addEventListener('click', deleteSelectedUserSong);
        }

        // --- Guide Tones & Looping Toggles ---
        if (UI.elements.guideTonesToggle) {
            UI.elements.guideTonesToggle.addEventListener('click', toggleGuideTones);
        }

        if (UI.elements.loopSelectedToggle) {
            UI.elements.loopSelectedToggle.addEventListener('click', toggleLoopingMode);
        }

        // --- Collapsible Sections ---
        document.querySelectorAll('.collapsible-toggle').forEach(button => {
            button.addEventListener('click', () => {
                const contentId = button.getAttribute('aria-controls');
                const content = document.getElementById(contentId);
                if (!content) return;
                
                const isExpanded = button.getAttribute('aria-expanded') === 'true' || false;
                button.setAttribute('aria-expanded', !isExpanded);
                content.style.display = isExpanded ? 'none' : (contentId === 'metronome-volume-controls-stack' ? 'flex' : 'block'); 
                button.querySelector('.toggle-icon').textContent = isExpanded ? '+' : '-';
                log(`Collapsible ${contentId} ${isExpanded ? 'collapsed' : 'expanded'}`);
            });
        });

        // --- Keyboard Shortcuts ---
        document.addEventListener('keydown', (event) => {
            const targetTagName = event.target.tagName.toLowerCase();
            // Ignore if typing in an input/select/textarea
            if (['input', 'select', 'textarea'].includes(targetTagName)) return;

            let tempoChanged = false;
            switch (event.key) {
                case ' ': // Spacebar for Start/Stop
                    event.preventDefault();
                    UI.elements.startStopButton.click();
                    break;
                case 'ArrowUp': // Up arrow for tempo up
                    event.preventDefault();
                    UI.elements.tempo.value = AppState.tempo = Math.min(220, parseInt(UI.elements.tempo.value) + 1);
                    tempoChanged = true; break;
                case 'ArrowDown': // Down arrow for tempo down
                    event.preventDefault();
                    UI.elements.tempo.value = AppState.tempo = Math.max(40, parseInt(UI.elements.tempo.value) - 1);
                    tempoChanged = true; break;
            }
            if (tempoChanged) {
                UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                if (AppState.isPlaying) { stopPlayback(); startPlayback(); } // Restart playback with new tempo
            }
        });
        log("Event listeners set up successfully.");
    } catch (error) {
        console.error("Error during setupEventListeners execution (outer catch):", error);
        if (error.message && error.message.startsWith("[CRITICAL]")) {
            // Already handled by alert and updateLoadingStatus in the element check
        } else {
            updateLoadingStatus("Error setting up controls. Some features may not work. Check console.", true);
        }
    }
}


// ==================================
// === INITIALIZATION =============
// ==================================
async function initializeApp() {
    UI.init(); // Cache DOM elements first
    
    // Initial UI setup based on default values
    createBeats();
    const initialTuning = TUNINGS[UI.elements.chordTuning?.value || 'standard'] || TUNINGS.standard;
    createFretboard(UI.elements.chordFretboard, initialTuning);
    onMetronomeInstrumentChange(UI.elements.soundType?.value || 'click'); // Setup drum UI if needed
    populateUserSongsDropdown(); // Load any saved user songs

    // Determine initial progression to load
    let initialProgressionName = "I V7"; // Default fallback
    if (UI.elements.progressionSelect && UI.elements.progressionSelect.options.length > 0) {
        const firstOptgroupOption = UI.elements.progressionSelect.querySelector('optgroup > option');
        if (firstOptgroupOption) {
            initialProgressionName = firstOptgroupOption.value;
        } else if (UI.elements.progressionSelect.options[0]) { // Fallback if no optgroups
            initialProgressionName = UI.elements.progressionSelect.options[0].value;
        }
    }
    
    const initialProgData = progressions[initialProgressionName] || {};
    const initialKey = UI.elements.keySelect?.value || initialProgData.defaultKey || "C";
    loadProgression(initialProgressionName, initialKey, false); // Load the initial progression

    initializeFretFlow(); // Setup the 4 FretFlow fretboards
    setupEventListeners(); // Set up all event listeners

    // Attempt to initialize audio
    try {
        await AudioContextManager.initialize();
    } catch (e) {
        // If audio init fails, show message and allow user to retry with a click
        updateLoadingStatus("Audio initialization failed. Click screen to retry.", true);
        document.body.addEventListener('click', async function retryAudioInit() {
            document.body.removeEventListener('click', retryAudioInit); // Remove self
            updateLoadingStatus("Retrying audio initialization...", true);
            try {
                await AudioContextManager.initialize();
                updateLoadingStatus("Audio initialized!", true);
                setTimeout(() => updateLoadingStatus("", false), 1500);
            } catch (err) {
                updateLoadingStatus("Audio retry failed. Please refresh or check browser settings.", true);
                console.error("Audio retry failed:", err);
            }
        }, { once: true });
    }

    if (AppState.audioInitialized) {
        updateLoadingStatus("Application initialized.", true);
        setTimeout(() => updateLoadingStatus("", false), 1500);
    }
    log("Application initialized.");
}

// Start the application once the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Application initialization failed:", error);
        updateLoadingStatus("Fatal Error: App could not initialize. Check console.", true);
    });
});

    </script>
</body>
</html>

