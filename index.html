<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png"> <!-- Ensure jazzmaster.png exists -->
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
    font-family: 'Lato', sans-serif;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #1f618d; /* Default light mode background */
    color: #333; /* Default light mode text */
    transition: background-color 0.3s ease, color 0.3s ease;
    }
    .app-section {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    .fretboards-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-bottom: 30px;
    }
    .fretboard-container {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    .scale-display {
    font-size: 1.2em;
    font-weight: bold;
    text-align: center;
    margin-bottom: 15px;
    color: #333; /* Default light mode text */
    transition: color 0.3s ease;
    }
    .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
    }

    .controls-container {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    }

    .control-group label {
    font-weight: bold;
    }

    .control-group select {
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #ccc;
    background-color: white; /* Default light mode */
    color: #333; /* Default light mode */
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    .fretboard {
    position: relative;
    height: 200px;
    background-color: #FFCF79; /* Light wood color */
    border-radius: 5px;
    margin-bottom: 30px;
    border: 2px solid #4B1C2E; /* Dark wood border */
    overflow: visible;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    .fret-line {
    position: absolute;
    top: 0;
    height: 100%;
    width: 2px;
    background: #c0c0c0;
    border-right: 1px solid rgba(0, 0, 0, 0.3);
    z-index: 1;
    }
    .string-line {
    position: absolute;
    left: 0;
    width: 100%;
    height: 1px;
    background: silver;
    border-bottom: 1px solid rgba(0, 0, 0, 0.3);
    z-index: 0;
    }
    .fret-number {
    position: absolute;
    bottom: -40px; /* Adjusted for better spacing */
    font-size: 16px;
    color: #1f618d; /* Match body background */
    transform: translateX(-50%);
    font-weight: bold;
    z-index: 2;
    width: 20px;
    text-align: center;
    transition: color 0.3s ease;
    }
    .fret-marker {
    position: absolute;
    width: 12px;
    height: 12px;
    background-color: #333; /* Dark marker */
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: background-color 0.3s ease;
    }
    .note {
    position: absolute;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: white; /* Text color inside note */
    background-color: #4CAF50; /* Default note color */
    z-index: 3;
    cursor: pointer;
    transform: translate(-50%, -50%);
    transition: transform 0.1s ease, background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .note:hover {
    transform: translate(-50%, -50%) scale(1.2);
    }
    .note.root {
        background-color: #BD2031; /* Red for root notes */
    }
    .note.degree-2-4-6 {
        background-color: #006400; /* Dark green for specific degrees */
    }

    .beat {
    width: 40px;
    height: 80px;
    background: #9E9E9E; /* Default beat color */
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: white;
    font-weight: bold;
    transition: all 0.2s ease;
    font-size: 14px;
    margin: 0 2px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .beats-container {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin: 20px 0;
    flex-wrap: nowrap; /* Keep beats in a line */
    overflow-x: auto; /* Allow scrolling if too many beats */
    padding-bottom: 10px; /* Space for scrollbar */
    }
    .beat.active {
    transform: translateY(-10px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    #measures {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
    gap: 20px;
    margin-top: 15px; /* Space above measures */
    }
    .measure {
    position: relative;
    background-color: #e9ecef;
    padding: 15px;
    border-radius: 4px;
    transition: opacity 0.2s ease, background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    border: 1px solid #ced4da;
    color: #333; /* Default text color */
    }
    .measure.dragging {
    opacity: 0.5;
    }
    .measure.active {
    background-color: #c3e6cb; /* Light green highlight */
    border: 2px solid #28a745; /* Green border */
    }
    .measure-number {
    position: absolute;
    top: 5px;
    right: 5px;
    font-size: 12px;
    color: #6c757d; /* Grey number */
    transition: color 0.3s ease;
    }
    .chord-controls, .scale-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    }
    .chord-controls select, .scale-controls select {
    flex: 1; /* Make selects fill space */
    min-width: 80px; /* Prevent selects from becoming too small */
    }

    .fretboard-section {
    border: 1px solid #ccc;
    padding: 15px;
    border-radius: 8px;
    background-color: #f9f9f9;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .fretboard-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 15px;
    }

    .volume-control {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
    transition: color 0.3s ease;
    }
    .volume-control label, .volume-control span {
        min-width: 100px; /* Ensure label width consistency */
    }
    .volume-control input[type="range"] {
        flex-grow: 1; /* Allow slider to take available space */
    }

    button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    background: #4CAF50; /* Green */
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    button:hover {
        background-color: #45a049; /* Darker green */
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    select {
    padding: 5px;
    margin: 5px 0; /* Adjusted margin */
    border-radius: 5px;
    border: 1px solid #ddd;
    background-color: white;
    color: #333;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    #tempo-display {
    font-size: 1.2em;
    font-weight: bold;
    margin: 0 10px;
    min-width: 80px; /* Ensure space for BPM */
    text-align: center;
    }
    #loading-indicator {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 5px;
    z-index: 1000;
    }

    .checkbox-wrapper {
    margin-top: 10px; /* Reduced space */
    margin-left: 0; /* Align with other controls */
    display: flex;
    align-items: center;
    }

    .control-button {
    padding: 8px 16px;
    border: none;
    border-radius: 5px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .control-button:hover {
    background: #45a049;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .toggle-button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    background: #4CAF50; /* Active state */
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .toggle-button:not(.active) {
    background: #9E9E9E; /* Inactive state */
    }
    .toggle-button:hover {
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    #dark-mode-toggle {
        margin-bottom: 10px; /* Space below toggle */
    }

    /* --- Dark Mode 1 --- */
    body.dark-mode { background-color: #283618; color: #fefae0; }
    .dark-mode .app-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
    .dark-mode .fretboard-container { background-color: #606c38; border: 1px solid #dda15e; }
    .dark-mode .fretboard { background-color: #dda15e; border: 2px solid #4b4b4b; }
    .dark-mode .fret-number { color: #fefae0; }
    .dark-mode .fret-marker { background-color: #fefae0; }
    .dark-mode .note { background-color: #bc6c25; color: #283618; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    .dark-mode .note.root { background-color: #e76f51; } /* Adjusted root color */
    .dark-mode .note.degree-2-4-6 { background-color: #a7c957; } /* Adjusted degree color */
    .dark-mode .note:hover { background-color: #a5a58d; }
    .dark-mode .scale-display { color: #fefae0; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
    .dark-mode button, .dark-mode .control-button, .dark-mode .toggle-button { background-color: #dda15e; color: #283618; border: 1px solid #bc6c25; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode button:hover, .dark-mode .control-button:hover, .dark-mode .toggle-button:hover { background-color: #bc6c25; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
    .dark-mode .toggle-button:not(.active) { background: #606c38; border-color: #dda15e; }
    .dark-mode select { background-color: #dda15e; color: #283618; border: 1px solid #bc6c25; }
    .dark-mode select:hover { background-color: #bc6c25; }
    .dark-mode .measure { background-color: #606c38; color: #fefae0; border: 1px solid #dda15e; }
    .dark-mode .measure.active { background-color: #dda15e; border-color: #bc6c25; color: #283618; }
    .dark-mode .measure-number { color: #fefae0; opacity: 0.7; }
    .dark-mode .beat { background-color: #dda15e; color: #283618; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode .beat.active { background-color: #bc6c25; transform: translateY(-5px); }
    .dark-mode .volume-control { color: #fefae0; }
    .dark-mode #fretflow-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; }
    .dark-mode #dark-mode-toggle.active { background-color: #283618; color: #fefae0; border: 1px solid #dda15e; }

    /* --- Dark Mode 2 --- */
    body.dark-mode-2 { background-color: #0a1128; color: #fefcfb; }
    .dark-mode-2 .app-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 .fretboard-container { background-color: #034078; border: 1px solid #1282a2; }
    .dark-mode-2 .fretboard { background-color: #001f54; border: 2px solid #1282a2; }
    .dark-mode-2 .fret-number { color: #fefcfb; }
    .dark-mode-2 .fret-marker { background-color: #fefcfb; }
    .dark-mode-2 .note { background-color: #1282a2; color: #fefcfb; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 .note.root { background-color: #0a9396; }
    .dark-mode-2 .note.degree-2-4-6 { background-color: #94d2bd; color: #0a1128; }
    .dark-mode-2 .note:hover { background-color: #005f73; }
    .dark-mode-2 .scale-display { color: #fefcfb; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
    .dark-mode-2 button, .dark-mode-2 .control-button, .dark-mode-2 .toggle-button { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 button:hover, .dark-mode-2 .control-button:hover, .dark-mode-2 .toggle-button:hover { background-color: #005f73; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
    .dark-mode-2 .toggle-button:not(.active) { background: #034078; border-color: #1282a2; }
    .dark-mode-2 select { background-color: #034078; color: #fefcfb; border: 1px solid #1282a2; }
    .dark-mode-2 select:hover { background-color: #005f73; }
    .dark-mode-2 .measure { background-color: #034078; color: #fefcfb; border: 1px solid #1282a2; }
    .dark-mode-2 .measure.active { background-color: #1282a2; border-color: #fefcfb; color: #0a1128; }
    .dark-mode-2 .measure-number { color: #fefcfb; opacity: 0.7; }
    .dark-mode-2 .beat { background-color: #1282a2; color: #fefcfb; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 .beat.active { background-color: #005f73; transform: translateY(-5px); }
    .dark-mode-2 .volume-control { color: #fefcfb; }
    .dark-mode-2 #fretflow-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
    .dark-mode-2 #dark-mode-toggle.active-2 { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }

    /* --- Dark Mode 3 --- */
    body.dark-mode-3 { background-color: #6b705c; color: #ffe8d6; }
    .dark-mode-3 .app-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 .fretboard-container { background-color: #a5a58d; border: 1px solid #cb997e; }
    .dark-mode-3 .fretboard { background-color: #cb997e; border: 2px solid #6b705c; }
    .dark-mode-3 .fret-number { color: #ffe8d6; }
    .dark-mode-3 .fret-marker { background-color: #ffe8d6; }
    .dark-mode-3 .note { background-color: #b7b7a4; color: #6b705c; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 .note.root { background-color: #ddbea9; }
    .dark-mode-3 .note.degree-2-4-6 { background-color: #e9edc9; color: #6b705c; }
    .dark-mode-3 .note:hover { background-color: #a5a58d; }
    .dark-mode-3 .scale-display { color: #ffe8d6; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
    .dark-mode-3 button, .dark-mode-3 .control-button, .dark-mode-3 .toggle-button { background-color: #cb997e; color: #6b705c; border: 1px solid #6b705c; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 button:hover, .dark-mode-3 .control-button:hover, .dark-mode-3 .toggle-button:hover { background-color: #b7b7a4; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
    .dark-mode-3 .toggle-button:not(.active) { background: #a5a58d; border-color: #cb997e; }
    .dark-mode-3 select { background-color: #ddbea9; color: #6b705c; border: 1px solid #cb997e; }
    .dark-mode-3 select:hover { background-color: #cb997e; }
    .dark-mode-3 .measure { background-color: #a5a58d; color: #ffe8d6; border: 1px solid #cb997e; }
    .dark-mode-3 .measure.active { background-color: #ddbea9; border-color: #cb997e; color: #6b705c; }
    .dark-mode-3 .measure-number { color: #ffe8d6; opacity: 0.7; }
    .dark-mode-3 .beat { background-color: #ddbea9; color: #6b705c; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 .beat.active { background-color: #cb997e; transform: translateY(-5px); }
    .dark-mode-3 .volume-control { color: #ffe8d6; }
    .dark-mode-3 #fretflow-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; }
    .dark-mode-3 #dark-mode-toggle.active-3 { background-color: #cb997e; color: #ffe8d6; border: 1px solid #6b705c; }

    @media (max-width: 768px) {
        .fretboards-grid {
            grid-template-columns: 1fr; /* Stack fretboards on smaller screens */
        }
        .controls-container {
            flex-direction: column; /* Stack controls vertically */
            align-items: flex-start;
        }
        .controls {
            flex-direction: column;
            align-items: stretch;
        }
        .volume-control {
            flex-direction: column;
            align-items: flex-start;
        }
        .volume-control input[type="range"] {
            width: 100%;
        }
        #measures {
            grid-template-columns: 1fr; /* Single column for measures */
        }
    }

    </style>
</head>
<body>
    <div class="app-section" id="chord-fretboard-section">
    <h1>BEBOP BLUEPRINT</h1>
    <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
    <button id="dark-mode-toggle" aria-label="Toggle dark mode">Theme</button>
    <div class="volume-control">
    <label for="chord-fretboard-volume">Fretboard Volume:</label>
    <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.05" value="0.3">
    </div>
    <div class="fretboard-container">
    <div class="scale-display" id="scale-display">C Major</div> <!-- Default text -->
    <div class="controls">
        <label for="chord-tuning">Tuning:</label>
        <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
            <option value="standard">Standard (EADGBE)</option>
            <option value="dropD">Drop D (DADGBE)</option>
            <option value="openG">Open G (DGDGBD)</option>
            <option value="DADGAD">DADGAD</option>
            <option value="openE">Open E (EBEG#BE)</option>
        </select>
    </div>
    <div id="chord-fretboard" class="fretboard"></div>
    </div>
    </div>

    <div class="app-section" id="metronome-section">
    <h2>BeatForge Metronome</h2>
    <h3>Click beats to change sound/accent</h3>
    <div class="controls">
        <label for="time-signature">Time Sig:</label>
        <select id="time-signature" aria-label="Select time signature">
            <option value="2">2/4</option>
            <option value="3">3/4</option>
            <option value="4" selected>4/4</option>
            <option value="6">6/8</option>
            <option value="7">7/8</option>
            <!-- <option value="8">8/8</option> --> <!-- 8/8 often felt as 4/4 -->
            <option value="12">12/8</option>
        </select>
        <label for="sound-type">Sound:</label>
        <select id="sound-type" aria-label="Select metronome sound">
            <option value="click">Click</option>
            <option value="woodblock">Woodblock</option>
            <option value="drums">Drums</option>
        </select>
        <button id="drumSetToggleBtn" class="control-button" style="display: none;">Drums</button> <!-- Hidden by default -->
        <label for="tempo">Tempo:</label>
        <input type="range" id="tempo" min="40" max="240" value="120" aria-label="Tempo">
        <span id="tempo-display">120 BPM</span>
        <button id="tap-tempo" aria-label="Tap tempo">Tap</button>
        <button id="start-stop" aria-label="Start or stop metronome">Start</button>
    </div>
        <!-- Add these inside the div with class="controls-section" -->
    <div>
        <label for="rhythm-pattern">Rhythm:</label>
        <select id="rhythm-pattern">
            <option value="downbeats">Downbeats</option>
            <option value="beats13">Beats 1 & 3</option>
            <option value="charleston">Charleston</option>
            <!-- Add more patterns later -->
        </select>
    </div>
    <div>
        <label for="two-chords">Two Chords/Measure:</label>
        <input type="checkbox" id="two-chords">
    </div>
    <div>
        <label for="voicing-type">Voicing Type:</label>
        <select id="voicing-type">
            <option value="standard">Standard</option>
            <option value="drop2">Drop 2</option>
            <option value="drop3">Drop 3</option>
            <option value="drop24">Drop 2 & 4</option>
            <!-- Add Rootless, Quartal later if needed -->
        </select>
    </div>
    <!-- End of new controls -->
     <div class="volume-control">
        <label for="metronome-volume">Metronome Vol:</label>
        <input type="range" id="metronome-volume" min="0" max="1" step="0.05" value="0.25" aria-label="Metronome volume">
    </div>
    <div class="volume-control">
        <label for="accent-intensity">Accent Intensity:</label>
        <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
    </div>
    <div class="beats-container"></div>
    </div>

    <div class="app-section" id="chord-progression-section">
    <h2>Chord Progression Practice</h2>
    <h3>Create a progression or pick one. Drag measures to reorder.</h3>
     <div class="controls">
        <label for="progression-select">Load Progression:</label>
        <select id="progression-select" aria-label="Select chord progression">
            <option value="">-- Select Standard --</option>
            <option value="I V7">I-V7</option>
            <option value="jazz_blues">Jazz Blues</option>
            <option value="minor_blues">Minor Blues</option>
            <option value="rhythm_changes">Rhythm Changes</option>
            <option value="2_5_1">II-V-I</option>
            <option value="6_2_5_1">VI-II-V-I</option>
            <option value="minor_2_5_1">Minor iim-V7-im</option>
            <option value="dark_eyes">Dark Eyes</option>
            <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams</option>
            <option value="rose_room">Rose Room</option>
            <option value="black_orpheus">Black Orpheus</option>
            <option value="all_the_things_you_are">All The Things You Are</option>
            <option value="all_of_me">All of Me</option>
            <option value="stella_by_starlight">Stella By Starlight</option>
            <option value="autumn_leaves">Autumn Leaves</option>
            <option value="summertime">Summertime</option>
            <option value="girl_from_ipanema">Girl From Ipanema</option>
            <option value="coltrane_changes">Coltrane Changes</option>
            <option value="bird_blues">Bird Blues</option>
            <option value="just_friends">Just Friends</option>
            <option value="blue_bossa">Blue Bossa</option>
            <option value="on_green_dolphin_street">On Green Dolphin Street</option>
            <option value="solar">Solar</option>
            <option value="misty">Misty</option>
            <option value="days_of_wine_and_roses">Days of Wine and Roses</option>
            <option value="cherokee">Cherokee</option>
            <option value="caravan">Caravan</option>
            <option value="nows_the_time">Now's The Time</option>
            <option value="tenor_madness">Tenor Madness</option>
        </select>
        <label for="keySelect">Key:</label>
        <select id="keySelect" aria-label="Select key">
            <!-- Options populated by JS -->
        </select>
        <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
        <button onclick="removeMeasure()" aria-label="Remove measure">Remove Last</button>
    </div>
    <div class="controls">
         <div class="checkbox-wrapper">
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.05" value="0.75" aria-label="Chord volume">
        </div>
    </div>
    <div id="measures">
        <!-- Measures will be populated dynamically -->
    </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <!-- FretFlow controls moved inside initializeFretFlow -->
    <div class="volume-control">
        <label for="fretboard-volume">FretFlow Volume:</label>
        <input type="range" id="fretboard-volume" min="0" max="1" step="0.05" value="0.3" aria-label="Fretboard volume">
    </div>
    <div class="fretboards-grid">
        <!-- 4 Fretboards populated by JS -->
    </div>
</div>
    <div id="loading-indicator" style="display: none;">Loading...</div>

    <script>

// --- Constants ---
const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const SAMPLE_NOTES = ['c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs', 'a', 'as', 'b']; // For audio file names
const OCTAVES = [2, 3, 4, 5]; // Available sample octaves
const FILE_FORMAT = 'wav'; // Assumed sample format

const SAMPLE_NOTE_MAP = { // Maps standard notation to sample file notation
    'C': 'c', 'C#': 'cs', 'Db': 'cs', 'D': 'd', 'D#': 'ds', 'Eb': 'ds', 'E': 'e',
    'F': 'f', 'F#': 'fs', 'Gb': 'fs', 'G': 'g', 'G#': 'gs', 'Ab': 'gs', 'A': 'a',
    'A#': 'as', 'Bb': 'as', 'B': 'b'
};

const SCALES = {
    major: { name: "Major (Ionian)", intervals: [0, 2, 4, 5, 7, 9, 11] },
    minor: { name: "Minor (Aeolian)", intervals: [0, 2, 3, 5, 7, 8, 10] },
    dorian: { name: "Dorian", intervals: [0, 2, 3, 5, 7, 9, 10] },
    phrygian: { name: "Phrygian", intervals: [0, 1, 3, 5, 7, 8, 10] },
    lydian: { name: "Lydian", intervals: [0, 2, 4, 6, 7, 9, 11] },
    mixolydian: { name: "Mixolydian", intervals: [0, 2, 4, 5, 7, 9, 10] },
    locrian: { name: "Locrian", intervals: [0, 1, 3, 5, 6, 8, 10] },
    harmonicMinor: { name: "Harmonic Minor", intervals: [0, 2, 3, 5, 7, 8, 11] },
    melodicMinor: { name: "Melodic Minor", intervals: [0, 2, 3, 5, 7, 9, 11] },
    bebopDominant: { name: "Bebop Dominant", intervals: [0, 2, 4, 5, 7, 9, 10, 11] },
    bebopMajor: { name: "Bebop Major", intervals: [0, 2, 4, 5, 7, 8, 9, 11] },
    // bebopDorian: { name: "Bebop Dorian", intervals: [0, 2, 3, 4, 5, 7, 9, 10] }, // Less common
    altered: { name: "Altered (Super Locrian)", intervals: [0, 1, 3, 4, 6, 8, 10] },
    lydianDominant: { name: "Lydian Dominant", intervals: [0, 2, 4, 6, 7, 9, 10] },
    diminishedWH: { name: "Diminished (W-H)", intervals: [0, 2, 3, 5, 6, 8, 9, 11] },
    diminishedHW: { name: "Diminished (H-W)", intervals: [0, 1, 3, 4, 6, 7, 9, 10] },
    wholeTone: { name: "Whole Tone", intervals: [0, 2, 4, 6, 8, 10] },
    pentatonicMajor: { name: "Pentatonic Major", intervals: [0, 2, 4, 7, 9] },
    pentatonicMinor: { name: "Pentatonic Minor", intervals: [0, 3, 5, 7, 10] },
    blues: { name: "Blues", intervals: [0, 3, 5, 6, 7, 10] },
    // majorBlues: { name: "Major Blues", intervals: [0, 2, 3, 4, 7, 9] }, // Less common standard name
    harmonicMajor: { name: "Harmonic Major", intervals: [0, 2, 4, 5, 7, 8, 11] },
    doubleHarmonic: { name: "Double Harmonic", intervals: [0, 1, 4, 5, 7, 8, 11] },
};

const TUNINGS = {
    standard: { name: 'Standard (EADGBE)', notes: ['E', 'A', 'D', 'G', 'B', 'E'] },
    dropD:    { name: 'Drop D (DADGBE)', notes: ['D', 'A', 'D', 'G', 'B', 'E'] },
    openG:    { name: 'Open G (DGDGBD)', notes: ['D', 'G', 'D', 'G', 'B', 'D'] },
    DADGAD:   { name: 'DADGAD', notes: ['D', 'A', 'D', 'G', 'A', 'D'] },
    openE:    { name: 'Open E (EBEG#BE)', notes: ['E', 'B', 'E', 'G#', 'B', 'E'] }
};

const CHORD_QUALITIES = { // Maps internal value to display name and intervals (Root=0)
    'maj': { name: 'Major', intervals: [0, 4, 7] },
    'min': { name: 'Minor', intervals: [0, 3, 7] },
    'maj7': { name: 'Maj7', intervals: [0, 4, 7, 11] },
    '7': { name: '7', intervals: [0, 4, 7, 10] }, // Dominant 7th
    'min7': { name: 'm7', intervals: [0, 3, 7, 10] },
    'm7b5': { name: 'm7b5', intervals: [0, 3, 6, 10] }, // Half-diminished
    'dim7': { name: 'dim7', intervals: [0, 3, 6, 9] }, // Fully diminished 7th
    'dim': { name: 'dim', intervals: [0, 3, 6] }, // Diminished triad
    'aug': { name: 'aug', intervals: [0, 4, 8] }, // Augmented triad
    '6': { name: '6', intervals: [0, 4, 7, 9] }, // Major 6th
    'm6': { name: 'm6', intervals: [0, 3, 7, 9] }, // Minor 6th
    'sus4': { name: 'sus4', intervals: [0, 5, 7] },
    'sus2': { name: 'sus2', intervals: [0, 2, 7] },
    '7sus4': { name: '7sus4', intervals: [0, 5, 7, 10] },
    'add9': { name: 'add9', intervals: [0, 4, 7, 14] }, // Major triad + 9th
    'madd9': { name: 'm(add9)', intervals: [0, 3, 7, 14] }, // Minor triad + 9th
    'maj9': { name: 'Maj9', intervals: [0, 4, 7, 11, 14] },
    '9': { name: '9', intervals: [0, 4, 7, 10, 14] }, // Dominant 9th
    'min9': { name: 'm9', intervals: [0, 3, 7, 10, 14] },
    'maj13': { name: 'Maj13', intervals: [0, 4, 7, 11, 14, 21] }, // Often implies 9th too
    '13': { name: '13', intervals: [0, 4, 7, 10, 14, 21] }, // Dominant 13th, implies 9th
    'min13': { name: 'm13', intervals: [0, 3, 7, 10, 14, 21] }, // Implies 9th
    '7b9': { name: '7b9', intervals: [0, 4, 7, 10, 13] },
    '7#9': { name: '7#9', intervals: [0, 4, 7, 10, 15] },
    '7b5': { name: '7b5', intervals: [0, 4, 6, 10] },
    '7#5': { name: '7#5', intervals: [0, 4, 8, 10] }, // Same as 7aug
    // '7alt': { name: '7alt', intervals: [0, 4, 10] } // Alt chords are complex, often imply b9, #9, b5, #5 - handle via scale choice
};

 /**
 * Bebop Blueprint - Advanced Jazz Practice Tool
 * Features: Dynamic Fretboard, Metronome, Chord Progression Practice, Scale Workout
 * Author: [Your Name/AI Assistant]
 * Date: 2025-05-03
 */

const SAMPLE_NOTE_MAP = NOTES.reduce((map, note, index) => {
    map[note] = SAMPLE_NOTES[index];
    return map;
}, {});
const OCTAVES = [2, 3, 4, 5]; // Piano sample octaves available
const FILE_FORMAT = 'wav'; // Assumed audio file format

const TUNINGS = {
    standard: { name: "Standard (EADGBE)", notes: ["E", "A", "D", "G", "B", "E"] },
    dropD: { name: "Drop D (DADGBE)", notes: ["D", "A", "D", "G", "B", "E"] },
    openG: { name: "Open G (DGDGBD)", notes: ["D", "G", "D", "G", "B", "D"] },
    openD: { name: "Open D (DADF#AD)", notes: ["D", "A", "D", "F#", "A", "D"] }
    // Add more tunings as needed
};

const SCALES = {
    major: { name: "Major (Ionian)", intervals: [0, 2, 4, 5, 7, 9, 11] },
    minor: { name: "Natural Minor (Aeolian)", intervals: [0, 2, 3, 5, 7, 8, 10] },
    harmonicMinor: { name: "Harmonic Minor", intervals: [0, 2, 3, 5, 7, 8, 11] },
    melodicMinor: { name: "Melodic Minor (Asc)", intervals: [0, 2, 3, 5, 7, 9, 11] },
    dorian: { name: "Dorian", intervals: [0, 2, 3, 5, 7, 9, 10] },
    phrygian: { name: "Phrygian", intervals: [0, 1, 3, 5, 7, 8, 10] },
    lydian: { name: "Lydian", intervals: [0, 2, 4, 6, 7, 9, 11] },
    mixolydian: { name: "Mixolydian", intervals: [0, 2, 4, 5, 7, 9, 10] },
    locrian: { name: "Locrian", intervals: [0, 1, 3, 5, 6, 8, 10] },
    majorPentatonic: { name: "Major Pentatonic", intervals: [0, 2, 4, 7, 9] },
    minorPentatonic: { name: "Minor Pentatonic", intervals: [0, 3, 5, 7, 10] },
    blues: { name: "Blues", intervals: [0, 3, 5, 6, 7, 10] },
    diminishedWH: { name: "Diminished (WH)", intervals: [0, 2, 3, 5, 6, 8, 9, 11] },
    diminishedHW: { name: "Diminished (HW)", intervals: [0, 1, 3, 4, 6, 7, 9, 10] },
    wholeTone: { name: "Whole Tone", intervals: [0, 2, 4, 6, 8, 10] },
    altered: { name: "Altered (Super Locrian)", intervals: [0, 1, 3, 4, 6, 8, 10] },
    lydianDominant: { name: "Lydian Dominant", intervals: [0, 2, 4, 6, 7, 9, 10] },
};

const CHORD_QUALITIES = {
    // Basic Triads
    'maj': { name: "Major Triad", intervals: [0, 4, 7] },
    'min': { name: "Minor Triad", intervals: [0, 3, 7] },
    'dim': { name: "Diminished Triad", intervals: [0, 3, 6] },
    'aug': { name: "Augmented Triad", intervals: [0, 4, 8] },
    // Sevenths
    'maj7': { name: "Major 7th (Δ7)", intervals: [0, 4, 7, 11] },
    '7': { name: "Dominant 7th", intervals: [0, 4, 7, 10] },
    'm7': { name: "Minor 7th", intervals: [0, 3, 7, 10] },
    'm7b5': { name: "Half-Diminished (ø7)", intervals: [0, 3, 6, 10] },
    'dim7': { name: "Diminished 7th (°7)", intervals: [0, 3, 6, 9] },
    'mMaj7': { name: "Minor-Major 7th", intervals: [0, 3, 7, 11] },
    'aug7': { name: "Augmented 7th (+7)", intervals: [0, 4, 8, 10] },
    'augMaj7': { name: "Augmented Major 7th (+Δ7)", intervals: [0, 4, 8, 11] },
    // Sixths
    '6': { name: "Major 6th", intervals: [0, 4, 7, 9] },
    'm6': { name: "Minor 6th", intervals: [0, 3, 7, 9] },
    // Suspended
    'sus4': { name: "Suspended 4th", intervals: [0, 5, 7] },
    'sus2': { name: "Suspended 2nd", intervals: [0, 2, 7] },
    '7sus4': { name: "7th Suspended 4th", intervals: [0, 5, 7, 10] },
    // Add more complex chords (9ths, 11ths, 13ths, altered) as needed
};

// --- Global Variables & State ---
const drumSoundSets = [
    { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" },
    { name: "Makaya", snare: "Snare2.wav", hihat: "HiHat2.wav", kick: "Kick2.wav" },
    { name: "PhillyJoe", kick: 'jazzkick.wav', snare: 'jazzsnare.wav', hihat: 'jazzhat.wav' }
];
let currentDrumSetIndex = 0;

// Variables for new playback features
let selectedRhythmPattern = 'downbeats';
let twoChordsPerMeasureEnabled = false;
let selectedVoicingType = 'standard';
let currentPlaybackIntervalId = null; // Keep track of the interval for new playback loop

const rhythmPatterns = {
    'downbeats': [1], // Play on beat 1
    'beats13': [1, 3], // Play on beats 1 and 3
    'charleston': [1, 3.5], // Play on beat 1 and the '&' of 3
    // Add more patterns here (e.g., bossa, swing comping)
};

const progressions = {
    "I V7": { defaultKey: "C", progression: ["Imaj7", "V7"] }, // Using Maj7 for I
    "jazz_blues": { defaultKey: "Bb", progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "IIm7", "V7", "I7", "V7"] },
    "minor_blues": { defaultKey: "Cm", progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"] }, // Start in Cm
    "rhythm_changes": { defaultKey: "Bb", progression: ["I6", "vim7", "iim7", "V7", "I6", "vim7", "iim7", "V7", "I6", "IV7", "I6", "I6", "iim7", "V7", "I6", "V7"] }, // A section only for simplicity
    "2_5_1": { defaultKey: "C", progression: ["IIm7", "V7", "Imaj7", "Imaj7"] },
    "6_2_5_1": { defaultKey: "C", progression: ["VIm7", "IIm7", "V7", "Imaj7"] }, // Often 4 bars
    "minor_2_5_1": { defaultKey: "Cm", progression: ["IIm7b5", "V7", "Im7", "Im7"] }, // V7 often altered (b9)
    "dark_eyes": { defaultKey: "Dm", progression: ["V7", "V7", "Im7", "Im7", "V7", "V7", "VI6", "VI6", "IVm6", "IVm6", "Im7", "Im7", "V7", "V7", "Im7", "Im7"] },
    "ill_see_you_in_my_dreams": { defaultKey: "F", progression: ["IV6", "IV6", "IVm6", "IVm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "IIm7", "V7", "Imaj7"] },
    "rose_room": {defaultKey: "Ab", progression: ["II7", "V7", "I6", "I7", "IV6", "IVm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "IVm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"] },
    "black_orpheus": { defaultKey: "Am", progression: ["Im7", "IIm7b5", "V7", "Im7", "IVm7", "VII7", "bIIImaj7", "bVImaj7", "IIm7b5", "V7", "Im7", "IIm7b5", "V7", "Im7", "IVm7", "VII7"] }, // V7 often altered
    "all_the_things_you_are": { defaultKey: "Ab", progression: ["VIm7", "IIm7", "V7", "Imaj7", "IVmaj7", "VIIm7b5", "III7", "VIm7", "IIm7", "V7", "Imaj7", "IVmaj7", "bVIIm7", "bIII7", "bVImaj7", "bIImaj7", "V7sus4", "V7", "Imaj7"] }, // Simplified common changes
    "all_of_me": { defaultKey: "C", progression: ["Imaj7", "III7", "VI7", "IIm7", "E7", "Am7", "D7", "Dm7", "G7", "Cmaj7", "E7", "A7", "Dm7", "Fmaj7", "Fm6", "Cmaj7", "G7"] }, // Common changes
    "stella_by_starlight": { defaultKey: "Bb", progression: ["Em7b5", "A7", "Cm7", "F7", "Fm7", "Bb7", "Ebmaj7", "Ab7", "Dm7b5", "G7", "Cm7", "F7", "Bbmaj7"] }, // Simplified first part
    "autumn_leaves": { defaultKey: "Gm", progression: ["Cm7", "F7", "Bbmaj7", "Ebmaj7", "Am7b5", "D7", "Gm7", "Gm7"] }, // Key Gm
    "summertime": { defaultKey: "Am", progression: ["Am7", "E7", "Am7", "E7", "Am7", "Dm7", "Am7", "E7", "Dm7", "Am7", "E7", "Am7"] }, // Simplified
    "girl_from_ipanema": { defaultKey: "F", progression: ["Fmaj7", "G7", "Gm7", "C7", "Fmaj7", "Gb7", "Fmaj7"] }, // A section
    "coltrane_changes": { defaultKey: "C", progression: ["Cmaj7", "Eb7", "Abmaj7", "B7", "Emaj7", "G7", "Cmaj7"] }, // Basic cycle
    "bird_blues": { defaultKey: "F", progression: ["Fmaj7", "Em7b5", "A7", "Dm7", "G7", "Cm7", "F7", "Bbmaj7", "Bbm7", "Eb7", "Am7", "D7", "Gm7", "C7", "Fmaj7", "D7", "Gm7", "C7"] }, // Parker Blues
    "just_friends": { defaultKey: "G", progression: ["Gmaj7", "B7", "Em7", "A7", "Am7", "D7", "Gmaj7"] }, // Simplified A section
    "blue_bossa": { defaultKey: "Cm", progression: ["Cm7", "Fm7", "Bb7", "Ebmaj7", "Dm7b5", "G7", "Cm7"] }, // Simplified
    "on_green_dolphin_street": { defaultKey: "C", progression: ["Cmaj7", "Cm7", "F7", "Bbmaj7", "Ebmaj7", "Am7b5", "D7", "Gm7", "C7", "Fmaj7", "Fm7", "Bb7", "Ebmaj7", "Abmaj7", "Dm7", "G7", "Cmaj7"] }, // Common changes
    "solar": { defaultKey: "Cm", progression: ["Cm7", "Gm7", "C7", "Fmaj7", "Fm7", "Bb7", "Ebmaj7", "Am7b5", "D7", "Gm7", "C7", "Fmaj7"] }, // Miles Davis changes
    "misty": { defaultKey: "Eb", progression: ["Ebmaj7", "Bbm7", "Eb7", "Abmaj7", "Abm7", "Db7", "Ebmaj7", "Cm7", "Fm7", "Bb7", "Ebmaj7"] }, // A section
    "days_of_wine_and_roses": { defaultKey: "F", progression: ["Fmaj7", "Eb7", "Abmaj7", "Db7", "Gm7", "C7", "Fmaj7"] }, // Simplified A section
    "cherokee": { defaultKey: "Bb", progression: ["Bbmaj7", "Bbmaj7", "Cm7", "F7", "Bbmaj7", "Bbmaj7", "Gm7", "C7", "Fmaj7", "Fmaj7", "Gm7", "C7", "Fmaj7", "Fmaj7", "Cm7", "F7"] }, // A section
    "caravan": { defaultKey: "Fm", progression: ["Fm7", "C7", "Fm7", "C7", "Fm7", "Bbm7", "Eb7", "Abmaj7", "Dbmaj7", "Gm7b5", "C7", "Fm7"] }, // A section
    "nows_the_time": { defaultKey: "F", progression: ["F7", "F7", "F7", "F7", "Bb7", "Bb7", "F7", "F7", "C7", "Bb7", "F7", "F7"] }, // Basic Blues
    "tenor_madness": { defaultKey: "Bb", progression: ["Bb7", "Bb7", "Bb7", "Bb7", "Eb7", "Eb7", "Bb7", "Bb7", "F7", "Eb7", "Bb7", "Bb7"] } // Basic Blues
};

// --- State Management ---
const AppState = {
    isPlaying: false, // Use this for the NEW playback loop
    // currentBeat: 0, // OLD state, managed by new loop's currentSubdivision
    // currentMeasure: 0, // OLD state, managed by new loop's currentMeasureIndex
    tempo: 120,
    audioInitialized: false,
    darkMode: 0, // 0: light, 1, 2, 3: dark modes
    listeners: [],
    // intervalId: null, // OLD state, replaced by currentPlaybackIntervalId
    lastTap: null,
    chordsPlaybackEnabled: true,
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};

// --- UI Management ---
const UI = {
    elements: {}, // Populated in init
    init() {
        this.elements = {
            // Existing elements...
            chordFretboard: document.getElementById('chord-fretboard'),
            measures: document.getElementById('measures'), // Container for progression measures
            progressionContainer: document.getElementById('progression-container'), // Specific container for progression
            tempoDisplay: document.getElementById('tempo-display'),
            startStopButton: document.getElementById('start-stop'), // OLD button? Need new one? Assume this is the main play button.
            playButton: document.getElementById('play-button'), // NEW button? Let's assume startStopButton is the one.
            progressionSelect: document.getElementById('progression-select'),
            keySelect: document.getElementById('keySelect'),
            scaleDisplay: document.getElementById('scale-display'),
            chordTuning: document.getElementById('chord-tuning'),
            timeSignature: document.getElementById('time-signature'),
            soundType: document.getElementById('sound-type'),
            metronomeVolume: document.getElementById('metronome-volume'),
            tempo: document.getElementById('tempo'),
            tapTempo: document.getElementById('tap-tempo'),
            chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
            chordVolume: document.getElementById('chord-volume'),
            chordsEnabled: document.getElementById('chordsEnabled'),
            fretboardVolume: document.getElementById('fretboard-volume'),
            fretboardsGrid: document.querySelector('.fretboards-grid'),
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            accentIntensity: document.getElementById('accent-intensity'),
            loadingIndicator: document.getElementById('loading-indicator'),
            drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
            beatsContainer: document.querySelector('.beats-container'), // For old metronome display
            fretflowSection: document.getElementById('fretflow-section'),

            // New UI elements for playback control
            rhythmPatternSelect: document.getElementById('rhythm-pattern'),
            twoChordsCheckbox: document.getElementById('two-chords'),
            voicingTypeSelect: document.getElementById('voicing-type')
        };
        // Check if all elements were found
        Object.entries(this.elements).forEach(([key, el]) => {
            // Allow new elements to be null initially if they haven't been added to HTML yet
            if (!el && !['rhythmPatternSelect', 'twoChordsCheckbox', 'voicingTypeSelect'].includes(key)) {
                 console.warn(`[UI Init] Missing DOM element: ${key}`);
            }
        });
        log("[UI Init] Elements cached.");
    }
};

// --- Utility Functions ---
function log(message) {
    console.log(`[Bebop Blueprint] ${message}`);
}

function updateLoadingStatus(message, show = true) {
    if (UI.elements.loadingIndicator) {
        UI.elements.loadingIndicator.textContent = message;
        UI.elements.loadingIndicator.style.display = show ? 'block' : 'none';
    }
}

function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

function getSampleFileName(note, octave) {
  // note should be in SAMPLE_NOTES format (e.g., 'cs')
  return `${note}${octave}.${FILE_FORMAT}`;
}

// --- Audio Management ---
const AudioContextManager = {
    context: null,
    soundBuffers: {}, // For metronome clicks, woodblocks, default drums
    pianoSampleBuffers: {}, // For piano chords/notes
    reverbNode: null,
    samplesLoaded: false,
    currentChordGain: null, // Gain node for the currently playing chord (OLD system)

    initialize: async function() {
        if (this.context && this.context.state === 'running') return this.context;
        try {
            if (!this.context) {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                log("AudioContext created.");
            }
            if (this.context.state === 'suspended') {
                await this.context.resume();
                log("AudioContext resumed.");
            }
            if (Object.keys(this.soundBuffers).length === 0) {
                 updateLoadingStatus("Loading sounds...");
                 await this.loadSounds();
            }
             if (Object.keys(this.pianoSampleBuffers).length === 0) {
                 updateLoadingStatus("Loading piano samples...");
                 await this.loadPianoSamples();
            }
            if (!this.reverbNode) {
                 await this.setupReverb();
            }
            AppState.updateState({ audioInitialized: true });
            log("AudioContext initialized successfully.");
            return this.context;
        } catch (error) {
            console.error("AudioContext initialization failed:", error);
            alert("Could not initialize audio. Please ensure your browser supports the Web Audio API and try refreshing the page.");
            AppState.updateState({ audioInitialized: false });
            throw error;
        }
    },

    ensureAudioContext: async function() {
        if (!AppState.audioInitialized || !this.context || this.context.state !== 'running') {
            log("Ensuring AudioContext is running...");
            await this.initialize();
        }
        return this.context;
    },

    loadSounds: async function() {
        const soundFiles = {
            'click': 'Click.wav', 'hihat': 'HiHat.wav', 'kick': 'Kick.wav',
            'snare': 'Snare.wav', 'woodblock': 'woodblock.wav'
        };
        for (const set of drumSoundSets) {
            soundFiles[`kick_${set.name}`] = set.kick;
            soundFiles[`snare_${set.name}`] = set.snare;
            soundFiles[`hihat_${set.name}`] = set.hihat;
        }
        let loadedCount = 0;
        const totalSounds = Object.keys(soundFiles).length;
        const loadPromises = Object.entries(soundFiles).map(async ([type, filename]) => {
            try {
                const response = await fetch(`./${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${filename}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
                loadedCount++;
                updateLoadingStatus(`Loading sounds... (${loadedCount}/${totalSounds})`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                if (['click', 'woodblock', 'kick', 'snare', 'hihat'].includes(type)) {
                    this.soundBuffers[type] = await this.createSynthSound(type);
                    log(`Using fallback synthetic sound for ${type}`);
                }
            }
        });
        await Promise.all(loadPromises);
        log(`Loaded ${loadedCount} of ${totalSounds} metronome/drum sounds.`);
        updateLoadingStatus("Drum sounds loaded.");
    },

    createSynthSound: async function(type) {
        const sampleRate = this.context.sampleRate;
        const duration = type === 'hihat' ? 0.05 : 0.15;
        const buffer = this.context.createBuffer(1, Math.floor(sampleRate * duration), sampleRate);
        const data = buffer.getChannelData(0);
        let freq = 1000;
        if (type === 'kick') freq = 100;
        else if (type === 'snare') freq = 300;
        else if (type === 'woodblock') freq = 1500;
        for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            let envelope = Math.exp(-t * (type === 'hihat' ? 50 : 25));
            let noise = (type === 'snare' || type === 'hihat') ? (Math.random() * 2 - 1) * 0.5 : 0;
            data[i] = (Math.sin(2 * Math.PI * freq * t * (1 - t * 2)) + noise) * envelope;
        }
        return buffer;
    },

    loadPianoSamples: async function() {
        this.pianoSampleBuffers = {};
        let loadedCount = 0;
        const totalSamples = SAMPLE_NOTES.length * OCTAVES.length;
        const loadPromises = [];
        for (const note of SAMPLE_NOTES) {
            for (const octave of OCTAVES) {
                const fileName = getSampleFileName(note, octave);
                const key = `${note}${octave}`;
                const promise = (async () => {
                    try {
                        const response = await fetch(`./${fileName}`);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${fileName}`);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
                        this.pianoSampleBuffers[key] = audioBuffer;
                        loadedCount++;
                        updateLoadingStatus(`Loading piano samples... (${loadedCount}/${totalSamples})`);
                    } catch (e) {
                        console.error(`Failed to load sample: ${fileName}`, e);
                    }
                })();
                loadPromises.push(promise);
            }
        }
        await Promise.all(loadPromises);
        this.samplesLoaded = loadedCount > 0;
        log(`Loaded ${loadedCount} of ${totalSamples} piano samples.`);
        if (!this.samplesLoaded) {
             console.warn("No piano samples loaded. Chord playback will be silent.");
             alert("Warning: Could not load piano samples. Chord playback will be silent. Ensure sample files (e.g., c3.wav, cs3.wav...) are present.");
        }
        updateLoadingStatus("Piano samples loaded.");
    },

    setupReverb: async function() {
        try {
            this.reverbNode = this.context.createConvolver();
            // Create a simple synthetic impulse response
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 1.5;
            const impulse = this.context.createBuffer(2, length, sampleRate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
            }
            this.reverbNode.buffer = impulse;
            this.reverbNode.connect(this.context.destination);
            log("Reverb node set up.");
        } catch (error) {
            console.error("Failed to set up reverb:", error);
            this.reverbNode = null;
        }
    }
}; // <<< END OF AudioContextManager OBJECT DEFINITION


// --- Voicing and Chord Playback Functions (Moved OUTSIDE AudioContextManager) ---

/**
 * Gets the specific notes for a chord based on root, quality, and voicing rules.
 * Applies octave constraints and selected voicing types.
 * @param {string} rootNote - e.g., "C", "F#".
 * @param {string} quality - e.g., "maj7", "m7", "7", "m7b5".
 * @param {string} voicingType - 'standard', 'drop2', 'drop3', 'drop24'.
 * @param {number} targetOctaveStart - Preferred starting octave (e.g., 3).
 * @returns {string[]} Array of note names with octaves (e.g., ["C3", "E3", "G3", "B3"]).
 */
function getChordVoicing(rootNote, quality, voicingType = 'standard', targetOctaveStart = 3) {
    // console.log(`Getting voicing for: ${rootNote}${quality}, Type: ${voicingType}`);
    // Ensure getChordTones is defined and returns notes without octaves
    const chordTones = getChordTones(rootNote, quality);
    if (!chordTones || chordTones.length === 0) {
        console.error(`Could not get tones for ${rootNote}${quality}`);
        return [];
    }

    // 1. Create a basic close voicing starting near the target octave
    let octave = targetOctaveStart;
    let previousNoteMidi = -1;
    let closeVoicing = chordTones.map((noteName, index) => {
        // Ensure noteNameToMidi is defined and handles note+octave format
        let currentNoteMidi = noteNameToMidi(noteName + octave);
        if (index > 0 && currentNoteMidi < previousNoteMidi) {
            octave++;
            currentNoteMidi = noteNameToMidi(noteName + octave);
        }
        previousNoteMidi = currentNoteMidi;
        return noteName + octave;
    });

    // 2. Ensure it's mostly within octaves 2 and 3 (MIDI ~36 to ~60)
    let avgMidi = closeVoicing.reduce((sum, note) => sum + noteNameToMidi(note), 0) / closeVoicing.length;
    let targetAvgMidi = (noteNameToMidi("C2") + noteNameToMidi("C4")) / 2;
    let octaveShift = Math.round((targetAvgMidi - avgMidi) / 12);

    if (octaveShift !== 0) {
         // console.log(`Shifting octave by ${octaveShift}`);
         // Ensure midiToNoteName is defined
         closeVoicing = closeVoicing.map(note => {
             let midi = noteNameToMidi(note);
             return midiToNoteName(midi + octaveShift * 12);
         });
    }

    // 3. Apply Drop Voicings if requested (requires 4 notes)
    if (closeVoicing.length === 4 && ['drop2', 'drop3', 'drop24'].includes(voicingType)) {
        return applyDropVoicing(closeVoicing, voicingType);
    } else if (closeVoicing.length !== 4 && voicingType !== 'standard') {
         console.warn(`Cannot apply drop voicing to ${closeVoicing.length}-note chord. Using standard voicing.`);
    }

    // console.log(`Final voicing for ${rootNote}${quality}: ${closeVoicing.join(', ')}`);
    return closeVoicing;
}

/**
 * Applies Drop 2, Drop 3, or Drop 2&4 voicing to a 4-note close voicing.
 * Assumes input notes are sorted lowest to highest.
 * @param {string[]} closeVoicing - Array of 4 note names with octaves, sorted low to high.
 * @param {string} type - 'drop2', 'drop3', or 'drop24'.
 * @returns {string[]} The rearranged notes for the drop voicing.
 */
function applyDropVoicing(closeVoicing, type) {
    if (closeVoicing.length !== 4) {
        console.error("Drop voicings require exactly 4 notes.");
        return closeVoicing;
    }
    let notes = [...closeVoicing];
    let noteToDrop;
    switch (type) {
        case 'drop2':
            noteToDrop = notes.splice(2, 1)[0];
            notes.unshift(adjustOctave(noteToDrop, -1));
            break;
        case 'drop3':
            noteToDrop = notes.splice(1, 1)[0];
            notes.unshift(adjustOctave(noteToDrop, -1));
            break;
        case 'drop24':
            let note2 = notes.splice(2, 1)[0];
            let note4 = notes.splice(0, 1)[0];
            notes.unshift(adjustOctave(note2, -1));
            notes.unshift(adjustOctave(note4, -1));
            break;
        default:
            console.warn(`Unknown drop voicing type: ${type}`);
            return closeVoicing;
    }
    notes.sort((a, b) => noteNameToMidi(a) - noteNameToMidi(b)); // Ensure noteNameToMidi exists
    // console.log(`Applied ${type} voicing: ${notes.join(', ')}`);
    return notes;
}

/**
 * Adjusts the octave of a note name.
 * @param {string} noteName - e.g., "C#4".
 * @param {number} octaveChange - e.g., -1, 1.
 * @returns {string} Note name with adjusted octave.
 */
function adjustOctave(noteName, octaveChange) {
    // Ensure noteNameToMidi and midiToNoteName exist
    const midi = noteNameToMidi(noteName);
    if (midi === -1) return noteName;
    return midiToNoteName(midi + octaveChange * 12);
}

/**
 * Plays a chord using pre-loaded piano samples based on specific voiced notes.
 * This version is intended for the NEW playback system.
 * @param {string[]} notes - Array of specific note names with octaves (e.g., ["C3", "E3", "G3", "Bb3"]).
 * @param {number} duration - Duration in seconds.
 * @param {number} [startTime] - Optional AudioContext time to schedule playback.
 */
async function playChord(notes, duration, startTime) {
    const context = await AudioContextManager.ensureAudioContext();
    if (!context || !AudioContextManager.samplesLoaded || !AppState.chordsPlaybackEnabled) return;

    const now = context.currentTime;
    const playAt = startTime !== undefined ? startTime : now;
    const volume = parseFloat(UI.elements.chordVolume.value); // Use the correct UI element ID

    // console.log(`Playing chord: ${notes.join(', ')} at time ${playAt.toFixed(2)} for ${duration}s`);

    if (!notes || notes.length === 0 || volume <= 0) {
        // console.warn("playChord called with empty notes array or zero volume.");
        return;
    }

    notes.forEach(noteName => {
        // Map note name (e.g., C#3) to sample key (e.g., cs3)
        const match = noteName.match(/^([A-G][#b]?)([0-9])$/);
        if (!match) return;
        const notePart = standardizeNoteName(match[1]);
        const octavePart = match[2];
        const sampleNote = SAMPLE_NOTE_MAP[notePart];
        if (!sampleNote) return;
        const sampleKey = `${sampleNote}${octavePart}`;

        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
        if (buffer) {
            try {
                const source = context.createBufferSource();
                source.buffer = buffer;

                const gainNode = context.createGain();
                gainNode.gain.setValueAtTime(volume, playAt);
                // Fade out quickly at the end
                gainNode.gain.linearRampToValueAtTime(0.0001, playAt + duration);

                source.connect(gainNode);
                // Optional: Connect through reverb
                if (AudioContextManager.reverbNode) {
                    const reverbGain = context.createGain();
                    reverbGain.gain.value = 0.2; // Chord reverb amount
                    gainNode.connect(reverbGain);
                    reverbGain.connect(AudioContextManager.reverbNode);
                } else {
                    gainNode.connect(context.destination);
                }

                source.start(playAt);
                // Stop the source slightly after the fade ends
                source.stop(playAt + duration + 0.1);
            } catch (e) {
                 console.error(`Error playing chord note ${noteName}:`, e);
            }
        } else {
            console.warn(`Piano sample buffer not found for note: ${noteName} (key: ${sampleKey})`);
        }
    });
}


// --- Music Theory Utilities ---

function standardizeNoteName(note) {
    if (!note || typeof note !== 'string') return 'C';
    note = note.trim();
    const flatToSharp = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
    const firstCharUpper = note.charAt(0).toUpperCase();
    const restOfString = note.slice(1);
    const potentialFlat = firstCharUpper + restOfString;
    note = flatToSharp[potentialFlat] || potentialFlat;
    const match = note.match(/^([A-G])(#)?/i); // Match C, C#, G etc.
    if (!match) return 'C';
    return match[1].toUpperCase() + (match[2] || '');
}

function getNoteIndex(note) {
    return NOTES.indexOf(standardizeNoteName(note));
}

function getScaleNotes(root, scaleKey) {
    const scale = SCALES[scaleKey];
    if (!root || !scale || !scale.intervals) return [];
    const rootIndex = getNoteIndex(root);
    if (rootIndex === -1) return [];
    return scale.intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
}

// *** Placeholder: Need getChordTones function ***
// This function should take a root note (e.g., "C") and a quality key (e.g., "maj7")
// and return an array of note names *without octaves* (e.g., ["C", "E", "G", "B"]).
function getChordTones(root, quality) {
    const qualityInfo = CHORD_QUALITIES[quality];
    if (!qualityInfo || !qualityInfo.intervals) {
        console.warn(`Unknown chord quality in getChordTones: ${quality}`);
        return [];
    }
    const rootIndex = getNoteIndex(root);
    if (rootIndex === -1) return [];
    return qualityInfo.intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
}

// *** Placeholder: Need noteNameToMidi function ***
// This function should take a note name with octave (e.g., "C#4")
// and return its MIDI number (e.g., 61). Handle invalid input.
function noteNameToMidi(noteName) {
    const noteMap = { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 };
    const match = noteName.match(/([A-G][#b]?)(-?\d+)/); // Match C#4, Ab-1 etc.
    if (!match) return -1;
    const notePart = standardizeNoteName(match[1]); // Standardize to C#, D# etc.
    const octave = parseInt(match[2], 10);
    const noteVal = noteMap[notePart];
    if (noteVal === undefined) return -1;
    return noteVal + (octave + 1) * 12; // MIDI C4 = 60
}

// *** Placeholder: Need midiToNoteName function ***
// This function should take a MIDI number (e.g., 61)
// and return its note name with octave (e.g., "C#4").
function midiToNoteName(midi) {
    if (midi < 0 || midi > 127) return "Invalid";
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(midi / 12) - 1;
    const noteIndex = midi % 12;
    return noteNames[noteIndex] + octave;
}


function getNoteAtFret(stringNote, fretNumber) {
    const startIndex = getNoteIndex(stringNote);
    if (startIndex === -1) return '?';
    return NOTES[(startIndex + fretNumber) % 12];
}

function isMinorKeyName(key) {
    return key && typeof key === 'string' && key.toLowerCase().endsWith('m');
}

function getQualityValue(qualityString) {
    if (!qualityString) return 'maj';
    const lowerQuality = qualityString.toLowerCase().replace('ø', 'm7b5').replace('°', 'dim7').replace('Δ', 'maj7').replace('min', 'm').replace(/^m$/,'m7').replace(/^maj$/,'maj7'); // Standardize common inputs
    for (const key in CHORD_QUALITIES) {
        // Check against internal key and common name variations
        if (lowerQuality === key || lowerQuality === CHORD_QUALITIES[key].name.toLowerCase() ||
            (key === '7' && lowerQuality === 'dom7') ||
            (key === 'm7' && lowerQuality === 'min7') ||
            (key === 'maj7' && lowerQuality === 'M7') ||
            (key === 'maj' && lowerQuality === '') // Handle empty string as major triad
           ) {
            return key;
        }
    }
    // Fallback for simple major/minor if not found above
    if (lowerQuality === 'm') return 'min';
    if (lowerQuality === '') return 'maj';

    console.warn(`Could not map quality string "${qualityString}" to internal key. Defaulting to maj.`);
    return 'maj'; // Default fallback
}


function suggestScaleForQuality(qualityKey) {
    if (!qualityKey) return 'major';
    if (qualityKey.includes('maj') || qualityKey === '6') return 'major';
    if (qualityKey === '7' || qualityKey === '9' || qualityKey === '13' || qualityKey.includes('sus')) return 'mixolydian';
    if (qualityKey.includes('min') && !qualityKey.includes('b5') && qualityKey !== 'm6') return 'dorian';
    if (qualityKey === 'm7b5') return 'locrian';
    if (qualityKey === 'dim7') return 'diminishedWH';
    if (qualityKey === 'm6') return 'melodicMinor';
    if (qualityKey.includes('alt') || qualityKey.match(/7[b#]\d/)) return 'altered';
    return 'major';
}

// --- Chord/Progression Parsing ---
function getChordFromFunction(romanNumeral, key) {
    if (!romanNumeral || !key) return null;
    const isMinor = isMinorKeyName(key);
    const rootKey = standardizeNoteName(key.replace(/m$/i, ''));
    const rootKeyIndex = NOTES.indexOf(rootKey);
    if (rootKeyIndex === -1) return null;
    const scaleIntervals = isMinor ? SCALES.minor.intervals : SCALES.major.intervals;
    let roman = romanNumeral.trim();
    let prefix = '';
    let qualitySuffix = '';
    let degreeNum = -1;
    if (roman.startsWith('b')) { prefix = 'b'; roman = roman.substring(1); }
    else if (roman.startsWith('#')) { prefix = '#'; roman = roman.substring(1); }
    const qualityRegex = /(maj7|m7b5|dim7|sus4|sus2|add9|madd9|maj9|min9|maj13|min13|7b9|7#9|7b5|7#5|alt|m7|dim|aug|m6|7|6|M7|M|m|ø|°)$/i;
    const qualityMatch = roman.match(qualityRegex);
    if (qualityMatch) { qualitySuffix = qualityMatch[0]; roman = roman.substring(0, roman.length - qualitySuffix.length); }
    const romanMap = { 'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7 };
    const upperRoman = roman.toUpperCase();
    if (romanMap[upperRoman] !== undefined) { degreeNum = romanMap[upperRoman]; }
    else { console.warn(`Could not parse Roman numeral degree: ${roman}`); return null; }
    let degreeIndex = degreeNum - 1;
    let scaleNoteIndex = (rootKeyIndex + scaleIntervals[degreeIndex]) % 12;
    if (prefix === 'b') { scaleNoteIndex = (scaleNoteIndex - 1 + 12) % 12; }
    else if (prefix === '#') { scaleNoteIndex = (scaleNoteIndex + 1) % 12; }
    const chordRoot = NOTES[scaleNoteIndex];
    if (!qualitySuffix) {
        const thirdInterval = (scaleIntervals[(degreeIndex + 2) % 7] - scaleIntervals[degreeIndex] + 12) % 12;
        const fifthInterval = (scaleIntervals[(degreeIndex + 4) % 7] - scaleIntervals[degreeIndex] + 12) % 12;
        const isDiminished = fifthInterval === 6;
        const isAugmented = fifthInterval === 8;

        if (isDiminished) { qualitySuffix = 'dim'; }
        else if (isAugmented) { qualitySuffix = 'aug'; }
        else if (roman === roman.toLowerCase()) { qualitySuffix = 'm'; } // Infer minor from lowercase
        else { qualitySuffix = 'maj'; } // Default to major

        // Default to 7th chords for jazz context if simple triad inferred
        if (qualitySuffix === 'maj') qualitySuffix = 'maj7';
        else if (qualitySuffix === 'm') qualitySuffix = 'm7';
        else if (qualitySuffix === 'dim') qualitySuffix = 'm7b5'; // Often m7b5 for diatonic dim in major/minor
        if (degreeNum === 5 && qualitySuffix === 'maj7') qualitySuffix = '7'; // V chord is dominant 7th
        if (degreeNum === 7 && !isMinor && qualitySuffix === 'm7b5') qualitySuffix = 'm7b5'; // vii in major is m7b5
        if (degreeNum === 2 && isMinor && qualitySuffix === 'm7b5') qualitySuffix = 'm7b5'; // ii in minor is m7b5
    }
    let finalQuality = qualitySuffix.replace(/^maj$/i, '').replace(/^m$/i, 'm').replace(/^M$/i, '').replace(/^M7$/i, 'maj7').replace(/^min7$/i, 'm7').replace(/^dom7$/i, '7').replace('ø', 'm7b5').replace('°', 'dim7');
    // Ensure the quality exists in our CHORD_QUALITIES map
    if (!CHORD_QUALITIES[getQualityValue(finalQuality)]) {
        console.warn(`Parsed quality "${finalQuality}" not found in CHORD_QUALITIES. Defaulting.`);
        // Attempt a reasonable default based on common patterns
        if (finalQuality.includes('m') || finalQuality.includes('min')) finalQuality = 'm7';
        else if (finalQuality.includes('maj') || finalQuality === '') finalQuality = 'maj7';
        else if (finalQuality.includes('dim') || finalQuality.includes('b5')) finalQuality = 'm7b5';
        else finalQuality = '7'; // Default dominant if unsure
    }

    return chordRoot + finalQuality;
}


function formatChordDisplay(chordSymbol) {
    if (!chordSymbol) return "?";
    return chordSymbol
        .replace('maj7', 'Δ7')
        .replace('m7', 'm7') // Keep m7 as is
        .replace('m7b5', 'ø7')
        .replace('dim7', '°7')
        .replace('min', 'm')
        .replace(/^maj$/, '') // Remove trailing 'maj' for triads
        .replace(/^m$/, 'm'); // Ensure simple minor is 'm'
}

// --- DOM Utilities ---
function createKeyOptions(selectedKey = 'C') {
    const standardizedSelected = standardizeNoteName(selectedKey);
    return NOTES.map(note =>
        `<option value="${note}"${note === standardizedSelected ? ' selected' : ''}>${note}</option>`
    ).join('');
}
function createAllKeyOptions(selectedKey = 'C') {
    const keys = [];
    NOTES.forEach(n => keys.push(n));
    NOTES.forEach(n => keys.push(`${n}m`));
    const standardizedSelected = selectedKey;
    return keys.map(key =>
        `<option value="${key}"${key === standardizedSelected ? ' selected' : ''}>${key}</option>`
    ).join('');
}

function createQualityOptions(selectedQuality = 'maj7') {
    const internalSelected = getQualityValue(selectedQuality);
    return Object.entries(CHORD_QUALITIES).map(([key, value]) =>
        `<option value="${key}"${key === internalSelected ? ' selected' : ''}>${value.name}</option>`
    ).join('');
}

function createScaleOptions(selectedScale = 'major') {
    return Object.entries(SCALES).map(([key, value]) =>
        `<option value="${key}"${key === selectedScale ? ' selected' : ''}>${value.name}</option>`
    ).join('');
}

// --- Playback Functions (Single Note) ---

async function playNote(noteNameWithOctave, volume = 1.0, durationMs = 500) {
    const context = await AudioContextManager.ensureAudioContext();
    if (!context || !AudioContextManager.samplesLoaded || volume <= 0) return;
    const match = noteNameWithOctave.match(/^([A-G][#b]?)([0-9])$/);
    if (!match) { console.warn(`Invalid note format for playback: ${noteNameWithOctave}`); return; }
    let note = standardizeNoteName(match[1]);
    const octave = parseInt(match[2]);
    const sampleNote = SAMPLE_NOTE_MAP[note];
    if (!sampleNote) { console.warn(`Cannot map note to sample: ${note}`); return; }
    const sampleKey = `${sampleNote}${octave}`;
    let buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
    let semitoneShift = 0;
    if (!buffer) {
        const lowerOctaveKey = `${sampleNote}${octave - 1}`;
        const higherOctaveKey = `${sampleNote}${octave + 1}`;
        if (AudioContextManager.pianoSampleBuffers[lowerOctaveKey]) {
            buffer = AudioContextManager.pianoSampleBuffers[lowerOctaveKey]; semitoneShift = 12;
        } else if (AudioContextManager.pianoSampleBuffers[higherOctaveKey]) {
            buffer = AudioContextManager.pianoSampleBuffers[higherOctaveKey]; semitoneShift = -12;
        } else { console.warn(`No sample or adjacent octave found for ${sampleKey}`); return; }
    }
    try {
        const source = context.createBufferSource();
        source.buffer = buffer;
        if (semitoneShift !== 0) { source.playbackRate.value = Math.pow(2, semitoneShift / 12); }
        const gainNode = context.createGain();
        const now = context.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
        gainNode.gain.setValueAtTime(volume, now + (durationMs / 1000) - 0.05);
        gainNode.gain.linearRampToValueAtTime(0, now + (durationMs / 1000));
        source.connect(gainNode);
        if (AudioContextManager.reverbNode) {
            const reverbGain = context.createGain(); reverbGain.gain.value = 0.15;
            gainNode.connect(reverbGain); reverbGain.connect(AudioContextManager.reverbNode);
        } else { gainNode.connect(context.destination); }
        source.start(now);
    } catch (error) { console.error(`Error playing note ${noteNameWithOctave}:`, error); }
}

// --- OLD Metronome Sound Function (Keep for reference or if needed by old UI) ---
async function playMetronomeSound(beatVolume, beatIndex, timeSignature) {
    const context = await AudioContextManager.ensureAudioContext();
    if (!context || beatVolume <= 0 || !UI.elements.beatsContainer) return; // Check beatsContainer exists

    const metronomeVolume = parseFloat(UI.elements.metronomeVolume.value);
    const combinedVolume = beatVolume * metronomeVolume;
    if (combinedVolume <= 0) return;

    const soundType = UI.elements.soundType.value;
    const beatElement = UI.elements.beatsContainer.querySelector(`.beat[data-beat="${beatIndex}"]`);
    if (!beatElement) return;

    const soundsToPlay = beatElement.dataset.sound.split(',');
    const isAccent = parseFloat(beatElement.dataset.baseVolume) >= 1.0;
    const accentBoost = parseFloat(UI.elements.accentIntensity.value);
    let finalVolume = isAccent ? Math.min(combinedVolume * accentBoost, 1.0) : combinedVolume;

    for (let soundKey of soundsToPlay) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;
        let buffer, bufferType = soundKey;
        if (soundType === 'drums') {
            const currentSet = drumSoundSets[currentDrumSetIndex];
            const drumBufferKey = `${soundKey}_${currentSet.name}`;
            buffer = AudioContextManager.soundBuffers[drumBufferKey] || AudioContextManager.soundBuffers[soundKey];
        } else { buffer = AudioContextManager.soundBuffers[soundType]; bufferType = soundType; }
        if (!buffer) { buffer = await AudioContextManager.createSynthSound(bufferType); }
        if (!buffer) continue;
        try {
            const source = context.createBufferSource(); source.buffer = buffer;
            const gainNode = context.createGain();
            let volumeAdjustment = 1.0;
            if (soundType === 'drums') {
                if (soundKey === 'hihat' && soundsToPlay.length > 1) volumeAdjustment = 0.6;
                else if (soundKey === 'kick') volumeAdjustment = 1.1;
            }
            gainNode.gain.value = Math.min(finalVolume * volumeAdjustment, 1.0);
            source.connect(gainNode);
            if (soundType === 'drums' && AudioContextManager.reverbNode) {
                const reverbGain = context.createGain(); reverbGain.gain.value = 0.1;
                gainNode.connect(reverbGain); reverbGain.connect(AudioContextManager.reverbNode);
            } else { gainNode.connect(context.destination); }
            source.start(context.currentTime);
        } catch (error) { console.error(`Error playing metronome sound (${soundKey}):`, error); }
    }
}

// --- NEW Metronome Click Function (for new playback loop) ---
async function playMetronomeClick(time, isDownbeat, volume) {
    const context = await AudioContextManager.ensureAudioContext();
    if (!context || volume <= 0) return;

    // Use pre-loaded click sounds or generate simple tones
    const buffer = AudioContextManager.soundBuffers['click'] || await AudioContextManager.createSynthSound('click');
    if (!buffer) return;

    try {
        const source = context.createBufferSource();
        source.buffer = buffer;
        // Optional: Adjust pitch slightly for downbeat
        source.playbackRate.value = isDownbeat ? 1.0 : 0.8;

        const gainNode = context.createGain();
        gainNode.gain.setValueAtTime(volume, time);
        gainNode.gain.linearRampToValueAtTime(0.0001, time + 0.05); // Short click

        source.connect(gainNode);
        gainNode.connect(context.destination);
        source.start(time);
        source.stop(time + 0.05);
    } catch (error) {
        console.error("Error playing metronome click:", error);
    }
}


// --- Fretboard Functions ---
function createFretboard(container, tuningNotes) {
    if (!(container instanceof HTMLElement)) { console.error('Invalid container element for fretboard'); return; }
    if (!Array.isArray(tuningNotes) || tuningNotes.length !== 6) { console.error('Invalid tuning notes provided for fretboard'); return; }
    container.innerHTML = '';
    const numFrets = 12;
    for (let i = 0; i <= numFrets; i++) {
        const fretLine = document.createElement('div'); fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`; container.appendChild(fretLine);
        if (i > 0) {
            const fretNumber = document.createElement('div'); fretNumber.className = 'fret-number';
            fretNumber.textContent = i; fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
            container.appendChild(fretNumber);
        }
    }
    const numStrings = tuningNotes.length;
    for (let i = 0; i < numStrings; i++) {
        const stringLine = document.createElement('div'); stringLine.className = 'string-line';
        stringLine.style.top = `${(i / (numStrings - 1)) * 100}%`; container.appendChild(stringLine);
    }
    const markerPositions = [3, 5, 7, 9, 12];
    markerPositions.forEach(position => {
        if (position > numFrets) return;
        const marker = document.createElement('div'); marker.className = 'fret-marker';
        marker.style.left = `${((position - 0.5) / numFrets) * 100}%`;
        if (position === 12) {
            const topMarker = marker.cloneNode(true); topMarker.style.top = '25%'; container.appendChild(topMarker);
            const bottomMarker = marker.cloneNode(true); bottomMarker.style.top = '75%'; container.appendChild(bottomMarker);
        } else { marker.style.top = '50%'; container.appendChild(marker); }
    });
}

function updateFretboardNotes(container, rootNote, scaleKey, tuningNotes) {
    if (!(container instanceof HTMLElement) || !rootNote || !scaleKey || !tuningNotes) return;
    const scaleInfo = SCALES[scaleKey];
    if (!scaleInfo) { console.warn(`Invalid scale key: ${scaleKey}`); return; }
    container.querySelectorAll('.note').forEach(note => note.remove());

    // Update scale display text
    const displayElement = container.id === 'chord-fretboard' ? UI.elements.scaleDisplay : container.previousElementSibling.previousElementSibling;
    if (displayElement) {
        displayElement.textContent = `${rootNote} ${scaleInfo.name}`;
    }

    const scaleNotesInKey = getScaleNotes(rootNote, scaleKey);
    const standardizedRoot = standardizeNoteName(rootNote);
    const numFrets = 12; const numStrings = tuningNotes.length;
    const baseOctaves = [2, 2, 3, 3, 3, 4]; // Approx EADGBE

    for (let string = 0; string < numStrings; string++) {
        const openStringNote = standardizeNoteName(tuningNotes[string]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);
        if (openStringNoteIndex === -1) continue;
        for (let fret = 0; fret <= numFrets; fret++) {
            const noteIndex = (openStringNoteIndex + fret) % 12;
            const currentNote = NOTES[noteIndex];
            if (scaleNotesInKey.includes(currentNote)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note'; noteElement.textContent = currentNote;
                const fretOffset = fret === 0 ? 2 : ((fret - 0.5) / numFrets) * 100;
                noteElement.style.left = `${fretOffset}%`; noteElement.style.top = `${(string / (numStrings - 1)) * 100}%`;
                let octave = baseOctaves[string] + Math.floor((openStringNoteIndex + fret) / 12);
                octave = Math.max(2, Math.min(5, octave)); // Clamp octave 2-5
                noteElement.dataset.note = `${currentNote}${octave}`;
                const degreeIndex = scaleInfo.intervals.findIndex(interval => (getNoteIndex(rootNote) + interval) % 12 === noteIndex);
                if (currentNote === standardizedRoot) { noteElement.classList.add('root'); }
                else if ([2, 4, 6].includes(degreeIndex)) { noteElement.classList.add('degree-2-4-6'); }
                attachSingleNoteClickHandler(noteElement, container.id);
                container.appendChild(noteElement);
            }
        }
    }
}

function attachSingleNoteClickHandler(noteElement, fretboardId) {
     noteElement.addEventListener('click', async (e) => {
        e.stopPropagation();
        const noteToPlay = noteElement.dataset.note;
        if (noteToPlay) {
            try {
                let volume = 0.5;
                if (fretboardId === 'chord-fretboard' && UI.elements.chordFretboardVolume) {
                    volume = parseFloat(UI.elements.chordFretboardVolume.value);
                } else if (fretboardId.startsWith('fretflow-fretboard') && UI.elements.fretboardVolume) {
                    volume = parseFloat(UI.elements.fretboardVolume.value);
                }
                await playNote(noteToPlay, volume, 500);
                noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                setTimeout(() => { noteElement.style.transform = 'translate(-50%, -50%) scale(1)'; }, 150);
            } catch (error) { console.error('Error playing note from fretboard:', error); }
        }
    });
    noteElement.addEventListener('mouseenter', () => { noteElement.style.transform = 'translate(-50%, -50%) scale(1.15)'; });
    noteElement.addEventListener('mouseleave', () => { noteElement.style.transform = 'translate(-50%, -50%) scale(1)'; });
}

// --- Metronome Beat Functions (OLD UI - Keep or Remove?) ---
// These functions manage the clickable beat divs. They are separate from the NEW playback loop.
// Decide if you want to keep this UI or rely solely on the new playback system.
function createBeats() {
    const container = UI.elements.beatsContainer;
    if (!container) return;
    container.innerHTML = '';
    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value;
    let beatsPerMeasure, subdivision = 1;
    if ([2, 3, 4].includes(timeSignature)) { beatsPerMeasure = timeSignature; if (timeSignature === 4) subdivision = 2; }
    else if ([6, 12].includes(timeSignature)) { beatsPerMeasure = timeSignature / 3; subdivision = 3; }
    else { beatsPerMeasure = timeSignature; subdivision = 1; }
    const totalDivisions = beatsPerMeasure * subdivision;
    let strongBeats = [0];
    if (timeSignature === 4) strongBeats = [0, 4]; // 8th note indices
    if (timeSignature === 6) strongBeats = [0, 3]; // Triplet indices
    if (timeSignature === 12) strongBeats = [0, 6];
    for (let i = 0; i < totalDivisions; i++) {
        const beat = document.createElement('div'); beat.className = 'beat'; beat.dataset.beat = i;
        const mainBeatNumber = Math.floor(i / subdivision) + 1; const subBeatNumber = (i % subdivision);
        if (subdivision === 1) { beat.textContent = mainBeatNumber; }
        else if (subdivision === 2) { beat.textContent = `${mainBeatNumber}${subBeatNumber === 0 ? '' : '&'}`; }
        else if (subdivision === 3) { beat.textContent = `${mainBeatNumber}${subBeatNumber === 0 ? '' : (subBeatNumber === 1 ? 'la' : 'li')}`; }
        const isStrong = strongBeats.includes(i);
        let defaultSound = 'silent', defaultVolume = '0', defaultColor = '#9E9E9E';
        if (soundType === 'drums') {
            if (i % subdivision === 0) { defaultSound = isStrong ? 'kick,hihat' : 'snare,hihat'; defaultVolume = isStrong ? '1.0' : '0.8'; defaultColor = isStrong ? '#1F618D' : '#4CAF50'; }
            else { defaultSound = 'hihat'; defaultVolume = '0.6'; defaultColor = '#777777'; }
            if (timeSignature === 4) {
                 if (i === 0 || i === 4) { defaultSound = 'kick,hihat'; defaultVolume = '1.0'; defaultColor = '#1F618D'; }
                 else if (i === 2 || i === 6) { defaultSound = 'snare,hihat'; defaultVolume = '1.0'; defaultColor = '#4CAF50'; }
                 else { defaultSound = 'hihat'; defaultVolume = '0.6'; defaultColor = '#777777'; }
             }
        } else { if (i % subdivision === 0) { defaultSound = soundType; defaultVolume = isStrong ? '1.0' : '0.5'; defaultColor = isStrong ? '#1F618D' : '#4CAF50'; } }
        beat.dataset.sound = defaultSound; beat.dataset.baseVolume = defaultVolume; beat.dataset.volume = defaultVolume; beat.style.backgroundColor = defaultColor;
        beat.addEventListener('click', () => toggleBeatState(beat, soundType, subdivision));
        container.appendChild(beat);
    }
}

function toggleBeatState(beat, soundType, subdivision) {
    const currentVolume = parseFloat(beat.dataset.volume); const currentSound = beat.dataset.sound;
    const isMainBeat = parseInt(beat.dataset.beat) % subdivision === 0;
    let states = [];
    if (soundType === 'drums') { states = [ { volume: '1.0', sound: 'kick,hihat', color: '#1F618D' }, { volume: '1.0', sound: 'snare,hihat', color: '#4CAF50' }, { volume: '0.6', sound: 'hihat', color: '#777777' }, { volume: '0', sound: 'silent', color: '#9E9E9E' } ]; }
    else { states = [ { volume: '1.0', sound: soundType, color: '#1F618D' }, { volume: '0.5', sound: soundType, color: '#4CAF50' }, { volume: '0', sound: 'silent', color: '#9E9E9E' } ]; if (!isMainBeat) { states = [{ volume: '0', sound: 'silent', color: '#9E9E9E' }]; } }
    let currentIndex = states.findIndex(state => state.sound === currentSound && parseFloat(state.volume) === currentVolume);
    if (currentIndex === -1) currentIndex = states.length - 1;
    const nextState = states[(currentIndex + 1) % states.length];
    beat.dataset.volume = nextState.volume; beat.dataset.sound = nextState.sound; beat.dataset.baseVolume = nextState.volume; beat.style.backgroundColor = nextState.color;
}

// --- Main Playback Loop (OLD - Remove or Comment Out) ---
/*
async function playBeat() {
    // This entire function is replaced by the new startPlayback/scheduler logic
    // ... (old code that used AppState.currentBeat, AppState.currentMeasure, etc.) ...
}
*/

// --- NEW Playback Loop Functions ---

function startPlayback() {
    // Ensure audio context is ready
    AudioContextManager.ensureAudioContext().then(context => {
        if (!context) {
            console.error("Cannot start playback, audio context not available.");
            return;
        }
        if (context.state === 'suspended') {
            context.resume();
        }

        if (currentPlaybackIntervalId !== null) {
            stopPlayback(); // Stop existing playback first
        }
        log("Starting playback...");
        AppState.isPlaying = true; // Set playing state

        const bpm = parseInt(UI.elements.tempo.value, 10);
        // Time signature parsing (assuming format like "4/4")
        const timeSigParts = UI.elements.timeSignature.value.split('/');
        const beatsPerMeasure = parseInt(timeSigParts[0], 10) || 4;
        // Use 8th note subdivision for timing flexibility
        const subdivision = 8;
        const intervalSeconds = (60 / bpm) / (subdivision / 4); // Time per 8th note

        let currentMeasureIndex = 0;
        let currentSubdivision = 0; // 0 to 7 for 8th notes in 4/4
        let nextNoteTime = context.currentTime + 0.1; // Start scheduling slightly ahead

        // Get progression from the measure divs
        const progressionDivs = UI.elements.progressionContainer.querySelectorAll('.measure');
        const progression = Array.from(progressionDivs).map(div => {
            // Assuming chord symbol is stored in dataset or derived from controls
            const root = div.querySelector('.root-note')?.value;
            const quality = div.querySelector('.chord-quality')?.value; // Internal quality key
            const symbol = root && quality ? `${root}${CHORD_QUALITIES[quality]?.name || quality}` : "N.C.";
            return { symbol: symbol, root: root, quality: quality }; // Store root and internal quality key
        });

        if (progression.length === 0) {
            log("Progression is empty. Nothing to play.");
            stopPlayback(); // Ensure state is reset
            return;
        }

        // Get UI settings for playback options
        selectedRhythmPattern = UI.elements.rhythmPatternSelect?.value || 'downbeats';
        twoChordsPerMeasureEnabled = UI.elements.twoChordsCheckbox?.checked || false;
        selectedVoicingType = UI.elements.voicingTypeSelect?.value || 'standard';
        const metronomeVolume = parseFloat(UI.elements.metronomeVolume.value);

        const scheduler = () => {
            if (!AppState.isPlaying) return; // Stop scheduling if stop button was pressed

            while (nextNoteTime < context.currentTime + 0.15) { // Schedule notes further ahead
                // Calculate current beat position (1-based quarter note beat)
                const currentQuarterBeat = (currentSubdivision / (subdivision / 4)) + 1;

                // Metronome Click (on quarter notes)
                if (currentSubdivision % (subdivision / 4) === 0 && metronomeVolume > 0) {
                     const isDownbeat = currentSubdivision === 0;
                     playMetronomeClick(nextNoteTime, isDownbeat, metronomeVolume);
                }

                // Chord Playback
                const measureData = progression[currentMeasureIndex];
                if (measureData.root && measureData.quality && AppState.chordsPlaybackEnabled) {
                    let playThisSubdivision = false;
                    let voicingTypeForThisChord = selectedVoicingType;

                    const pattern = rhythmPatterns[selectedRhythmPattern] || rhythmPatterns['downbeats'];
                    // Check if currentQuarterBeat matches a beat in the pattern
                    if (pattern.includes(currentQuarterBeat)) {
                         playThisSubdivision = true;
                    }

                    // Handle Two Chords Per Measure (assuming 4/4)
                    if (twoChordsPerMeasureEnabled && beatsPerMeasure === 4) {
                        const beatThreshold = 3; // Play second chord on beat 3
                        if (currentQuarterBeat >= beatThreshold && pattern.includes(currentQuarterBeat)) {
                             // Apply random inversion for the second chord
                             const dropTypes = ['drop2', 'drop3', 'drop24'];
                             voicingTypeForThisChord = dropTypes[Math.floor(Math.random() * dropTypes.length)];
                             // console.log(`Applying random inversion: ${voicingTypeForThisChord} for beat ${currentQuarterBeat}`);
                        } else if (currentQuarterBeat < beatThreshold && pattern.includes(currentQuarterBeat)) {
                             voicingTypeForThisChord = selectedVoicingType; // First chord uses selected type
                        } else {
                             playThisSubdivision = false; // Don't play if beat not in pattern or wrong part of measure
                        }
                    } else {
                         voicingTypeForThisChord = selectedVoicingType; // Use selected type if not two chords/measure
                    }

                    // If this subdivision should trigger a chord
                    if (playThisSubdivision) {
                        const voicing = getChordVoicing(measureData.root, measureData.quality, voicingTypeForThisChord);
                        if (voicing && voicing.length > 0) {
                            // Calculate duration based on rhythm pattern
                            let duration = intervalSeconds * (subdivision / 4) * 1.8; // Default: ~2 quarter notes
                            // Adjust duration based on pattern? (e.g., shorter for faster rhythms)
                            playChord(voicing, duration, nextNoteTime);
                        }
                    }
                }

                // Advance Time and Counters
                nextNoteTime += intervalSeconds;
                currentSubdivision++;
                if (currentSubdivision >= beatsPerMeasure * (subdivision / 4)) {
                    currentSubdivision = 0;
                    currentMeasureIndex = (currentMeasureIndex + 1) % progression.length;
                    // Update visual indicator for the current measure
                    highlightCurrentMeasure(currentMeasureIndex);
                    // Update main fretboard display for the new measure
                    syncFretboardWithMeasure(progressionDivs[currentMeasureIndex]);
                }
            }
            // Schedule the next check
            currentPlaybackIntervalId = setTimeout(scheduler, 50); // Check every 50ms
        };

        // Initial setup before starting scheduler
        highlightCurrentMeasure(currentMeasureIndex);
        syncFretboardWithMeasure(progressionDivs[currentMeasureIndex]);
        scheduler(); // Start the loop

        // Update button state
        if (UI.elements.startStopButton) {
            UI.elements.startStopButton.textContent = 'Stop';
            // Remove old listener and add new one to prevent multiple bindings
            const newButton = UI.elements.startStopButton.cloneNode(true);
            UI.elements.startStopButton.parentNode.replaceChild(newButton, UI.elements.startStopButton);
            UI.elements.startStopButton = newButton; // Update reference
            UI.elements.startStopButton.addEventListener('click', stopPlayback);
        }

    }).catch(error => {
        console.error("Error ensuring audio context for playback:", error);
        alert("Could not start playback. Audio system might not be ready.");
    });
}

function stopPlayback() {
    if (currentPlaybackIntervalId !== null) {
        clearTimeout(currentPlaybackIntervalId);
        currentPlaybackIntervalId = null;
    }
    AppState.isPlaying = false; // Set playing state
    log("Playback stopped.");

    // Reset button state
     if (UI.elements.startStopButton) {
        UI.elements.startStopButton.textContent = 'Play';
        // Remove old listener and add new one to prevent multiple bindings
        const newButton = UI.elements.startStopButton.cloneNode(true);
        UI.elements.startStopButton.parentNode.replaceChild(newButton, UI.elements.startStopButton);
        UI.elements.startStopButton = newButton; // Update reference
        UI.elements.startStopButton.addEventListener('click', startPlayback);
    }
    // Remove measure highlight
    highlightCurrentMeasure(-1);
    // Optional: Stop any currently sounding notes (more complex, involves tracking sources)
}

// --- Helper function to parse chord symbols (ensure this exists and is robust) ---
function parseChordSymbol(symbol) {
    // This function needs to return [root, qualityKey] where qualityKey matches CHORD_QUALITIES
    if (!symbol || symbol === "N.C.") return [null, null];
    const rootMatch = symbol.match(/^[A-G][#b]?/);
    if (!rootMatch) return [null, null];
    const root = standardizeNoteName(rootMatch[0]);
    const qualityString = symbol.substring(root.length).trim();
    const qualityKey = getQualityValue(qualityString); // Use the mapping function

    if (!CHORD_QUALITIES[qualityKey]) {
         console.warn(`Unknown chord quality: ${qualityString} (mapped to ${qualityKey}) for root ${root}. Treating as N.C.`);
         return [null, null];
    }
    return [root, qualityKey];
}


// --- Helper function to highlight the current measure ---
function highlightCurrentMeasure(measureIndex) {
    const measures = UI.elements.progressionContainer?.querySelectorAll('.measure');
    if (!measures) return;
    measures.forEach((measure, index) => {
        if (index === measureIndex) {
            measure.classList.add('playing'); // Use 'playing' class
        } else {
            measure.classList.remove('playing');
        }
    });
}

// --- Chord Progression Management ---
function loadProgression(progressionName, overrideKey = null) {
    const measuresContainer = UI.elements.progressionContainer; // Use the correct container
    if (!measuresContainer) { console.error("Progression container not found!"); return; }

    if (!progressionName || !progressions[progressionName]) {
        if (progressionName === "") {
            measuresContainer.innerHTML = ''; addMeasure(); log("Cleared progression.");
        } else { console.error(`Invalid progression name: ${progressionName}`); }
        return;
    }
    const progressionData = progressions[progressionName];
    const selectedKey = overrideKey || progressionData.defaultKey || "C";
    UI.elements.keySelect.value = selectedKey;
    measuresContainer.innerHTML = '';
    log(`Loading progression "${progressionName}" in key: ${selectedKey}`);
    progressionData.progression.forEach((chordFunction, index) => {
        try {
            const chordSymbol = getChordFromFunction(chordFunction, selectedKey);
            if (!chordSymbol) {
                console.warn(`Failed to parse chord function: ${chordFunction} in key ${selectedKey}`);
                addMeasure('C', 'maj7', 'C', 'major', index + 1); return;
            }
            const [root, qualityKey] = parseChordSymbol(chordSymbol); // Use parseChordSymbol
            if (!root || !qualityKey) {
                 console.warn(`Failed to parse resulting symbol: ${chordSymbol}`);
                 addMeasure('C', 'maj7', 'C', 'major', index + 1); return;
            }
            const suggestedScale = suggestScaleForQuality(qualityKey);
            addMeasure(root, qualityKey, root, suggestedScale, index + 1, chordFunction);
        } catch (error) {
            console.error(`Error processing chord ${chordFunction} at index ${index}:`, error);
            addMeasure('C', 'maj7', 'C', 'major', index + 1);
        }
    });
    if (measuresContainer.children.length === 0) { addMeasure(); }
    updateMeasureNumbers();
    syncFretboardWithMeasure(measuresContainer.firstElementChild);
}

function updateProgressionKey(newKey) {
    log(`Updating progression to key: ${newKey}`);
    const measuresContainer = UI.elements.progressionContainer;
    Array.from(measuresContainer.children).forEach((measure) => {
        const chordFunc = measure.dataset.chordFunction;
        let root, qualityKey, suggestedScale;
        if (chordFunc) {
            const chordSymbol = getChordFromFunction(chordFunc, newKey);
            if (chordSymbol) {
                [root, qualityKey] = parseChordSymbol(chordSymbol);
                if (!root || !qualityKey) { // Fallback if parsing fails
                    root = measure.querySelector('.root-note').value;
                    qualityKey = measure.querySelector('.chord-quality').value;
                }
                suggestedScale = suggestScaleForQuality(qualityKey);
            } else { /* Keep existing values if function fails */
                root = measure.querySelector('.root-note').value;
                qualityKey = measure.querySelector('.chord-quality').value;
                suggestedScale = measure.querySelector('.scale-select').value;
            }
        } else { /* Manual measure - don't transpose, just update suggestions */
             root = measure.querySelector('.root-note').value;
             qualityKey = measure.querySelector('.chord-quality').value;
             suggestedScale = suggestScaleForQuality(qualityKey);
        }
        const rootSelect = measure.querySelector('.root-note');
        const qualitySelect = measure.querySelector('.chord-quality');
        const secondKeySelect = measure.querySelector('.second-key');
        const scaleSelect = measure.querySelector('.scale-select');
        if (rootSelect) rootSelect.value = standardizeNoteName(root);
        if (qualitySelect) qualitySelect.value = qualityKey;
        if (secondKeySelect) secondKeySelect.value = standardizeNoteName(root);
        if (scaleSelect) scaleSelect.value = suggestedScale;
    });
    syncFretboardWithMeasure(measuresContainer.firstElementChild);
}

function addMeasure(root = 'C', quality = 'maj7', scaleRoot = 'C', scaleType = 'major', measureNum = null, chordFunction = null) {
    const measuresContainer = UI.elements.progressionContainer;
    if (!measuresContainer) return;
    const measure = document.createElement('div');
    measure.className = 'measure'; measure.draggable = true;
    const currentMeasureCount = measuresContainer.children.length;
    const number = measureNum !== null ? measureNum : currentMeasureCount + 1;
    if (chordFunction) { measure.dataset.chordFunction = chordFunction; }
    measure.innerHTML = `
        <span class="measure-number">${number}</span>
        <div class="chord-controls">
            <select class="root-note" aria-label="Chord Root">${createKeyOptions(root)}</select>
            <select class="chord-quality" aria-label="Chord Quality">${createQualityOptions(quality)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key" aria-label="Scale Root">${createKeyOptions(scaleRoot)}</select>
            <select class="scale-select" aria-label="Scale Type">${createScaleOptions(scaleType)}</select>
        </div>
        <button class="remove-measure-btn" aria-label="Remove measure ${number}">×</button>
    `;
    measuresContainer.appendChild(measure);
    measure.addEventListener('dragstart', dragStart); measure.addEventListener('dragover', dragOver);
    measure.addEventListener('drop', drop); measure.addEventListener('dragend', dragEnd);
    measure.querySelectorAll('select').forEach(select => { select.addEventListener('change', () => updateMeasureState(measure)); });
    measure.querySelector('.remove-measure-btn').addEventListener('click', () => {
        measure.remove();
        updateMeasureNumbers();
        log(`Removed measure`);
        syncFretboardWithMeasure(measuresContainer.firstElementChild);
    });
    if (measureNum === null) { log(`Added measure ${number}`); updateMeasureNumbers(); }
}

function removeMeasure() { // Keep this function to remove the *last* measure via button if needed
    const measuresContainer = UI.elements.progressionContainer;
    const measures = measuresContainer.children;
    if (measures.length > 1) {
        measures[measures.length - 1].remove(); updateMeasureNumbers(); log(`Removed last measure`);
        syncFretboardWithMeasure(measuresContainer.firstElementChild);
    } else { alert("Cannot remove the last measure."); }
}

function updateMeasureNumbers() {
    const measuresContainer = UI.elements.progressionContainer;
    Array.from(measuresContainer.children).forEach((measure, index) => {
        const numberElement = measure.querySelector('.measure-number');
        if (numberElement) numberElement.textContent = index + 1;
        const removeBtn = measure.querySelector('.remove-measure-btn');
        if(removeBtn) removeBtn.setAttribute('aria-label', `Remove measure ${index + 1}`);
    });
}

function syncFretboardWithMeasure(measure) {
    if (!measure) {
        UI.elements.scaleDisplay.textContent = "---";
        const defaultTuning = TUNINGS[UI.elements.chordTuning.value]?.notes || TUNINGS.standard.notes;
        updateFretboardNotes(UI.elements.chordFretboard, 'C', 'major', defaultTuning);
        return;
    }
    const scaleRoot = measure.querySelector('.second-key')?.value;
    const scaleType = measure.querySelector('.scale-select')?.value;
    const tuning = TUNINGS[UI.elements.chordTuning.value]?.notes;
    if (scaleRoot && scaleType && tuning) {
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }
}

function updateMeasureState(measure) {
    const rootNote = measure.querySelector('.root-note').value;
    const quality = measure.querySelector('.chord-quality').value;
    const scaleRoot = measure.querySelector('.second-key').value;
    const scaleType = measure.querySelector('.scale-select').value;
    // Auto-sync scale root to chord root
    measure.querySelector('.second-key').value = rootNote;
    // Auto-suggest scale based on new quality
    measure.querySelector('.scale-select').value = suggestScaleForQuality(quality);

    const measureIndex = Array.from(UI.elements.progressionContainer.children).indexOf(measure);
    // Update main fretboard only if it's the currently highlighted measure during playback, or the first measure if stopped
    const currentPlayingMeasureIndex = Array.from(UI.elements.progressionContainer.children).findIndex(m => m.classList.contains('playing'));
    if (measureIndex === 0 || measureIndex === currentPlayingMeasureIndex) {
        syncFretboardWithMeasure(measure);
    }
    // log(`Measure ${measureIndex + 1} updated: ${rootNote}${CHORD_QUALITIES[quality]?.name || quality}, Scale: ${scaleRoot} ${SCALES[scaleType]?.name || scaleType}`);
}

// --- Drag and Drop Handlers ---
let draggedElement = null;
function dragStart(e) {
    draggedElement = e.target.closest('.measure');
    if (!draggedElement) return;
    const index = Array.from(UI.elements.progressionContainer.children).indexOf(draggedElement);
    e.dataTransfer.setData('text/plain', index); e.dataTransfer.effectAllowed = 'move';
    setTimeout(() => draggedElement.classList.add('dragging'), 0);
    // log(`Dragging measure ${index + 1}`);
}
function dragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
function drop(e) {
    e.preventDefault();
    const targetElement = e.target.closest('.measure');
    if (!targetElement || targetElement === draggedElement || !draggedElement) return;
    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
    const targetIndex = Array.from(UI.elements.progressionContainer.children).indexOf(targetElement);
    // log(`Dropping measure from index ${draggedIndex} to index ${targetIndex}`);
    if (draggedIndex < targetIndex) { targetElement.parentNode.insertBefore(draggedElement, targetElement.nextSibling); }
    else { targetElement.parentNode.insertBefore(draggedElement, targetElement); }
    updateMeasureNumbers(); syncFretboardWithMeasure(UI.elements.progressionContainer.firstElementChild);
}
function dragEnd(e) { if (draggedElement) { draggedElement.classList.remove('dragging'); } draggedElement = null; }

// --- FretFlow (Multiple Fretboards) ---
function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) return;
    fretboardsGrid.innerHTML = ''; log("Initializing FretFlow section...");
    for (let i = 0; i < 4; i++) {
        const fretboardSection = document.createElement('div'); fretboardSection.className = 'fretboard-section';
        fretboardSection.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group"><label for="fretflow-key-${i}">Key:</label><select id="fretflow-key-${i}" class="fretflow-key">${createKeyOptions(NOTES[i * 3])}</select></div>
                <div class="control-group"><label for="fretflow-scale-${i}">Scale:</label><select id="fretflow-scale-${i}" class="fretflow-scale">${createScaleOptions(Object.keys(SCALES)[i])}</select></div>
                <div class="control-group"><label for="fretflow-tuning-${i}">Tuning:</label><select id="fretflow-tuning-${i}" class="tuning-select">${Object.entries(TUNINGS).map(([key, value]) => `<option value="${key}" ${key === 'standard' ? 'selected' : ''}>${value.name}</option>`).join('')}</select></div>
            </div>
            <div class="scale-display"></div>
            <div id="fretflow-fretboard-${i}" class="fretboard"></div>`;
        fretboardsGrid.appendChild(fretboardSection);
        const fretboardContainer = fretboardSection.querySelector(`#fretflow-fretboard-${i}`);
        const keySelect = fretboardSection.querySelector(`#fretflow-key-${i}`);
        const scaleSelect = fretboardSection.querySelector(`#fretflow-scale-${i}`);
        const tuningSelect = fretboardSection.querySelector(`#fretflow-tuning-${i}`);
        const updateThisFretboard = () => {
            try {
                const selectedKey = keySelect.value; const selectedScale = scaleSelect.value;
                const selectedTuningKey = tuningSelect.value; const selectedTuningNotes = TUNINGS[selectedTuningKey]?.notes;
                if (!selectedTuningNotes) { console.error(`Invalid tuning selected: ${selectedTuningKey}`); return; }
                createFretboard(fretboardContainer, selectedTuningNotes);
                updateFretboardNotes(fretboardContainer, selectedKey, selectedScale, selectedTuningNotes);
            } catch (error) { console.error(`Error updating FretFlow fretboard ${i}:`, error); }
        };
        keySelect.addEventListener('change', updateThisFretboard);
        scaleSelect.addEventListener('change', updateThisFretboard);
        tuningSelect.addEventListener('change', updateThisFretboard);
        updateThisFretboard(); // Initial render
    }
     log("FretFlow initialized with 4 independent fretboards.");
}

// --- Event Listeners Setup ---
function setupEventListeners() {
    log("Setting up event listeners...");
    const initializeAudioInteraction = async () => {
        try { await AudioContextManager.ensureAudioContext();
            document.body.removeEventListener('click', initializeAudioInteraction);
            document.body.removeEventListener('touchstart', initializeAudioInteraction);
            log("Audio interaction listener removed.");
        } catch (error) { console.error('Failed to initialize audio on interaction:', error); }
    };
    document.body.addEventListener('click', initializeAudioInteraction, { once: false });
    document.body.addEventListener('touchstart', initializeAudioInteraction, { once: false });

    // Main Play/Stop Button (assuming ID 'start-stop')
    if (UI.elements.startStopButton) {
        // Initial setup for the button
        UI.elements.startStopButton.textContent = 'Play';
        UI.elements.startStopButton.removeEventListener('click', startPlayback); // Remove potential old listeners
        UI.elements.startStopButton.removeEventListener('click', stopPlayback);
        UI.elements.startStopButton.addEventListener('click', startPlayback); // Add listener for starting
    } else {
        console.warn("Main Play/Stop button (#start-stop) not found.");
    }


    if(UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.addEventListener('click', () => {
        currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
        UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
        log(`Switched to drum set: ${drumSoundSets[currentDrumSetIndex].name}`);
    });

    if(UI.elements.soundType) UI.elements.soundType.addEventListener('change', (e) => {
        const isDrums = e.target.value === 'drums';
        if(UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.style.display = isDrums ? 'inline-block' : 'none';
        if (isDrums && UI.elements.drumSetToggleBtn) { UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name; }
        createBeats(); log(`Metronome sound type changed to: ${e.target.value}`);
    });

    if(UI.elements.darkModeToggle) UI.elements.darkModeToggle.addEventListener('click', () => {
        AppState.darkMode = (AppState.darkMode + 1) % 4;
        document.body.className = ''; // Clear all classes first
        UI.elements.darkModeToggle.className = 'button'; // Reset button class
        UI.elements.darkModeToggle.textContent = "Theme";
        const themes = ['', 'dark-mode', 'dark-mode-2', 'dark-mode-3'];
        const buttonClasses = ['', 'active', 'active-2', 'active-3'];
        const buttonTexts = ['Light Mode', 'Theme 1', 'Theme 2', 'Theme 3'];
        if (AppState.darkMode > 0) document.body.classList.add(themes[AppState.darkMode]);
        UI.elements.darkModeToggle.classList.add(buttonClasses[AppState.darkMode]);
        UI.elements.darkModeToggle.textContent = buttonTexts[AppState.darkMode];
        log(`${buttonTexts[AppState.darkMode]} enabled`);
    });

    if(UI.elements.chordsEnabled) UI.elements.chordsEnabled.addEventListener('click', () => {
        AppState.chordsPlaybackEnabled = !AppState.chordsPlaybackEnabled;
        UI.elements.chordsEnabled.textContent = AppState.chordsPlaybackEnabled ? 'Chords ON' : 'Chords OFF';
        UI.elements.chordsEnabled.classList.toggle('active', AppState.chordsPlaybackEnabled);
        log(`Chords playback ${AppState.chordsPlaybackEnabled ? 'enabled' : 'disabled'}`);
    });

    const tempoUpdateDebounced = debounce(() => { log("Tempo changed."); }, 200);
    if(UI.elements.tempo) UI.elements.tempo.addEventListener('input', () => {
        AppState.tempo = parseInt(UI.elements.tempo.value);
        if(UI.elements.tempoDisplay) UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        tempoUpdateDebounced();
    });

    let tapTimestamps = [];
    if(UI.elements.tapTempo) UI.elements.tapTempo.addEventListener('click', () => {
        const now = performance.now(); tapTimestamps.push(now);
        tapTimestamps = tapTimestamps.filter(ts => now - ts < 5000);
        if (tapTimestamps.length > 4) { tapTimestamps.shift(); }
        if (tapTimestamps.length >= 2) {
            let totalInterval = 0;
            for (let i = 1; i < tapTimestamps.length; i++) { totalInterval += tapTimestamps[i] - tapTimestamps[i - 1]; }
            const avgInterval = totalInterval / (tapTimestamps.length - 1);
            if (avgInterval > 0) {
                const bpm = Math.round(60000 / avgInterval);
                AppState.tempo = Math.max(40, Math.min(240, bpm));
                if(UI.elements.tempo) UI.elements.tempo.value = AppState.tempo;
                if(UI.elements.tempoDisplay) UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                log(`Tap tempo calculated: ${AppState.tempo} BPM`);
                tempoUpdateDebounced();
            }
        }
        UI.elements.tapTempo.style.transform = 'scale(1.1)';
        setTimeout(() => UI.elements.tapTempo.style.transform = 'scale(1)', 100);
    });

    if(UI.elements.timeSignature) UI.elements.timeSignature.addEventListener('change', () => {
        log(`Time signature changed to: ${UI.elements.timeSignature.options[UI.elements.timeSignature.selectedIndex].text}`);
        createBeats();
        if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
    });

    // Volume controls (optional logging)
    // ['metronomeVolume', 'chordFretboardVolume', 'chordVolume', 'fretboardVolume', 'accentIntensity'].forEach(id => {
    //     if (UI.elements[id]) UI.elements[id].addEventListener('input', () => log(`${id}: ${UI.elements[id].value}`));
    // });

    if(UI.elements.progressionSelect) UI.elements.progressionSelect.addEventListener('change', () => {
        loadProgression(UI.elements.progressionSelect.value);
    });

    if(UI.elements.keySelect) UI.elements.keySelect.addEventListener('change', () => {
        updateProgressionKey(UI.elements.keySelect.value);
    });

    if(UI.elements.chordTuning) UI.elements.chordTuning.addEventListener('change', () => {
        log(`Main fretboard tuning changed to: ${UI.elements.chordTuning.value}`);
        syncFretboardWithMeasure(UI.elements.progressionContainer?.firstElementChild);
    });

    // Event delegation for measure control changes
    if(UI.elements.progressionContainer) UI.elements.progressionContainer.addEventListener('change', (e) => {
        if (e.target.tagName === 'SELECT') {
            const measureElement = e.target.closest('.measure');
            if (measureElement) { updateMeasureState(measureElement); }
        }
    });

    // Add listeners for NEW playback controls if they exist
    if(UI.elements.rhythmPatternSelect) UI.elements.rhythmPatternSelect.addEventListener('change', (e) => {
        selectedRhythmPattern = e.target.value;
        log(`Rhythm pattern changed to: ${selectedRhythmPattern}`);
        // If playing, the loop will pick up the change. No restart needed.
    });
    if(UI.elements.twoChordsCheckbox) UI.elements.twoChordsCheckbox.addEventListener('change', (e) => {
        twoChordsPerMeasureEnabled = e.target.checked;
        log(`Two chords per measure: ${twoChordsPerMeasureEnabled}`);
    });
    if(UI.elements.voicingTypeSelect) UI.elements.voicingTypeSelect.addEventListener('change', (e) => {
        selectedVoicingType = e.target.value;
        log(`Voicing type changed to: ${selectedVoicingType}`);
    });


    log("Event listeners set up complete.");
}

// --- Initialization ---
async function initializeApp() {
    log("Initializing Bebop Blueprint...");
    updateLoadingStatus("Initializing UI...", true);
    UI.init();

    if(UI.elements.keySelect) UI.elements.keySelect.innerHTML = createAllKeyOptions('C');
    // Add default measure container if missing
    if (!UI.elements.progressionContainer && UI.elements.measures) {
        UI.elements.progressionContainer = UI.elements.measures; // Use 'measures' as container if 'progression-container' missing
        log("Using #measures as progression container.");
    } else if (!UI.elements.progressionContainer) {
         console.error("Cannot initialize: Progression container not found (#progression-container or #measures).");
         updateLoadingStatus("Error: Missing progression container!", true);
         return;
    }


    updateLoadingStatus("Creating initial UI components...");
    createBeats();
    const initialTuning = TUNINGS[UI.elements.chordTuning?.value || 'standard']?.notes || TUNINGS.standard.notes;
    if(UI.elements.chordFretboard) createFretboard(UI.elements.chordFretboard, initialTuning);

    updateLoadingStatus("Loading default progression...");
    loadProgression(UI.elements.progressionSelect?.value || "2_5_1");

    updateLoadingStatus("Initializing FretFlow...");
    initializeFretFlow();

    updateLoadingStatus("Setting up interactions...");
    setupEventListeners();

    if(UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.style.display = UI.elements.soundType?.value === 'drums' ? 'inline-block' : 'none';
        if (UI.elements.soundType?.value === 'drums') { UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name; }
    }
    // Set initial state for chord toggle button
    if(UI.elements.chordsEnabled) {
        UI.elements.chordsEnabled.textContent = AppState.chordsPlaybackEnabled ? 'Chords ON' : 'Chords OFF';
        UI.elements.chordsEnabled.classList.toggle('active', AppState.chordsPlaybackEnabled);
    }


    setTimeout(() => {
        updateLoadingStatus("Ready!", false);
        log("Application initialized successfully.");
    }, 200);
}

// --- Run Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Application Initialization Failed:", error);
        updateLoadingStatus("Initialization Error!", true);
        alert("Error initializing the application. Please check the console for details and try refreshing.");
    });
});


    </script>
</body>
</html>
