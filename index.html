<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Lato', sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--bg-color, #f0f0f0); /* Lighter default background */
        color: var(--text-color, #333);

        /* Light Theme (Default) Guide Tone Colors */
        --guide-tone-bg-color: #007bff;       /* Bright Blue */
        --guide-tone-text-color: white;
        --guide-tone-border-color: #0056b3;    /* Darker Blue */
        --root-highlight-border-color: #c82333; /* Default for root highlight border */

        /* Item 1: Song Title Color */
        --song-title-fretboard-color: #0056b3; /* Darker blue for light mode */
    }
    .app-section {
        background: var(--section-bg-color, white);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        color: var(--section-text-color, inherit);
    }
    .fretboards-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin-bottom: 30px;
    }
    .fretboard-container {
        background: var(--fretboard-container-bg, white);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        border: 1px solid var(--fretboard-container-border, transparent);
    }
    /* Song Info Display Styling (Item 1) */
    #song-info-display-fretboard {
        margin-bottom: 10px; /* Space before scale display */
    }
    #song-info-display-fretboard #current-song-title-fretboard {
        text-align: left;
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 1.3em; /* Slightly larger */
        font-weight: bold; /* Bolder */
        color: var(--song-title-fretboard-color); /* Themed color */
    }
    #song-info-display-fretboard p {
        text-align: left;
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 0.9em;
        color: var(--song-info-p-color, #555);
        font-style: italic;
    }

    .scale-display {
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
        margin-bottom: 5px; /* Reduced margin */
        color: var(--scale-display-color, #333);
        min-height: 1.5em; /* Reserve space */
    }
    /* Next Chord Display Styling */
    .next-chord-display {
        font-size: 0.95em; /* Slightly smaller than scale display */
        font-style: italic;
        text-align: center;
        color: var(--next-chord-color, #6c757d); /* Muted gray color */
        margin-top: -5px; /* Pull it up slightly */
        margin-bottom: 15px; /* Space below before controls */
        height: auto; /* Allow multiple lines */
        min-height: 1.2em; /* Reserve space to prevent layout shift for single line */
        line-height: 1.2em;
    }
    .controls, .top-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
        align-items: center;
    }
    .controls-container { display: flex; gap: 20px; margin-bottom: 20px; }
    .control-group { display: flex; align-items: center; gap: 10px; }
    .control-group label { font-weight: bold; }
    .control-group select { padding: 5px; border-radius: 4px; border: 1px solid #ccc; }

    .fretboard {
        position: relative;
        height: 200px;
        background-color: var(--fretboard-bg, #FFCF79);
        border-radius: 5px;
        margin-bottom: 30px;
        border: 2px solid var(--fretboard-border, #4A3B31);
        overflow: visible;
    }
    .fret-line { position: absolute; top: 0; height: 100%; width: 2px; background: #A0A0A0; border-right: 1px solid rgba(0,0,0,0.1); z-index: 1; }
    .string-line { position: absolute; left: 0; width: 100%; height: 1px; background: #C0C0C0; border-bottom: 1px solid rgba(0,0,0,0.1); z-index: 0; }
    .fret-number { position: absolute; bottom: -25px; font-size: 14px; color: #555; transform: translateX(-50%); font-weight: bold; z-index: 2; width: 20px; text-align: center; }
    .fret-marker { position: absolute; width: 10px; height: 10px; background-color: #5A4F46; border-radius: 50%; transform: translate(-50%, -50%); z-index: 1; }
    
    .note {
        position: absolute;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: var(--note-text-color, white); /* Default note text color */
        z-index: 3;
        cursor: pointer;
        transform: translate(-50%, -50%);
        transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s ease, color 0.2s ease, outline 0.2s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        /* background-color is set by JS for regular notes */
    }

    /* UPDATED GUIDE TONE STYLING (Item 3) */
    .note.guide-tone-highlight, .note.root-highlight-for-guides {
        outline: 3px solid var(--guide-tone-border-color) !important;
        box-shadow: 0 0 8px 2px var(--guide-tone-border-color) !important;
        transform: translate(-50%, -50%) scale(0.95) !important; /* Make them slightly smaller */
        z-index: 10 !important;
        font-weight: bold !important;
        border-radius: 50%;
    }
    .note.guide-tone-highlight {
        background-color: var(--guide-tone-bg-color) !important;
        color: var(--guide-tone-text-color) !important;
    }
    .note.root-highlight-for-guides {
        /* Retains its original background and text color from the scale drawing logic */
        /* Specific border for root if needed, defaults to guide tone border */
         outline-color: var(--root-highlight-border-color) !important;
         box-shadow: 0 0 8px 2px var(--root-highlight-border-color) !important;
    }

    .note:hover {
        transform: translate(-50%, -50%) scale(1.2);
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .note.guide-tone-highlight:hover, .note.root-highlight-for-guides:hover {
        transform: translate(-50%, -50%) scale(1.1) !important; /* Slightly larger hover for highlighted notes */
    }


    .beat { width: 40px; height: 80px; background: #9E9E9E; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s ease; font-size: 14px; margin: 0 2px; }
    .beats-container { display: flex; justify-content: center; gap: 8px; margin: 20px 0; flex-wrap: nowrap; overflow-x: auto; }
    .beat.active { transform: translateY(-10px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    #measures { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
    
    .measure { 
        position: relative; 
        background-color: var(--measure-bg, #e9ecef); 
        padding: 10px; /* Reduced padding slightly */
        border-radius: 4px; 
        transition: opacity 0.2s ease, background-color 0.2s ease, border 0.2s ease; 
        border: 2px solid transparent; 
        cursor: pointer; 
        color: var(--measure-text-color, #333); 
        display: flex; /* For split measure layout */
        flex-direction: column; /* Default: Stack parts or part + button */
        gap: 8px; /* Gap between parts or part and button */
    }
    .measure.split-active {
        /* Styles for when measure is split, parts might go side-by-side */
        flex-direction: row; /* Arrange parts side by side */
        align-items: flex-start; /* Align items at the top */
    }
    .measure-part {
        flex: 1; /* Each part takes equal space if side-by-side */
        display: flex;
        flex-direction: column;
        gap: 5px; /* Gap between controls within a part */
        padding: 5px;
        border: 1px dashed var(--measure-part-border-color, #ccc);
        border-radius: 3px;
    }
    .measure.split-active .measure-part {
        min-width: 120px; /* Ensure controls don't get too squished */
    }

    .measure-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
    }
    .measure-number { 
        font-size: 12px; 
        color: var(--measure-text-color, #333);
        background-color: rgba(255,255,255,0.7); 
        padding: 2px 4px; 
        border-radius: 3px; 
    }
    .split-measure-button {
        padding: 3px 6px;
        font-size: 0.8em;
        align-self: flex-end; /* Position button appropriately */
        margin-top: 5px;
    }
    .measure.split-active .split-measure-button {
        /* Adjust button position if measure content is row-based */
        /* This might need to be outside the measure-part flow */
    }
     .measure-footer { /* Container for buttons at the bottom of a measure */
        display: flex;
        justify-content: flex-end; /* Align button to the right */
        margin-top: auto; /* Pushes to the bottom if measure is flex-column */
    }
     .measure.split-active .measure-footer {
        width: 100%; /* Make footer span across if measure becomes row for parts */
        justify-content: center; /* Center button if parts are side-by-side */
        padding-top: 10px;
    }


    .measure.loop-selected { border: 2px solid var(--measure-loop-border, #007bff); background-color: var(--measure-loop-bg, #e6f2ff); }
    .measure.active .measure-part.part-active { background-color: var(--measure-active-bg, #c3e6cb); border: 1px solid var(--measure-active-border, #28a745); }
    .measure.active .measure-part:not(.part-active) { /* Slightly dim inactive part */
        opacity: 0.7;
    }


    .chord-controls, .scale-controls { display: flex; gap: 5px; margin-bottom: 5px; flex-wrap: wrap;}
    .chord-controls select, .scale-controls select { flex: 1; min-width: 60px; }


    .fretboard-section { border: 1px solid #ccc; padding: 15px; border-radius: 8px; background-color: #f9f9f9; }
    body.dark-mode .fretboard-section { background-color: #3a441e; border-color: #606c38; color: #fefae0; }
    body.dark-mode-2 .fretboard-section { background-color: #001f54; border-color: #1282a2; color: #fefcfb; }
    body.dark-mode-3 .fretboard-section { background-color: #a5a58d; border-color: #cb997e; color: #ffe8d6; }
    .fretboard-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; }
    
    .volume-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 5px 0;
        color: var(--volume-control-text-color, inherit);
    }
    #metronome-volume-controls-stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-width: 400px;
        margin: 15px auto 20px auto;
    }
    #metronome-volume-controls-stack .volume-control {
        width: 100%;
        justify-content: space-between; 
    }
    #metronome-volume-controls-stack .volume-control label,
    #metronome-volume-controls-stack .volume-control span {
        margin-right: 10px;
        white-space: nowrap;
        flex-shrink: 0; 
    }
    #metronome-volume-controls-stack .volume-control input[type="range"] {
        flex-grow: 1;
        min-width: 150px;
        max-width: 250px;
    }

    button, .button-like { padding: 10px 15px; border: none; border-radius: 5px; background: var(--button-bg, #4CAF50); color: var(--button-text-color, white); cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
    button:hover, .button-like:hover { background: var(--button-hover-bg, #45a049); }
    button.secondary { background-color: var(--button-secondary-bg, #007bff); }
    button.secondary:hover { background-color: var(--button-secondary-hover-bg, #0056b3); }
    button.danger { background-color: var(--button-danger-bg, #6b705c); }
    button.danger:hover { background-color: var(--button-danger-hover-bg, #c82333); }
    select { padding: 8px 10px; margin: 5px; border-radius: 5px; border: 1px solid var(--select-border-color, #ddd); background-color: var(--select-bg-color, white); color: var(--select-text-color, inherit); }
    #tempo-display { font-size: 1.2em; font-weight: bold; margin: 0 10px; min-width: 70px; text-align: center; }
    #loading-indicator { position: fixed; top: 20px; right: 20px; padding: 10px 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 5px; z-index: 1000; font-size: 0.9em; display: none; }
    .checkbox-wrapper { margin-top: 10px; margin-left: 0; display: flex; align-items: center; }
    .control-button { padding: 8px 12px; font-size: 0.9em; }
    #chordsEnabled { margin-bottom: 10px; }

    #start-stop {
        padding: 12px 25px !important;
        font-size: 1.1em !important;
        font-weight: bold !important;
        background-color: var(--start-stop-bg, #28a745) !important;
        border: 2px solid var(--start-stop-border, #1e7e34) !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        color: var(--start-stop-text-color, white) !important;
    }
    #start-stop:hover {
        background-color: var(--start-stop-hover-bg, #218838) !important;
        border-color: var(--start-stop-hover-border, #1c6c2e) !important;
    }

    /* --- Dark Mode 1 --- */
    body.dark-mode {
        --bg-color: #283618;
        --text-color: #fefae0;
        --section-bg-color: linear-gradient(145deg, #283618, #606c38);
        --section-text-color: #fefae0;
        --fretboard-container-bg: #606c38;
        --fretboard-container-border: #dda15e;
        /* Item 1 */ --song-title-fretboard-color: #dda15e; /* Goldish for DM1 */
        --song-info-h4-color: #fefae0;
        --song-info-p-color: #e0daca;
        --fretboard-bg: #dda15e;
        --fretboard-border: #4b4b4b;
        --note-text-color: #283618; /* Note text on fretboard */
        --scale-display-color: #fefae0;
        --button-bg: #dda15e;
        --button-text-color: #283618;
        --button-hover-bg: #bc6c25;
        --button-secondary-bg: #a17d40;
        --button-secondary-hover-bg: #8a6930;
        --button-danger-bg: #6b705c;
        --button-danger-hover-bg: #d73744;
        --start-stop-bg: #fca311;
        --start-stop-border: #e79002;
        --start-stop-text-color: #283618;
        --start-stop-hover-bg: #e79002;
        --start-stop-hover-border: #c87800;
        --select-bg-color: #dda15e;
        --select-text-color: #283618;
        --select-border-color: #bc6c25;
        --measure-bg: #606c38;
        --measure-text-color: #fefae0;
        --measure-border: #dda15e; /* Default border for measure */
        --measure-active-bg: #dda15e;
        --measure-active-border: #bc6c25;
        --measure-loop-bg: #7d6830;
        --measure-loop-border: #ffc107;
        --beat-bg: #dda15e;
        --beat-text-color: #283618;
        --beat-active-bg: #bc6c25;
        --volume-control-text-color: #fefae0;
        --next-chord-color: #fefae0;
        --measure-part-border-color: #dda15e;


        /* Dark Mode 1 Guide Tone Colors */
        --guide-tone-bg-color: #61dafb;      /* Light Cyan/Aqua */
        --guide-tone-text-color: #0a1128;    /* Very Dark Blue/Black */
        --guide-tone-border-color: #4ac9e8;   /* Slightly Darker Cyan */
        --root-highlight-border-color: #ffc107; /* Gold for root highlight */
    }
    .dark-mode .app-section { box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
    .dark-mode .scale-display { text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
    .dark-mode .beat.active { transform: translateY(-5px); }
    #dark-mode-toggle.active { background-color: #283618; color: #fefae0; border: 1px solid #dda15e; }

    /* --- Dark Mode 2 --- */
    body.dark-mode-2 {
        --bg-color: #0a1128;
        --text-color: #fefcfb;
        --section-bg-color: linear-gradient(145deg, #001f54, #034078);
        --section-text-color: #fefcfb;
        --fretboard-container-bg: #034078;
        --fretboard-container-border: #1282a2;
        /* Item 1 */ --song-title-fretboard-color: #61dafb; /* Cyan for DM2 */
        --song-info-h4-color: #fefcfb;
        --song-info-p-color: #e0e0df;
        --fretboard-bg: #001f54;
        --fretboard-border: #1282a2;
        --note-text-color: #fefcfb; /* Note text on fretboard */
        --scale-display-color: #fefcfb;
        --button-bg: #1282a2;
        --button-text-color: #fefcfb;
        --button-hover-bg: #0e6c89;
        --button-secondary-bg: #0c5f7d;
        --button-secondary-hover-bg: #094b61;
        --button-danger-bg: #6b705c;
        --button-danger-hover-bg: #e83838;
        --start-stop-bg: #61dafb;
        --start-stop-border: #4ac9e8;
        --start-stop-text-color: #0a1128;
        --start-stop-hover-bg: #4ac9e8;
        --start-stop-hover-border: #32b6d4;
        --select-bg-color: #034078;
        --select-text-color: #fefcfb;
        --select-border-color: #1282a2;
        --measure-bg: #034078;
        --measure-text-color: #fefcfb;
        --measure-border: #1282a2;
        --measure-active-bg: #1282a2;
        --measure-active-border: #fefcfb;
        --measure-loop-bg: #01325A;
        --measure-loop-border: #61dafb;
        --beat-bg: #1282a2;
        --beat-text-color: #fefcfb;
        --beat-active-bg: #034078;
        --volume-control-text-color: #fefcfb;
        --next-chord-color: #fefcfb;
        --measure-part-border-color: #1282a2;

        /* Dark Mode 2 Guide Tone Colors */
        --guide-tone-bg-color: #fca311;      /* Bright Orange/Yellow */
        --guide-tone-text-color: #001f54;    /* Dark Blue (contrasts with bg) */
        --guide-tone-border-color: #e79002;   /* Darker Orange */
        --root-highlight-border-color: #61dafb; /* Cyan for root highlight */
    }
    #dark-mode-toggle.active-2 { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }

    /* --- Dark Mode 3 --- */
    body.dark-mode-3 {
        --bg-color: #6b705c;
        --text-color: #ffe8d6;
        --section-bg-color: linear-gradient(145deg, #6b705c, #a5a58d);
        --section-text-color: #ffe8d6;
        --fretboard-container-bg: #a5a58d;
        --fretboard-container-border: #cb997e;
        /* Item 1 */ --song-title-fretboard-color: #e7ad99; /* Peach for DM3 */
        --song-info-h4-color: #ffe8d6;
        --song-info-p-color: #f0d8c6;
        --fretboard-bg: #cb997e;
        --fretboard-border: #6b705c;
        --note-text-color: #6b705c; /* Note text on fretboard */
        --scale-display-color: #ffe8d6;
        --button-bg: #cb997e;
        --button-text-color: #6b705c;
        --button-hover-bg: #b2856c;
        --button-secondary-bg: #b18f7a;
        --button-secondary-hover-bg: #9a7860;
        --button-danger-bg: #6b705c;
        --button-danger-text-color: white; /* Specific for this button */
        --button-danger-hover-bg: #c24a4a;
        --start-stop-bg: #e7ad99;
        --start-stop-border: #d09882;
        --start-stop-text-color: #6b705c;
        --start-stop-hover-bg: #d09882;
        --start-stop-hover-border: #b9836c;
        --select-bg-color: #ddbea9;
        --select-text-color: #6b705c;
        --select-border-color: #cb997e;
        --measure-bg: #a5a58d;
        --measure-text-color: #ffe8d6;
        --measure-border: #cb997e;
        --measure-active-bg: #ddbea9;
        --measure-active-border: #cb997e;
        --measure-loop-bg: #BDA290;
        --measure-loop-border: #e7ad99;
        --beat-bg: #ddbea9;
        --beat-text-color: #6b705c;
        --beat-active-bg: #cb997e;
        --volume-control-text-color: #ffe8d6;
        --next-chord-color: #ffe8d6;
        --measure-part-border-color: #cb997e;

        /* Dark Mode 3 Guide Tone Colors */
        --guide-tone-bg-color: #EF233C;      /* Bright Red/Pink */
        --guide-tone-text-color: #ffe8d6;    /* Light Peach (theme text color) */
        --guide-tone-border-color: #D90429;   /* Darker Red */
        --root-highlight-border-color: #e7ad99; /* Peach for root highlight */
    }
    .dark-mode-3 button.danger { color: var(--button-danger-text-color, white); } /* Ensure text color is applied */
    #dark-mode-toggle.active-3 { background-color: #cb997e; color: #ffe8d6; border: 1px solid #6b705c; }

    /* Fretflow Section Theming (ensure these are after main theme blocks if they don't use vars from body) */
    .dark-mode #fretflow-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; }
    .dark-mode-2 #fretflow-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
    .dark-mode-3 #fretflow-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; }

    .toggle-button { padding: 8px 12px; border: none; border-radius: 5px; color: white; cursor: pointer; transition: background-color 0.3s ease; font-size: 0.9em; }
    .toggle-button.active { background: #4CAF50; }
    .toggle-button:not(.active) { background: #9E9E9E; }

    #user-songs-section { margin-top: 15px; }
    #user-songs-section label { margin-right: 5px; }

    /* Media Queries (keep at the end) */
    @media (max-width: 1200px) { /* #measures grid-template-columns already responsive */ }
    @media (max-width: 768px) {
        .measure.split-active {
            flex-direction: column; /* Stack parts on smaller screens */
        }
        .measure.split-active .measure-part {
            min-width: unset; /* Allow full width when stacked */
        }
    }
    @media (max-width: 600px) { /* #measures grid-template-columns already responsive */ }

    </style>
</head>
<body>
    <div class="top-controls app-section">
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <!-- Guide Tones & Loop buttons moved -->
    </div>

    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <!-- Song Info Moved Here (Item 1) -->
            <div id="song-info-display-fretboard">
                <h4 id="current-song-title-fretboard"></h4>
                <p id="current-song-description-fretboard"></p>
            </div>
            <div class="scale-display" id="scale-display">Select a progression and key.</div>
            <div class="next-chord-display" id="next-chord-display"></div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
                <!-- Guide Tones Button Moved Here (Item 6) -->
                <button id="guide-tones-toggle" class="toggle-button" aria-label="Toggle guide tones">Guide Tones Off</button>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls"> <!-- Main controls row -->
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option> <option value="3">3/4</option> <option value="4" selected>4/4</option>
                <option value="6">6/8</option> <option value="7">7/8</option> <option value="8">8/8</option> <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option> <option value="woodblock">Woodblock</option> <option value="drums">Drums</option>
            </select>
            <button id="drumSetToggleBtn" class="control-button" style="display: none;">Drums</button> <!-- Initially hidden, shown by JS -->
            <!-- Tempo controls remain here -->
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>

        <!-- Vertically stacked volume controls -->
        <div id="metronome-volume-controls-stack">
            <div class="volume-control" id="metronome-master-volume-container">
                <span>Metronome Volume:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
            <div class="volume-control" id="kick-volume-container" style="display: none;">
                <label for="kick-volume">Kick Volume:</label>
                <input type="range" id="kick-volume" min="0" max="1" step="0.05" value="1.0" aria-label="Kick volume">
            </div>
            <div class="volume-control" id="snare-volume-container" style="display: none;">
                <label for="snare-volume">Snare Volume:</label>
                <input type="range" id="snare-volume" min="0" max="1" step="0.05" value="0.7" aria-label="Snare volume">
            </div>
            <div class="volume-control" id="hihat-volume-container" style="display: none;">
                <label for="hihat-volume">Hi-hat Volume:</label>
                <input type="range" id="hihat-volume" min="0" max="1" step="0.05" value="0.8" aria-label="Hi-hat volume">
            </div>
            <div class="volume-control" id="accent-intensity-container">
                <label for="accent-intensity">Accent Intensity:</label>
                <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
            </div>
        </div>

        <div class="beats-container"></div>
    </div>

    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <!-- Original song info display location - content will be managed by JS to appear in fretboard section -->
        <div id="song-info-display" style="display: none;">
            <h4 id="current-song-title"></h4>
            <p id="current-song-description"></p>
        </div>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
        <div class="controls">
            <label for="progression-select">Select Progression:</label>
            <select id="progression-select" aria-label="Select chord progression">
                <option value="I V7">I-V7</option> <option value="jazz_blues">Jazz Blues</option> <option value="minor_blues">Minor Blues</option> <option value="rhythm_changes">Rhythm Changes</option> <option value="2_5_1">II-V-I</option> <option value="6_2_5_1">VI-II-V-I</option> <option value="minor_2_5_1">Minor iim-V7-im</option> <option value="dark_eyes">Dark Eyes</option> <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams</option> <option value="rose_room">Rose Room</option> <option value="black_orpheus">Black Orpheus</option> <option value="all_the_things_you_are">All The Things You Are</option> <option value="all_of_me">All of Me</option> <option value="stella_by_starlight">Stella By Starlight</option> <option value="autumn_leaves">Autumn Leaves</option> <option value="summertime">Summertime</option> <option value="girl_from_ipanema">Girl From Ipanema</option> <option value="coltrane_changes">Coltrane Changes</option> <option value="bird_blues">Bird Blues</option> <option value="just_friends">Just Friends</option> <option value="blue_bossa">Blue Bossa</option> <option value="on_green_dolphin_street">On Green Dolphin Street</option> <option value="solar">Solar</option> <option value="misty">Misty</option> <option value="days_of_wine_and_roses">Days of Wine and Roses</option> <option value="cherokee">Cherokee</option> <option value="caravan">Caravan</option> <option value="nows_the_time">Now's The Time</option> <option value="tenor_madness">Tenor Madness</option>
            </select>
            <label for="keySelect">Select Key:</label>
            <select id="keySelect" aria-label="Select key">
              <option value="C">C</option> <option value="Cm">Cm</option> <option value="Db">Db</option> <option value="Dbm">Dbm</option> <option value="D">D</option> <option value="Dm">Dm</option> <option value="Eb">Eb</option> <option value="Ebm">Ebm</option> <option value="E">E</option> <option value="Em">Em</option> <option value="F">F</option> <option value="Fm">Fm</option> <option value="Gb">Gb</option> <option value="Gbm">Gbm</option> <option value="G">G</option> <option value="Gm">Gm</option> <option value="Ab">Ab</option> <option value="Abm">Abm</option> <option value="A">A</option> <option value="Am">Am</option> <option value="Bb">Bb</option> <option value="Bbm">Bbm</option> <option value="B">B</option> <option value="Bm">Bm</option>
            </select>
            <!-- Looping Button Moved Here (Item 5) -->
            <button id="loop-selected-toggle" class="toggle-button" aria-label="Toggle measure looping">Looping Off</button>
        </div>
        <div id="user-songs-section" class="controls">
            <label for="user-progression-select">Your Saved Songs:</label>
            <select id="user-progression-select" aria-label="Select your saved chord progression">
                <option value="">-- Select a saved song --</option>
            </select>
            <button id="delete-user-song-button" class="danger">Delete Selected Song</button>
        </div>

        <div id="measures"></div>

        <div class="controls">
            <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
            <button onclick="removeMeasure()" aria-label="Remove measure">Remove Last Measure</button>
            <button id="save-progression-button" class="secondary" aria-label="Save current progression">Save Current Progression</button>
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.5" aria-label="Chord volume">
        </div>
        <div class="control-group">
              <label for="reverb-dial">Reverb</label>
              <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
              <span id="reverb-dial-value">20</span>%
         </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <div class="fretboards-grid"></div>
</div>
    <div id="loading-indicator"></div> <!-- Added loading indicator div -->
    <script>
// ==================================
// === UTILITY FUNCTIONS ==========
// ==================================
function log(message) {
    console.log(`[Bebop Blueprint Debug] ${message}`);
}
function updateLoadingStatus(message, isVisible = true) {
    let i = document.getElementById('loading-indicator');
    if (!i) {
        i = document.createElement('div');
        i.id = 'loading-indicator';
        document.body.appendChild(i);
    }
    i.textContent = message;
    i.style.display = isVisible ? 'block' : 'none';
}

// ==================================
// === MUSICAL CONSTANTS ==========
// ==================================
const progressions = {
  "I V7": {
    defaultKey: "C",
    progression: ["Imaj7", "V7"],
    description:
      "A classic two-chord progression often used in jazz standards for a simple, elegant harmonic resolution.",
  },
  jazz_blues: {
    defaultKey: "Bb",
    progression: [
      "I7",
      "IV7",
      "I7",
      "I7",
      "IV7",
      "IV7",
      "I7",
      "VI7",
      "iim7",
      "V7",
      "I7",
      "V7",
    ],
    description:
      "A swinging 12-bar blues with jazzy substitutions, perfect for improvisation and soulful melodies.",
  },
  minor_blues: {
    defaultKey: "Am",
    progression: [
      "im7",
      "ivm7",
      "im7",
      "im7",
      "ivm7",
      "ivm7",
      "im7",
      "im7",
      "V7",
      "V7",
      "im7",
      "V7",
    ],
    description:
      "A moody minor blues progression with a melancholic vibe, ideal for expressive solos.",
  },
  rhythm_changes: {
    defaultKey: "Bb",
    progression: [
      "Imaj7",
      "vim7",
      "iim7",
      "V7",
      "Imaj7",
      "vim7",
      "iim7",
      "V7",
      "Imaj7",
      "IV7",
      "Imaj7",
      "Imaj7",
      "iim7",
      "V7",
      "Imaj7",
      "V7",
    ],
    description:
      "A fast-paced, iconic jazz structure based on Gershwin's 'I Got Rhythm,' great for bebop.",
  },
  "2_5_1": {
    defaultKey: "C",
    progression: ["iim7", "V7", "Imaj7", "Imaj7"],
    description:
      "The quintessential jazz turnaround, providing a smooth and satisfying resolution.",
  },
  "6_2_5_1": {
    defaultKey: "C",
    progression: ["vim7", "iim7", "V7", "Imaj7", "Imaj7"],
    description:
      "An extended version of the 2-5-1, starting on the vi minor for a richer harmonic journey.",
  },
  minor_2_5_1: {
    defaultKey: "Am",
    progression: ["iim7b5", "V7b9", "im7", "im7"],
    description:
      "A dramatic minor key progression, often used for intense and emotional resolutions.",
  },
  dark_eyes: {
    defaultKey: "Dm",
    progression: [
      "V7",
      "V7",
      "im7",
      "im7",
      "V7",
      "V7",
      "VImaj7",
      "VImaj7",
      "ivm6",
      "ivm6",
      "im7",
      "im7",
      "V7",
      "V7",
      "im7",
      "im7",
    ],
    description:
      "A passionate, Gypsy jazz-inspired progression with a fiery, Eastern European flair.",
  },
  ill_see_you_in_my_dreams: {
    defaultKey: "F",
    progression: [
      "IV6",
      "IV6",
      "ivm6",
      "ivm6",
      "Imaj7",
      "VII7",
      "Imaj7",
      "Imaj7",
      "VI7",
      "VI7",
      "VI7",
      "VI7",
      "II7",
      "II7",
      "iim7",
      "V7",
      "Imaj6",
      "I7",
    ],
    description:
      "A dreamy, nostalgic progression from the 1920s, evoking romance and whimsy.",
  },
  rose_room: {
    defaultKey: "Ab",
    progression: [
      "II7",
      "V7",
      "Imaj7",
      "I6",
      "vm7",
      "I7",
      "IVmaj7",
      "IVmaj7",
      "ivm7",
      "ivm7",  
      "Imaj7",
      "VI7",
      "II7",
      "II7",  
      "V7",
      "V7", 
      "II7",
      "V7",
      "Imaj7",
      "I6",
      "vm7",
      "I7",
      "IVmaj7",
      "IVmaj7",
      "ivm7",
      "ivm7",  
      "Imaj7",  
      "VI7",
      "II7",
      "V7",
      "Imaj7",
      "Imaj7", 
    ],
    description:
      "A sophisticated swing tune with lush chords, perfect for a classy jazz vibe.",
  },
  black_orpheus: {
    defaultKey: "Am",
    progression: [
      "im7",
      "iim7b5",
      "V7b9",
      "im7",
      "ivm7",
      "VII7",
      "bIIImaj7",
      "bVImaj7",
      "iim7b5",
      "V7b9",
      "im7",
      "iim7b5",
      "V7b9",
      "im7",
      "ivm7",
      "VII7",
    ],
    description:
      "A bossa nova classic with a haunting minor key, inspired by Brazilian rhythms.",
  },
  all_the_things_you_are: {
    defaultKey: "Ab",
    progression: [
      "vim7",
      "iim7",
      "V7",
      "Imaj7",
      "IVmaj7",
      "iiim7",
      "VI7",
      "IImaj7",
      "iim7",
      "vm7",
      "I7",
      "IVmaj7",
      "Imaj7",
      "iim7",
      "V7",
      "Imaj7",
      "iim7",
      "V7",
      "Imaj7",
      "iim7",
      "vm7",
      "I7",
      "IVmaj7",
      "Imaj7",
    ],
    description:
      "A harmonically complex standard with shifting keys, beloved in jazz for its beauty.",
  },
  all_of_me: {
    defaultKey: "C",
    progression: [
      "Imaj7",
      "III7",
      "VI7",
      "iim7",
      "III7",
      "vim7",
      "II7",
      "iim7",
      "V7",
      "Imaj7",
      "III7",
      "VI7",
      "iim7",
      "IVmaj7",
      "ivm7",
      "Imaj7",
      "V7",
    ],
    description:
      "A cheerful, upbeat standard with a catchy progression, great for vocal jazz.",
  },
  stella_by_starlight: {
    defaultKey: "Bb",
    progression: [
      "iim7b5",
      "V7b9",
      "Imaj7",
      "IV7",
      "vm7",
      "I7",
      "IVmaj7",
      "bVIImaj7",
      "biiim7b5",
      "VI7b9",
      "iim7",
      "V7",
      "Imaj7",
      "IV7",
      "IVmaj7",
      "V7",
    ],
    description:
      "A lush, cinematic progression with a romantic and introspective feel.",
  },
  autumn_leaves: {
    defaultKey: "Bb",
    progression: [
      "iim",
      "V7",
      "imaj7",
      "IVmaj7",
      "viim7b5",
      "III7",
      "vim7",
      "vim7",
    ],
    description:
      "A melancholic jazz standard evoking falling leaves and wistful nostalgia.",
  },
  summertime: {
    defaultKey: "Am",
    progression: [
      "im7",
      "V7",
      "im7",
      "V7",
      "im7",
      "V7",
      "im7",
      "V7",
      "ivm7",
      "im7",
      "V7",
      "im7",
      "ivm7",
      "im7",
      "V7",
      "im7",
    ],
    description:
      "A sultry, soulful progression from Gershwin's opera, perfect for laid-back grooves.",
  },
  girl_from_ipanema: {
    defaultKey: "F",
    progression: [
      "Imaj7",
      "II7",
      "iim7",
      "V7",
      "Imaj7",
      "II7",
      "iim7",
      "V7",
      "Imaj7",
      "bII7",
      "#IVm7b5",
      "VII7",
      "iiim7",
      "VI7",
      "iim7",
      "V7",
    ],
    description:
      "A breezy bossa nova tune with a sunny, beachy vibe, iconic in jazz.",
  },
  coltrane_changes: {
    defaultKey: "C",
    progression: [
      "Imaj7",
      "bIII7",
      "bVImaj7",
      "VII7",
      "IIImaj7",
      "V7",
      "Imaj7",
      "bIII7",
      "bVImaj7",
      "VII7",
      "IIImaj7",
      "V7",
    ],
    description:
      "A challenging, innovative progression from John Coltrane, with rapid key shifts.",
  },
  bird_blues: {
    defaultKey: "F",
    progression: [
      "I7",
      "IV7",
      "I7",
      "vim7",
      "iim7",
      "V7",
      "IV7",
      "ivm7",
      "I7",
      "vim7",
      "iim7",
      "V7",
    ],
    description:
      "A bebop blues progression inspired by Charlie Parker, full of energy and drive.",
  },
  just_friends: {
    defaultKey: "G",
    progression: [
      "Imaj7",
      "VI7",
      "iim7",
      "V7",
      "Imaj7",
      "VI7",
      "iim7",
      "V7",
      "iim7",
      "V7",
      "Imaj7",
      "VI7",
      "iim7",
      "V7",
      "Imaj7",
      "VI7",
    ],
    description:
      "A lively, upbeat standard with a playful harmonic structure, great for swing.",
  },
  blue_bossa: {
    defaultKey: "Cm",
    progression: [
      "im7",
      "im7",
      "bVII7",
      "bVII7",
      "im7",
      "im7",
      "ivm7",
      "bVII7",
      "im7",
      "V7",
      "im7",
      "im7",
    ],
    description:
      "A cool, Latin-jazz progression with a relaxed yet groovy bossa nova feel.",
  },
  on_green_dolphin_street: {
    defaultKey: "C",
    progression: [
      "Imaj7",
      "im7",
      "Imaj7",
      "im7",
      "bIImaj7",
      "Imaj7",
      "bIImaj7",
      "Imaj7",
      "iim7",
      "V7",
    ],
    description:
      "A modal, cinematic progression with a mysterious and captivating atmosphere.",
  },
  solar: {
    defaultKey: "Cm",
    progression: [
      "imaj7",
      "iim7b5",
      "V7alt",
      "imaj7",
      "bVImaj7",
      "bIIImaj7",
      "bVII7",
      "bVII7",
      "imaj7",
      "imaj7",
    ],
    description:
      "A contemplative, Miles Davis original with a flowing, introspective harmonic line.",
  },
  misty: {
    defaultKey: "Eb",
    progression: [
      "Imaj7",
      "vm7",
      "I7",
      "IVmaj7",
      "ivm7",
      "Imaj7",
      "iim7",
      "V7",
      "iiim7",
      "VI7",
      "iim7",
      "V7",
    ],
    description:
      "A tender, romantic ballad progression, evoking misty-eyed sentimentality.",
  },
  days_of_wine_and_roses: {
    defaultKey: "F",
    progression: [
      "Imaj7",
      "vim7",
      "iim7",
      "V7",
      "Imaj7",
      "vim7",
      "iim7",
      "V7",
      "IVmaj7",
      "vm7",
      "I7",
      "IVmaj7",
      "iiim7",
      "VI7",
      "iim7",
      "V7",
    ],
    description:
      "A bittersweet, elegant progression with a waltzing, reflective quality.",
  },
  cherokee: {
    defaultKey: "Bb",
    progression: [
      "Imaj7",
      "Imaj7",
      "iim7",
      "V7",
      "Imaj7",
      "Imaj7",
      "iim7",
      "V7",
      "bVImaj7",
      "bVImaj7",
      "V7",
      "V7",
      "Imaj7",
      "Imaj7",
      "iim7",
      "V7",
    ],
    description:
      "A high-energy bebop standard with a fast-moving, adventurous harmonic structure.",
  },
  caravan: {
    defaultKey: "Fm",
    progression: [
      "im7",
      "IV7b5",
      "im7",
      "IV7b5",
      "im7",
      "IV7b5",
      "im7",
      "IV7b5",
      "bVII7",
      "bVII7",
      "Imaj7",
      "Imaj7",
      "V7",
      "V7",
      "im7",
      "im7",
    ],
    description:
      "An exotic, Latin-tinged progression with a hypnotic, caravan-like rhythm.",
  },
  nows_the_time: {
    defaultKey: "F",
    progression: [
      "I7",
      "I7",
      "I7",
      "I7",
      "IV7",
      "IV7",
      "I7",
      "I7",
      "V7",
      "IV7",
      "I7",
      "I7",
    ],
    description:
      "A gritty, straightforward blues progression by Charlie Parker, full of soul.",
  },
  tenor_madness: {
    defaultKey: "Bb",
    progression: [
      "I7",
      "I7",
      "I7",
      "I7",
      "IV7",
      "IV7",
      "I7",
      "I7",
      "iim7",
      "V7",
      "I7",
      "I7",
    ],
    description:
      "A hard-swinging blues progression, ideal for fiery tenor sax battles.",
  },
};
const NOTES = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
const NOTES_CHROMATIC = [
  "C",
  "Db",
  "D",
  "Eb",
  "E",
  "F",
  "Gb",
  "G",
  "Ab",
  "A",
  "Bb",
  "B",
];
const ALL_NOTES_FOR_SAMPLES = [
  "a",
  "as",
  "b",
  "c",
  "cs",
  "d",
  "ds",
  "e",
  "f",
  "fs",
  "g",
  "gs",
];
const OCTAVES_FOR_SAMPLES = [2, 3, 4, 5];
const PLAYBACK_OCTAVES = [3, 4]; // Preferred octaves for chord playback
const FILE_FORMAT = "wav";

function getSampleFileName(note, octave) {
  return `${note}${octave}.${FILE_FORMAT}`;
}

const SAMPLE_NOTE_MAP = {
  C: "c",
  Db: "cs",
  "C#": "cs",
  D: "d",
  Eb: "ds",
  "D#": "ds",
  E: "e",
  F: "f",
  Gb: "fs",
  "F#": "fs",
  G: "g",
  Ab: "gs",
  "G#": "gs",
  A: "a",
  Bb: "as",
  "A#": "as",
  B: "b",
  CS: "cs", // Ensure these are present for direct use if needed
  DS: "ds",
  FS: "fs",
  GS: "gs",
  AS: "as",
};
// FRETBOARD_NOTES_OCTAVES: string1 is high E (thin string, typically top in diagrams but bottom in pitch array)
// string6 is low E (thick string, typically bottom in diagrams but top in pitch array)
const FRETBOARD_NOTES_OCTAVES = { // Standard Tuning EADGBE
  string1: ["E4", "F4", "Fs4", "G4", "Gs4", "A4", "As4", "B4", "C5", "Cs5", "D5", "Ds5", "E5"], // High E
  string2: ["B3", "C4", "Cs4", "D4", "Ds4", "E4", "F4", "Fs4", "G4", "Gs4", "A4", "As4", "B4"], // B
  string3: ["G3", "Gs3", "A3", "As3", "B3", "C4", "Cs4", "D4", "Ds4", "E4", "F4", "Fs4", "G4"], // G
  string4: ["D3", "Ds3", "E3", "F3", "Fs3", "G3", "Gs3", "A3", "As3", "B3", "C4", "Cs4", "D4"], // D
  string5: ["A2", "As2", "B2", "C3", "Cs3", "D3", "Ds3", "E3", "F3", "Fs3", "G3", "Gs3", "A3"], // A
  string6: ["E2", "F2", "Fs2", "G2", "Gs2", "A2", "As2", "B2", "C3", "Cs3", "D3", "Ds3", "E3"], // Low E
};

const SCALES = {
  major: [0, 2, 4, 5, 7, 9, 11],
  minor: [0, 2, 3, 5, 7, 8, 10],
  harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
  melodicMinor: [0, 2, 3, 5, 7, 9, 11], // Ascending
  dorian: [0, 2, 3, 5, 7, 9, 10],
  phrygian: [0, 1, 3, 5, 7, 8, 10],
  lydian: [0, 2, 4, 6, 7, 9, 11],
  mixolydian: [0, 2, 4, 5, 7, 9, 10],
  locrian: [0, 1, 3, 5, 6, 8, 10],
  bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11],
  bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11],
  bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10], // Minor bebop
  bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10], // Less common
  altered: [0, 1, 3, 4, 6, 8, 10], // (Super Locrian, Diminished Whole Tone)
  lydianDominant: [0, 2, 4, 6, 7, 9, 10], // Lydian b7
  diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11], // Whole-Half
  diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10], // Half-Whole
  wholeTone: [0, 2, 4, 6, 8, 10],
  pentatonicMajor: [0, 2, 4, 7, 9],
  pentatonicMinor: [0, 3, 5, 7, 10],
  blues: [0, 3, 5, 6, 7, 10], // Minor blues
  majorBlues: [0, 2, 3, 4, 7, 9], // Major blues (add b3 to pent major)
  harmonicMajor: [0, 2, 4, 5, 7, 8, 11],
  doubleHarmonic: [0, 1, 4, 5, 7, 8, 11], // Byzantine, Gypsy Major
  enigmatic: [0, 1, 4, 6, 8, 10, 11],
  persian: [0, 1, 4, 5, 6, 8, 11],
  arabic: [0, 2, 4, 5, 6, 8, 10], // (Major b2 b6)
  japanese: [0, 2, 5, 7, 8], // (Kumoi without 4th degree from root C D F G Ab C) Hirajoshi
  egyptian: [0, 2, 5, 7, 10], // Pentatonic with no 3rd or 7th (C D F G Bb)
};
const TUNINGS = { // Note: Stored high-to-low string pitch for easier indexing with visual top-to-bottom
  standard: ["E", "B", "G", "D", "A", "E"], // E4, B3, G3, D3, A2, E2
  dropD: ["E", "B", "G", "D", "A", "D"],    // E4, B3, G3, D3, A2, D2
  openG: ["D", "B", "G", "D", "G", "D"],    // D4, B3, G3, D3, G2, D2
  DADGAD: ["D", "A", "G", "D", "A", "D"],   // D4, A3, G3, D3, A2, D2
  openE: ["E", "B", "E", "Ab", "B", "E"],   // E4, B3, E3, G#3, B2, E2
};
// Reverse them for processing (low E string at index 0)
Object.keys(TUNINGS).forEach(key => {
    TUNINGS[key].reverse();
});

const CHORD_INTERVALS = {
  maj: [0, 4, 7],
  min: [0, 3, 7],
  dim: [0, 3, 6],
  aug: [0, 4, 8],
  sus4: [0, 5, 7],
  sus2: [0, 2, 7],
  maj7: [0, 4, 7, 11],
  dom7: [0, 4, 7, 10], // Also '7'
  min7: [0, 3, 7, 10], // Also 'm7'
  min7b5: [0, 3, 6, 10], // Half-diminished, m7(b5)
  dim7: [0, 3, 6, 9], // Fully diminished
  maj6: [0, 4, 7, 9],
  min6: [0, 3, 7, 9],
  dom7b9: [0, 4, 7, 10, 13], // 13 is b9 an octave higher
  "dom7#9": [0, 4, 7, 10, 15], // 15 is #9 an octave higher
  dom7b5: [0, 4, 6, 10],
  alt: [0, 4, 6, 10, 13], // Common alt: Root, M3, b5, b7, b9. Other alterations possible.
  dom7sus: [0, 5, 7, 10], // 7sus4
  maj9: [0, 4, 7, 11, 14], // 14 is M9 an octave higher
  dom9: [0, 4, 7, 10, 14],
  min9: [0, 3, 7, 10, 14],
  imaj7: [0, 3, 7, 11], // Minor-Major 7th
  unknown: [0, 4, 7, 10], // Fallback if quality parsing fails
};
const drumSoundSets = [
  { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" },
  {
    name: "Makaya",
    snare: "Snare2.wav",
    hihat: "HiHat2.wav",
    kick: "Kick2.wav",
  },
  {
    name: "PhillyJoe",
    kick: "jazzkick.wav",
    snare: "jazzsnare.wav",
    hihat: "jazzhat.wav",
  },
];

// --- State Management ---
const AppState = {
    isPlaying: false,
    currentBeat: 0,
    currentMeasure: 0,
    tempo: 120,
    audioInitialized: false,
    intervalId: null,
    lastTapTime: 0,
    tapTempoTimestamps: [],
    guideTonesActive: false,
    loopingActive: false,
    loopStartMeasure: -1,
    loopEndMeasure: -1,
    previousChordRootIndex: undefined, // For voice leading logic if ever re-enabled
    listeners: [],
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};
let currentFunctionalProgression = [];
let currentProgressionName = "";
let currentDrumSetIndex = 0;

// --- UI Management ---
const UI = {
    elements: {},
    init() {
        this.elements = {
            chordFretboard: document.getElementById('chord-fretboard'),
            measures: document.getElementById('measures'),
            tempoDisplay: document.getElementById('tempo-display'),
            startStopButton: document.getElementById('start-stop'),
            progressionSelect: document.getElementById('progression-select'),
            keySelect: document.getElementById('keySelect'),
            scaleDisplay: document.getElementById('scale-display'),
            nextChordDisplay: document.getElementById('next-chord-display'),
            chordTuning: document.getElementById('chord-tuning'),
            timeSignature: document.getElementById('time-signature'),
            soundType: document.getElementById('sound-type'),
            metronomeVolume: document.getElementById('metronome-volume'),
            tempo: document.getElementById('tempo'),
            tapTempo: document.getElementById('tap-tempo'),
            chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
            chordVolume: document.getElementById('chord-volume'),
            chordsEnabled: document.getElementById('chordsEnabled'),
            fretboardsGrid: document.querySelector('.fretboards-grid'),
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            accentIntensity: document.getElementById('accent-intensity'),
            drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
            reverbDial: document.getElementById('reverb-dial'),
            reverbDialValue: document.getElementById('reverb-dial-value'),

            // Metronome drum mix controls
            kickVolumeContainer: document.getElementById('kick-volume-container'),
            kickVolume: document.getElementById('kick-volume'),
            snareVolumeContainer: document.getElementById('snare-volume-container'),
            snareVolume: document.getElementById('snare-volume'),
            hihatVolumeContainer: document.getElementById('hihat-volume-container'),
            hihatVolume: document.getElementById('hihat-volume'),

            // For moved song info
            currentSongTitleFretboard: document.getElementById('current-song-title-fretboard'),
            currentSongDescriptionFretboard: document.getElementById('current-song-description-fretboard'),
            // Original song info (kept for potential internal logic, but hidden)
            currentSongTitle: document.getElementById('current-song-title'),
            currentSongDescription: document.getElementById('current-song-description'),
            userProgressionSelect: document.getElementById('user-progression-select'),
            saveProgressionButton: document.getElementById('save-progression-button'),
            deleteUserSongButton: document.getElementById('delete-user-song-button'),
            guideTonesToggle: document.getElementById('guide-tones-toggle'), // Moved
            loopSelectedToggle: document.getElementById('loop-selected-toggle') // Moved
        };
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element && key !== 'reverbDialValue' && key !== 'currentSongTitle' && key !== 'currentSongDescription') { // Allow original song info to be missing if truly removed
                 console.warn(`Missing DOM element: ${key}`);
            }
        });
        log("UI elements cached.");
    }
};

// --- Music Theory Helpers ---
function standardizeNoteName(note) {
    if (!note) return '';
    let standardized = note.toUpperCase().trim().replace('', 'b').replace('', '#');
    const sharpToFlatMap = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
    if (standardized.includes('#')) {
        return sharpToFlatMap[standardized] || standardized;
    }
    // Ensure it's one of the 12 canonical flat/natural names
    const foundNote = NOTES.find(n => n.toUpperCase() === standardized.toUpperCase());
    return foundNote || standardized; // Fallback to input if not found (e.g. already standard)
}

function standardizeNoteNameForSamples(note) {
    const stdNote = standardizeNoteName(note); // C, Db, D ...
    return SAMPLE_NOTE_MAP[stdNote] || SAMPLE_NOTE_MAP[note.toUpperCase()] || note.toLowerCase();
}

function getStandardQuality(rawQuality) {
    if (!rawQuality) return 'maj7'; // Default quality
    const quality = rawQuality.toLowerCase().trim();

    // Direct matches for common jazz notation
    if (quality === 'maj7' || quality === 'ma7' || quality === '' || quality === 'maj') return 'maj7';
    if (quality === '7' || quality === 'dom7' || quality === 'dom') return 'dom7';
    if (quality === 'm7' || quality === 'min7' || quality === 'mi7' || quality === 'min' || quality === 'm') return 'min7';
    if (quality === 'm7b5' || quality === 'min7b5' || quality === '' || quality === 'mi7b5') return 'min7b5';
    if (quality === 'dim7' || quality === '7' || (quality === 'dim' && rawQuality.includes('7'))) return 'dim7'; // ensure it's dim7 not just dim
    if (quality === 'maj6' || quality === 'ma6' || (quality === '6' && !rawQuality.startsWith('m') && !rawQuality.startsWith('M'))) return 'maj6';
    if (quality === 'm6' || quality === 'min6' || quality === 'mi6') return 'min6';

    // Triads
    if (quality === 'dim' || quality === '') return 'dim';
    if (quality === 'aug' || quality === '+') return 'aug';
    if (quality === 'sus4' || quality === 'sus') return 'sus4'; // Default sus to sus4

    // Extended/Altered Dominants
    if (quality === '7b9' || quality === 'dom7b9') return 'dom7b9';
    if (quality === '7#9' || quality === 'dom7#9') return 'dom7#9';
    if (quality === '7b5' || quality === 'dom7b5') return 'dom7b5';
    if (quality === 'alt' || quality === '7alt') return 'alt';
    if (quality === '7sus' || quality === '7sus4') return 'dom7sus';

    // Minor-Major
    if (quality === 'imaj7' || quality === 'm(maj7)' || quality === 'minmaj7' || quality === 'mmaj7') return 'imaj7';

    // Check if it's already a key in CHORD_INTERVALS (e.g. 'sus2', 'maj9')
    if (CHORD_INTERVALS[rawQuality]) return rawQuality;
    if (CHORD_INTERVALS[quality]) return quality;


    console.warn(`getStandardQuality: Unstandardized quality "${rawQuality}". Defaulting to 'maj7'.`);
    return 'maj7';
}

function parseChord(chordString) {
    if (typeof chordString !== 'string' || !chordString.trim()) {
        return null;
    }
    chordString = chordString.trim();
    const match = chordString.match(/^([A-G][#b]?)(.*)$/);
    if (!match) {
        // console.warn(`Could not parse chord string: ${chordString}`);
        return null;
    }
    const root = standardizeNoteName(match[1]);
    const qualityString = match[2].trim();
    const quality = getStandardQuality(qualityString);
    return { root: root, quality: quality, originalString: chordString };
}

function parseRomanNumeralToAbsoluteChord(romanString, key) {
    const isMinorKey = key.includes('m');
    const normalizedKeyRoot = standardizeNoteName(key.replace('m', ''));
    const keyRootIndex = NOTES_CHROMATIC.indexOf(normalizedKeyRoot);

    if (keyRootIndex === -1) {
        console.error(`Invalid key for Roman numeral parsing: ${key}`);
        return { root: 'C', quality: 'maj7', originalRoman: romanString }; // Fallback
    }

    // Try parsing as an absolute chord first (e.g. "Cmaj7", "Gm7")
    // If romanString is something like "Cmaj7/G7", this will parse "Cmaj7"
    const firstChordInSplit = romanString.split('/')[0].trim();
    const absoluteChordAttempt = parseChord(firstChordInSplit);
    if (absoluteChordAttempt && absoluteChordAttempt.root && CHORD_INTERVALS[absoluteChordAttempt.quality]) {
        // If it was part of a split, we only return the first part for now.
        // The full split handling will be done by `loadProgression` or `saveProgression`.
        return { ...absoluteChordAttempt, originalRoman: romanString };
    }

    const romanMatch = firstChordInSplit.match(/^(b|#)?([IViv]+)(.*)$/);
    if (!romanMatch) {
        // If not a roman numeral, and not a simple chord, assume it's just a root note or malformed
        console.warn(`Could not parse Roman numeral or chord: ${firstChordInSplit} in key ${key}. Assuming root.`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString }; // Default to Imaj7 of the key
    }

    const accidental = romanMatch[1]; // 'b', '#', or undefined
    const numeral = romanMatch[2];   // 'I', 'IV', 'v', 'ii', etc.
    let qualitySuffix = romanMatch[3].trim(); // 'maj7', 'm7', '7', 'dim7', '', etc.

    const majorScaleIntervals = { 'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11 };
    const minorScaleIntervals = { 'i': 0, 'ii': 2, 'III': 3, 'iv': 5, 'v': 7, 'VI': 8, 'VII': 10 }; // Natural minor based

    let degreeInterval;
    const isUpperCaseNumeral = numeral === numeral.toUpperCase();

    if (isMinorKey) {
        degreeInterval = minorScaleIntervals[numeral.toLowerCase()];
        // Common alterations in minor keys (e.g., V7 instead of v7, IVmaj7 instead of ivm7)
        if (isUpperCaseNumeral && numeral.toLowerCase() === 'v') degreeInterval = majorScaleIntervals['V']; // V in minor is major/dominant
        if (isUpperCaseNumeral && numeral.toLowerCase() === 'iv') degreeInterval = majorScaleIntervals['IV']; // IV in minor can be major
    } else { // Major key
        degreeInterval = majorScaleIntervals[numeral.toUpperCase()];
    }

    if (degreeInterval === undefined) {
        console.warn(`Unknown Roman numeral base: ${numeral} in ${firstChordInSplit}`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }

    let chordRootIndex = (keyRootIndex + degreeInterval) % 12;
    if (accidental === 'b') {
        chordRootIndex = (chordRootIndex - 1 + 12) % 12;
    } else if (accidental === '#') {
        chordRootIndex = (chordRootIndex + 1) % 12;
    }
    const chordRoot = NOTES_CHROMATIC[chordRootIndex];

    let finalQuality;
    if (qualitySuffix) {
        if (qualitySuffix === "6" && CHORD_INTERVALS[isUpperCaseNumeral ? "maj6" : "min6"]) { // Ambiguous '6'
            finalQuality = isUpperCaseNumeral ? "maj6" : "min6";
        } else {
           finalQuality = getStandardQuality(qualitySuffix);
        }
    } else { // Infer quality if not specified
        if (numeral.toLowerCase() === 'v' && (isMinorKey || qualitySuffix === '7')) { // V7 in minor or just 'V' often implies V7
            finalQuality = 'dom7';
        } else if (numeral.toLowerCase() === 'vii' && !isUpperCaseNumeral) { // vii or vii
            finalQuality = 'min7b5'; // Often half-dim in diatonic contexts
        } else if (isUpperCaseNumeral) {
            finalQuality = 'maj7';
        } else {
            finalQuality = 'min7';
        }
    }
    if (!CHORD_INTERVALS[finalQuality]) {
        console.warn(`Inferred/parsed quality "${finalQuality}" for Roman ${firstChordInSplit} in key ${key} is not in CHORD_INTERVALS. Defaulting quality.`);
        finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7';
    }

    return { root: chordRoot, quality: finalQuality, originalRoman: romanString };
}

function getChordNotes(root, quality) {
    let intervals = CHORD_INTERVALS[quality];
    if (!intervals) {
        console.warn(`Quality "${quality}" for root "${root}" not found in CHORD_INTERVALS. Defaulting to dom7 intervals.`);
        intervals = CHORD_INTERVALS['dom7']; // Fallback
    }
    const standardizedRoot = standardizeNoteName(root);
    const rootIndex = NOTES.indexOf(standardizedRoot);
    if (rootIndex === -1) {
        console.error(`Invalid root note for getChordNotes: ${root}`);
        return [standardizedRoot]; // Return the root itself if parsing fails
    }
    return intervals.map(interval => (NOTES[(rootIndex + interval) % 12]));
}

function suggestScaleForQuality(quality) {
    const scaleMap = {
        'maj7': 'major', 'maj': 'major', 'maj6': 'major',
        'dom7': 'mixolydian', 'dom9': 'mixolydian', 'dom7b9': 'diminishedWH', // Or altered
        'dom7#9': 'altered', 'alt': 'altered', 'dom7sus': 'mixolydian', // or dorian/aeolian for sus
        'min7': 'dorian', 'min': 'dorian', 'min9': 'dorian', 'min6': 'dorian',
        'min7b5': 'locrian', // or locrian #2
        'dim7': 'diminishedWH', // Whole-Half for o7
        'imaj7': 'melodicMinor', // Minor-Major 7th chord
    };
    return scaleMap[quality] || 'major'; // Default to major scale
}


// --- DOM Utilities ---
function createKeyOptions(selectedKey = 'C') {
    return NOTES.map(note =>
        `<option value="${note}"${note === standardizeNoteName(selectedKey) ? ' selected' : ''}>${note}</option>`
    ).join('');
}

function createQualityOptions(selectedQuality = 'maj7') {
    const qualityDisplayOrder = [
        { value: 'maj7', label: 'maj7' }, { value: 'dom7', label: '7' },
        { value: 'min7', label: 'm7' }, { value: 'min7b5', label: 'm7b5' },
        { value: 'dim7', label: 'dim7' }, { value: 'maj6', label: 'maj6' },
        { value: 'min6', label: 'm6' },
        { value: 'dom7b9', label: '7b9' }, { value: 'dom7#9', label: '7#9' },
        { value: 'dom7b5', label: '7b5' }, { value: 'alt', label: 'alt' },
        { value: 'dom7sus', label: '7sus' }, { value: 'imaj7', label: 'm(maj7)' },
        // Triads
        { value: 'maj', label: 'maj' }, { value: 'min', label: 'min' },
        { value: 'dim', label: 'dim' }, { value: 'aug', label: 'aug' },
        { value: 'sus4', label: 'sus4' }, { value: 'sus2', label: 'sus2' }
        // Can add 9ths, 11ths, 13ths if desired
    ];
    return qualityDisplayOrder.map(q =>
        `<option value="${q.value}"${q.value === selectedQuality ? ' selected' : ''}>${q.label}</option>`
    ).join('');
}
function createScaleOptions(selectedScale = 'major') {
    return Object.keys(SCALES).map(scaleName => {
        const displayName = scaleName
            .replace(/([A-Z]+)/g, ' $1') // Add space before uppercase letters if part of a word like 'wholeTone'
            .replace(/([A-Z][a-z])/g, ' $1') // Add space before capitalized words like 'BebopDominant'
            .split(' ')
            .map(s => s.charAt(0).toUpperCase() + s.substring(1))
            .join(' ')
            .trim(); // Ensure no leading/trailing spaces
        return `<option value="${scaleName}"${scaleName === selectedScale ? ' selected' : ''}>${displayName}</option>`;
    }).join('');
}

// --- Audio Management ---
const AudioContextManager = {
    context: null,
    soundBuffers: {}, // For metronome, drums
    pianoSampleBuffers: {}, // For piano notes/chords
    reverbNode: null,
    samplesLoaded: false,
    reverbAmount: 0.2, // Default reverb amount (0 to 1)
    currentChordGain: null, // To fade out previous chord
    secondaryLoadStarted: false,
    reverbNodeConnected: false,

    async initialize() {
        if (this.context && this.context.state !== 'closed') {
            return this.context;
        }
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            log("AudioContext created/resumed.");
            updateLoadingStatus("Loading essential sounds...", true);
            await this.loadInitialSounds(); // Essential sounds like click and primary piano octaves
            AppState.audioInitialized = true;
            log("AudioContextManager initial sounds loaded.");
            await this.setupReverb();

            if (this.context.state === 'suspended') {
                await this.context.resume(); // Important for browsers that start context in suspended state
                log("AudioContext resumed from suspended state.");
            }
            // Start loading non-essential sounds in the background
            setTimeout(() => this.loadSecondarySounds(), 100);

        } catch (error) {
            console.error("Error initializing AudioContextManager:", error);
            alert("Failed to initialize audio. Please ensure your browser supports Web Audio API and allow autoplay if prompted.");
            AppState.audioInitialized = false;
            throw error; // Rethrow to be caught by outer try/catch
        }
        return this.context;
    },

    async ensureAudioContext() {
        if (!this.context || this.context.state === 'suspended') {
            return await this.initialize();
        }
        if (this.context.state === 'closed') {
            console.warn("AudioContext was closed, attempting to re-initialize.");
            return await this.initialize();
        }
        return this.context;
    },

    async loadInitialSounds() {
        try {
            // Load a fallback click sound first
            const response = await fetch('./Click.wav');
            if (!response.ok) throw new Error(`HTTP error ${response.status} for Click.wav`);
            const arrayBuffer = await response.arrayBuffer();
            this.soundBuffers['click'] = await this.context.decodeAudioData(arrayBuffer);
            log("Successfully loaded Click.wav");
        } catch (e) {
            console.error("Failed to load Click.wav:", e);
            this.soundBuffers['click'] = await this.createDrumSound('click'); // Fallback synth click
            log("Using synthetic fallback for click sound.");
        }
        // Load primary piano samples
        await this.loadPianoSamplesSpecific(PLAYBACK_OCTAVES);
        this.samplesLoaded = Object.keys(this.pianoSampleBuffers).length > 0;
        if (this.samplesLoaded) {
            log(`Initial piano samples (Octaves ${PLAYBACK_OCTAVES.join(',')}) loaded.`);
        } else {
            console.warn(`Initial piano samples (Octaves ${PLAYBACK_OCTAVES.join(',')}) failed to load any samples.`);
        }
    },

    async loadSecondarySounds() {
        if (this.secondaryLoadStarted) return;
        this.secondaryLoadStarted = true;
        log("Starting secondary background sound loading...");
        updateLoadingStatus("Loading additional sounds...", true);

        const loadPromises = [];
        const soundsToLoad = {
            'woodblock': 'woodblock.wav',
            'hihat': 'HiHat.wav', // From default drum set
            'kick': 'Kick.wav',
            'snare': 'Snare.wav'
        };

        for (let [type, filename] of Object.entries(soundsToLoad)) {
            if (!this.soundBuffers[type]) { // Only load if not already loaded (e.g. click)
                loadPromises.push(this.loadSingleSound(type, filename));
            }
        }

        // Load remaining piano octaves
        const remainingOctaves = OCTAVES_FOR_SAMPLES.filter(o => !PLAYBACK_OCTAVES.includes(o));
        if (remainingOctaves.length > 0) {
            loadPromises.push(this.loadPianoSamplesSpecific(remainingOctaves));
        }

        await Promise.allSettled(loadPromises);
        log("Secondary background sound loading complete.");
        updateLoadingStatus("All sounds loaded.", true);
        setTimeout(() => updateLoadingStatus("", false), 1500);
    },

    async loadSingleSound(type, filename) {
        try {
            const response = await fetch(`./${filename}`);
            if (!response.ok) throw new Error(`HTTP error ${response.status} for ${filename}`);
            const arrayBuffer = await response.arrayBuffer();
            this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
            log(`Successfully loaded secondary sound: ${filename}`);
        } catch (e) {
            console.error(`Failed to load secondary sound ${filename}:`, e);
            // Optionally, create a synth fallback for other sounds too if critical
            this.soundBuffers[type] = await this.createDrumSound(type); // Fallback synth sound
            log(`Using synthetic fallback for secondary sound: ${type}`);
        }
    },

    async loadPianoSamplesSpecific(octavesToLoad) {
        let loadedCount = 0;
        const promises = [];
        for (const note of ALL_NOTES_FOR_SAMPLES) { // a, as, b, c, cs ...
            for (const octave of octavesToLoad) {
                if (!OCTAVES_FOR_SAMPLES.includes(octave)) continue; // Ensure octave is valid

                const sampleKey = `${note}${octave}`;
                if (this.pianoSampleBuffers[sampleKey]) continue; // Skip if already loaded

                const filename = getSampleFileName(note, octave);
                promises.push(
                    fetch(filename)
                        .then(response => {
                            if (!response.ok) return Promise.reject(new Error(`HTTP error ${response.status} for ${filename}`));
                            return response.arrayBuffer();
                        })
                        .then(arrayBuffer => this.context.decodeAudioData(arrayBuffer))
                        .then(buffer => {
                            this.pianoSampleBuffers[sampleKey] = buffer;
                            loadedCount++;
                        })
                        .catch(error => {
                            // console.warn(`Failed to load piano sample: ${filename}`, error.message);
                            // Don't log every single failure to avoid console spam if a whole octave is missing
                        })
                );
            }
        }
        await Promise.allSettled(promises);
        if (loadedCount > 0) {
            log(`Loaded ${loadedCount} new piano samples for octaves: [${octavesToLoad.join(', ')}]`);
        } else {
            // console.warn(`No new piano samples loaded for octaves: [${octavesToLoad.join(', ')}] (may have been loaded previously or files missing)`);
        }
        this.samplesLoaded = Object.keys(this.pianoSampleBuffers).length > 0;
    },

    async createDrumSound(type) { // Fallback synthetic drum sounds
        const sampleRate = this.context.sampleRate;
        const duration = type === 'hihat' ? 0.05 : 0.2; // Short for hihat, longer for others
        const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
        const data = buffer.getChannelData(0);

        switch (type) {
            case 'click': // Simple click
                for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
                break;
            case 'hihat': // White noise burst
                for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
                break;
            case 'kick': // Sine wave sweep
                for (let i = 0; i < data.length; i++) {
                    const x = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 100 * Math.exp(-x * 5) * x) * Math.exp(-x * 10) * 2; // Freq sweep down
                }
                break;
            case 'snare': // Noise + sine burst
                 for (let i = 0; i < data.length; i++) {
                    const x = i / sampleRate;
                    data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * x)) * Math.exp(-x * 10) * 1.5;
                }
                break;
            case 'woodblock': // Higher pitched click/tone
                for (let i = 0; i < data.length; i++) {
                    const x = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 800 * x) * Math.exp(-x * 20);
                }
                break;
            default: // Fallback to a simple click if type unknown
                for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
        }
        return buffer;
    },

    async setupReverb() {
        if (!this.context) return;
        if (!this.reverbNode) {
            try {
                this.reverbNode = this.context.createConvolver();
                // Create a simple impulse response
                const sampleRate = this.context.sampleRate;
                const length = sampleRate * 2.5; // 2.5 seconds reverb tail
                const impulse = this.context.createBuffer(2, length, sampleRate);
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5); // Exponential decay
                    }
                }
                this.reverbNode.buffer = impulse;
                log("Reverb node created with synthetic impulse response.");

                // Connect reverb to destination if not already
                if (this.context.destination && !this.reverbNodeConnected) {
                     this.reverbNode.connect(this.context.destination);
                     this.reverbNodeConnected = true;
                     log("Reverb node connected to destination.");
                }

            } catch (e) {
                console.error("Failed to create reverb node:", e);
                this.reverbNode = null; // Disable reverb if creation fails
            }
        }
    }
};

async function ensureAudioInitializedUserInteraction() {
    if (!AppState.audioInitialized) {
        try {
            await AudioContextManager.initialize();
            log("Audio context initialized on user interaction.");
        } catch (e) {
            console.error('Audio initialization failed on user interaction:', e);
            // UI already shows error from initialize()
        }
    }
}

// --- Audio Playback ---
function playNote(noteNameWithOctave, volume = 0.5, duration = 500) {
    if (!AudioContextManager.context || !AudioContextManager.samplesLoaded || !noteNameWithOctave) {
        // console.warn("playNote prerequisites not met: context, samplesLoaded, or noteNameWithOctave missing.");
        return;
    }

    const match = noteNameWithOctave.match(/^([A-G][#bs]?)(\d)$/i);
    if (!match) {
        console.warn(`Invalid note format for playback: ${noteNameWithOctave}`);
        return;
    }
    let [, pitchClass, octaveStr] = match;
    const samplePitchClass = standardizeNoteNameForSamples(pitchClass); // e.g., 'c', 'cs'
    // Clamp octave to available sample range
    const octave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], parseInt(octaveStr)));

    const sampleKey = `${samplePitchClass}${octave}`;
    const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

    if (!buffer) {
        // console.warn(`No audio sample found for ${sampleKey} (original: ${noteNameWithOctave}).`);
        return;
    }

    try {
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;

        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.setValueAtTime(volume, AudioContextManager.context.currentTime);

        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination); // Directly to destination for fretboard clicks

        source.start(AudioContextManager.context.currentTime);
        source.stop(AudioContextManager.context.currentTime + duration / 1000); // Stop after duration
    } catch (e) {
        console.error('Error playing note:', e);
    }
}

async function playChord(root, quality, startTime, duration) {
    if (!UI.elements.chordsEnabled.classList.contains('active') || !AudioContextManager.samplesLoaded) {
        return;
    }
    await AudioContextManager.ensureAudioContext(); // Ensure context is running

    const baseNotes = getChordNotes(root, quality);
    if (!baseNotes || baseNotes.length === 0) {
        console.warn(`Cannot play chord for ${root}${quality}: No notes found.`);
        return;
    }

    const overallVolume = parseFloat(UI.elements.chordVolume.value) * 0.7; // Adjust max volume
    if (overallVolume <= 0) return;

    // Fade out previous chord
    if (AudioContextManager.currentChordGain) {
        try {
            AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, startTime);
            AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05); // Quick fade
        } catch (e) {
            console.warn("Error fading out previous chord:", e);
        }
    }

    // Create a new main gain node for the current chord
    const mainGain = AudioContextManager.context.createGain();
    mainGain.gain.setValueAtTime(0, startTime); // Start silent
    mainGain.gain.linearRampToValueAtTime(overallVolume, startTime + 0.02); // Quick fade in
    mainGain.connect(AudioContextManager.context.destination); // Dry signal
    AudioContextManager.currentChordGain = mainGain;

    // Reverb send
    if (AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0) {
        const reverbDryWet = AudioContextManager.context.createGain();
        reverbDryWet.gain.value = AudioContextManager.reverbAmount; // Control reverb level
        mainGain.connect(reverbDryWet); // Send from chord's main gain
        reverbDryWet.connect(AudioContextManager.reverbNode);
        // Ensure reverb node is connected to destination (should be done in setupReverb)
         if (!AudioContextManager.reverbNodeConnected && AudioContextManager.context.destination) {
            AudioContextManager.reverbNode.connect(AudioContextManager.context.destination);
            AudioContextManager.reverbNodeConnected = true;
        }
    }

    // Simple voicing: spread notes across preferred octaves
    let voicing = [...baseNotes]; // Create a mutable copy
    // Basic inversion to avoid overly muddy low chords - random for now
    const inversion = Math.floor(Math.random() * voicing.length);
    for (let i = 0; i < inversion; i++) {
        voicing.push(voicing.shift());
    }

    const assignedNotesWithOctaves = voicing.map((noteName, index) => {
        let octave = PLAYBACK_OCTAVES[0]; // Default to lower preferred octave
        // Try to spread notes: if current note is lower than first note, push to higher octave
        if (index > 0 && NOTES.indexOf(noteName) < NOTES.indexOf(voicing[0]) && PLAYBACK_OCTAVES.length > 1) {
            octave = PLAYBACK_OCTAVES[1];
        } else if (PLAYBACK_OCTAVES.length > 1 && index > 1) { // Alternate octaves for remaining notes
            octave = PLAYBACK_OCTAVES[index % PLAYBACK_OCTAVES.length];
        }
        // Ensure the chosen octave is within the loadable sample range
        if (!OCTAVES_FOR_SAMPLES.includes(octave)) {
             octave = OCTAVES_FOR_SAMPLES.find(o => o >= PLAYBACK_OCTAVES[0]) || OCTAVES_FOR_SAMPLES[0];
        }
        return { name: noteName, octave: octave };
    });


    assignedNotesWithOctaves.forEach(noteObj => {
        const samplePitchClass = standardizeNoteNameForSamples(noteObj.name);
        const sampleKey = `${samplePitchClass}${noteObj.octave}`;
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

        if (!buffer) {
            // console.warn(`Chord Playback: No sample for ${sampleKey} (root: ${root}, quality: ${quality})`);
            return;
        }

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;

        // Slight humanization of volume per note
        const noteSpecificGain = AudioContextManager.context.createGain();
        noteSpecificGain.gain.value = 0.8 + (Math.random() * 0.2); // Vary volume slightly

        source.connect(noteSpecificGain);
        noteSpecificGain.connect(mainGain); // Connect to the chord's main gain node

        // Slight humanization of timing
        const timingVariance = Math.random() * 0.03; // up to 30ms
        source.start(startTime + timingVariance);
        source.stop(startTime + duration + timingVariance); // Ensure it plays for the full chord duration
    });
}

async function playMetronomeSound(baseVolume) { // baseVolume is from beatElement.dataset.volume
    if (!AudioContextManager.context) return;

    const metronomeOverallVolume = parseFloat(UI.elements.metronomeVolume.value);
    const soundTypeSetting = UI.elements.soundType.value;
    const beatElement = document.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    if (!beatElement) return;

    const soundsToPlayThisBeat = beatElement.dataset.sound.split(',');
    const beatSpecificVolumeFactor = parseFloat(beatElement.dataset.volume); // User clicked volume (0 to 1)

    const isStrongBeatForAccent = parseFloat(beatElement.dataset.baseVolume) >= 0.9; // Original strong beat
    const accentMultiplier = isStrongBeatForAccent ? parseFloat(UI.elements.accentIntensity?.value || 1.0) : 1.0;


    for (let soundKey of soundsToPlayThisBeat) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;

        let bufferToPlay;
        let effectiveSoundKey = soundKey;
        let soundSpecificMixLevel = 1.0; // For individual drum mix

        if (soundTypeSetting === 'drums') {
            const currentDrumSet = drumSoundSets[currentDrumSetIndex];
            let soundFilename;
            switch (soundKey) {
                case 'kick':
                    soundFilename = currentDrumSet.kick;
                    if (UI.elements.kickVolume) soundSpecificMixLevel = parseFloat(UI.elements.kickVolume.value);
                    break;
                case 'snare':
                    soundFilename = currentDrumSet.snare;
                    if (UI.elements.snareVolume) soundSpecificMixLevel = parseFloat(UI.elements.snareVolume.value);
                    break;
                case 'hihat':
                    soundFilename = currentDrumSet.hihat;
                    if (UI.elements.hihatVolume) soundSpecificMixLevel = parseFloat(UI.elements.hihatVolume.value);
                    break;
                default: // If beat data has something else, treat as click for drums
                    effectiveSoundKey = 'click';
                    soundFilename = null; // Will use synthetic click or preloaded click buffer
                    soundSpecificMixLevel = 1.0; // Click sound is not part of drum mix sliders
                    break;
            }

            if (soundFilename) { // A specific drum part (kick, snare, hihat)
                effectiveSoundKey = soundFilename; // e.g. "Kick2.wav"
                if (!AudioContextManager.soundBuffers[soundFilename]) {
                    try {
                        const response = await fetch(`./${soundFilename}`);
                        if (!response.ok) throw new Error(`HTTP ${response.status} for ${soundFilename}`);
                        const arrayBuffer = await response.arrayBuffer();
                        AudioContextManager.soundBuffers[soundFilename] = await AudioContextManager.context.decodeAudioData(arrayBuffer);
                    } catch (e) {
                        console.error(`Failed to load drum sample ${soundFilename} on-the-fly:`, e);
                        // Fallback to generic sound (e.g. 'kick' buffer) if specific drum sample fails
                        bufferToPlay = AudioContextManager.soundBuffers[soundKey] || AudioContextManager.soundBuffers['click'];
                        effectiveSoundKey = soundKey; // Revert to generic key like 'kick' or 'click'
                    }
                }
                bufferToPlay = AudioContextManager.soundBuffers[soundFilename];
            } else { // Fallback if soundFilename was null (e.g. 'click' for drums or non-drum sound)
                 bufferToPlay = AudioContextManager.soundBuffers[effectiveSoundKey] || AudioContextManager.soundBuffers['click'];
            }
        } else { // 'click' or 'woodblock' selected
            effectiveSoundKey = soundTypeSetting; // Use the main sound type
            bufferToPlay = AudioContextManager.soundBuffers[soundTypeSetting] || AudioContextManager.soundBuffers['click'];
            soundSpecificMixLevel = 1.0; // Click/woodblock not part of drum mix
        }

        if (!bufferToPlay) {
            // console.warn(`No buffer for metronome sound: ${effectiveSoundKey}`);
            continue;
        }

        // Calculate final volume for this specific sound part
        let actualFinalVolume = metronomeOverallVolume * beatSpecificVolumeFactor * soundSpecificMixLevel * accentMultiplier;
        actualFinalVolume = Math.min(actualFinalVolume, 1.0); // Cap at 1.0

        if (actualFinalVolume <= 0.001) continue; // Don't play if effectively silent

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = bufferToPlay;
        const gainNode = AudioContextManager.context.createGain();

        gainNode.gain.setValueAtTime(actualFinalVolume, AudioContextManager.context.currentTime);
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);

        if (soundTypeSetting === 'drums' && AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0.01) {
            const reverbSendGain = AudioContextManager.context.createGain();
            reverbSendGain.gain.setValueAtTime(0.05 * AudioContextManager.reverbAmount, AudioContextManager.context.currentTime); // Small fixed send
            gainNode.connect(reverbSendGain); // Send from the sound's gain node
            reverbSendGain.connect(AudioContextManager.reverbNode);
        }

        source.start(AudioContextManager.context.currentTime);
    }
}


// --- Fretboard Drawing ---
function createFretboard(fretboardContainer, tuningArray) {
    if (!(fretboardContainer instanceof HTMLElement)) {
        console.error("Invalid fretboard container provided to createFretboard.");
        return;
    }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) {
        console.error("Invalid or empty tuning array provided to createFretboard.");
        return;
    }

    fretboardContainer.innerHTML = ''; // Clear previous content
    const numFrets = 12;
    const numStrings = tuningArray.length; // tuningArray[0] is low E, tuningArray[numStrings-1] is high E

    // Draw Nut (as a thicker fret line at the very beginning)
    const nutElement = document.createElement('div');
    nutElement.className = 'fret-line'; // Style like a fret line
    nutElement.style.left = '0%';
    nutElement.style.width = '4px'; // Make it thicker
    nutElement.style.backgroundColor = '#4A3B31'; // Darker color for nut
    nutElement.style.zIndex = '1'; // Ensure it's behind notes but visible
    fretboardContainer.appendChild(nutElement);

    // Draw Fret Lines (metal frets)
    for (let i = 1; i <= numFrets; i++) { // Start from 1 for metal frets
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`;
        fretboardContainer.appendChild(fretLine);

        // Fret Numbers
        const fretNumber = document.createElement('div');
        fretNumber.className = 'fret-number';
        fretNumber.textContent = i;
        // Position fret number centered under the fret space it denotes
        fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
        fretboardContainer.appendChild(fretNumber);
    }

    // Draw String Lines
    // stringIndex 0 (low E) should be at visual bottom (larger Y value)
    // stringIndex numStrings-1 (high E) should be at visual top (smaller Y value)
    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        const stringYPosition = (((numStrings - 1 - stringIndex) / (numStrings - 1)) * 96) + 2; // Spread from 2% (top) to 98% (bottom)
        stringLine.style.top = `${stringYPosition}%`;
        fretboardContainer.appendChild(stringLine);
    }

    // Fret Markers (dots)
    const markerPositions = [3, 5, 7, 9, 12];
    markerPositions.forEach(fretPos => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((fretPos - 0.5) / numFrets) * 100}%`; // Center in fret space

        if (fretPos === 12) { // Double dot for 12th fret
            const topMarker = marker.cloneNode(true);
            const bottomMarker = marker.cloneNode(true);
            topMarker.style.top = `33%`;
            bottomMarker.style.top = `67%`;
            fretboardContainer.appendChild(topMarker);
            fretboardContainer.appendChild(bottomMarker);
        } else {
            marker.style.top = '50%'; // Single dot centered vertically
            fretboardContainer.appendChild(marker);
        }
    });
}

function updateFretboardNotes(fretboardContainer, rootNote, scaleName, tuningArray, measureContext = null) {
    // measureContext can be a measureDiv or a measurePartDiv
    // --- Validation & Setup ---
    if (!(fretboardContainer instanceof HTMLElement)) { console.error('Invalid fretboardContainer for updateFretboardNotes'); return; }
    const standardizedRoot = standardizeNoteName(rootNote); // This is the scale root
    if (!NOTES.includes(standardizedRoot)) { console.error(`Invalid root note for scale: ${rootNote}`); return; }
    const scaleData = SCALES[scaleName];
    if (!scaleData) { console.error(`Invalid scale: ${scaleName}`); return; }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) { console.error('Invalid tuning array for updateFretboardNotes'); return; }

    const isStandardGuitarTuning = tuningArray.length === 6 && tuningArray.join('') === "EADGBE";
    // --- End Validation ---

    clearGuideToneHighlights(); // Clear previous highlights before redrawing notes
    fretboardContainer.querySelectorAll('.note').forEach(el => el.remove());


    // --- Update Scale Display (Only for the main chord fretboard) ---
    if (fretboardContainer.id === 'chord-fretboard' && UI.elements.scaleDisplay) {
        const displayScaleRoot = standardizedRoot;
        const displayScaleTypeRaw = scaleName;

        let displayScaleTypeName = displayScaleTypeRaw;
        const tempScaleSelect = document.createElement('select');
        tempScaleSelect.innerHTML = createScaleOptions(displayScaleTypeRaw);
        const selectedOptionEl = tempScaleSelect.querySelector(`option[value="${displayScaleTypeRaw}"]`);
        displayScaleTypeName = selectedOptionEl ? selectedOptionEl.textContent : displayScaleTypeRaw.replace(/([A-Z])/g, ' $1').split(' ').map(s => s.charAt(0).toUpperCase() + s.substring(1)).join(' ').trim();

        let chordRootForDisplay = "";
        let chordQualityTextForDisplay = "";
        
        let actualMeasurePartContext = measureContext;
        if (measureContext && measureContext.classList.contains('measure')) { // If full measure passed, find active part
            actualMeasurePartContext = measureContext.querySelector('.measure-part.part-active') || measureContext.querySelector('.measure-part');
        }


        if (actualMeasurePartContext) {
            chordRootForDisplay = actualMeasurePartContext.querySelector('.chord-controls .root-note')?.value;
            const chordQualityRaw = actualMeasurePartContext.querySelector('.chord-controls .chord-quality')?.value;
            const qualityOption = actualMeasurePartContext.querySelector(`.chord-controls .chord-quality option[value="${chordQualityRaw}"]`);
            if (qualityOption) {
                chordQualityTextForDisplay = qualityOption.textContent;
            } else {
                chordQualityTextForDisplay = chordQualityRaw || "";
                 if (chordQualityRaw === 'dom7') chordQualityTextForDisplay = '7';
                 // ... other mappings
            }
        } else { // Fallback if no specific context or if it's from initial load/first measure
            const firstMeasure = UI.elements.measures.children[0];
            if (firstMeasure) {
                const firstPart = firstMeasure.querySelector('.measure-part');
                if (firstPart) {
                    chordRootForDisplay = firstPart.querySelector('.chord-controls .root-note')?.value;
                    const chordQualityRaw = firstPart.querySelector('.chord-controls .chord-quality')?.value;
                    const qualityOption = firstPart.querySelector(`.chord-controls .chord-quality option[value="${chordQualityRaw}"]`);
                    chordQualityTextForDisplay = qualityOption ? qualityOption.textContent : (chordQualityRaw || "");
                }
            }
        }


        if (chordRootForDisplay && chordQualityTextForDisplay) {
            UI.elements.scaleDisplay.textContent = `${displayScaleRoot} ${displayScaleTypeName} over ${chordRootForDisplay}${chordQualityTextForDisplay}`;
        } else {
            UI.elements.scaleDisplay.textContent = `${displayScaleRoot} ${displayScaleTypeName}`;
        }
    }
    // --- End Update Scale Display ---

    const rootIndex = NOTES.indexOf(standardizedRoot); 
    const notesInScale = scaleData.map(interval => NOTES[(rootIndex + interval) % 12]); 
    const numStrings = tuningArray.length;
    const numFrets = 12; 

    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) {
        const openStringNote = standardizeNoteName(tuningArray[stringIndex]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);
        if (openStringNoteIndex === -1) {
            console.warn(`Could not find index for open string note: ${openStringNote}`);
            continue;
        }

        const FNO_Key = `string${numStrings - stringIndex}`;

        for (let fret = 0; fret <= numFrets; fret++) {
            const currentNoteIndexOnString = (openStringNoteIndex + fret + 12) % 12;
            const currentNoteNameOnString = NOTES[currentNoteIndexOnString];

            if (notesInScale.includes(currentNoteNameOnString)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNoteNameOnString;

                if (fret === 0) { 
                    noteElement.style.left = `-2%`; 
                } else {
                    noteElement.style.left = `${((fret - 0.5) / numFrets) * 100}%`;
                }

                const stringYPosition = (((numStrings - 1 - stringIndex) / (numStrings - 1)) * 96) + 2; 
                noteElement.style.top = `${stringYPosition}%`;

                if (currentNoteNameOnString === standardizedRoot) { 
                    noteElement.style.backgroundColor = '#BD2031'; 
                } else {
                    const degreeInScale = notesInScale.indexOf(currentNoteNameOnString);
                    noteElement.style.backgroundColor = (degreeInScale % 2 === 0) ? '#006400' : '#4CAF50'; 
                }
                
                let noteOctaveForPlayback = `${currentNoteNameOnString}3`; 
                if (isStandardGuitarTuning && FRETBOARD_NOTES_OCTAVES[FNO_Key] && fret < FRETBOARD_NOTES_OCTAVES[FNO_Key].length) {
                    noteOctaveForPlayback = FRETBOARD_NOTES_OCTAVES[FNO_Key][fret];
                } else {
                    let approxOctave = PLAYBACK_OCTAVES[0]; 
                    if (stringIndex < numStrings / 3) { 
                        approxOctave = PLAYBACK_OCTAVES[PLAYBACK_OCTAVES.length -1];
                    } else if (stringIndex < numStrings * 2/3) {
                        approxOctave = PLAYBACK_OCTAVES[Math.floor(PLAYBACK_OCTAVES.length / 2)];
                    }
                    if (fret > 7 && approxOctave < OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1]) {
                         approxOctave = Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], approxOctave + 1);
                    }
                     approxOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], approxOctave));
                    noteOctaveForPlayback = `${currentNoteNameOnString}${approxOctave}`;
                }
                noteElement.dataset.note = noteOctaveForPlayback;

                noteElement.addEventListener('click', async (event) => {
                    event.stopPropagation(); 
                    await AudioContextManager.ensureAudioContext();
                    const noteToPlay = noteElement.dataset.note;
                    const volume = fretboardContainer.id.startsWith('fretflow-fretboard') ? 0.4 : parseFloat(UI.elements.chordFretboardVolume.value);
                    playNote(noteToPlay, volume, 500); 
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                    setTimeout(() => {
                        // Reset transform, respecting if it's a guide/root tone
                        if (noteElement.classList.contains('guide-tone-highlight') || noteElement.classList.contains('root-highlight-for-guides')) {
                            noteElement.style.transform = 'translate(-50%, -50%) scale(0.95)';
                        } else {
                            noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                        }
                    }, 150);
                });
                fretboardContainer.appendChild(noteElement);
            }
        }
    }

    if (AppState.guideTonesActive && fretboardContainer.id === 'chord-fretboard') {
        highlightGuideTones(measureContext); // Pass the context
    }
}

// --- Metronome Beat Display & Interaction ---
function createBeats() {
    const beatsContainer = document.querySelector('.beats-container');
    if (!beatsContainer) return;
    beatsContainer.innerHTML = ''; // Clear existing beats

    if (!UI.elements.timeSignature || !UI.elements.soundType) return;
    const timeSignatureNum = parseInt(UI.elements.timeSignature.value); // Numerator (2, 3, 4, 6, 7, 8, 12)
    const soundType = UI.elements.soundType.value;

    let beatsToDisplay = timeSignatureNum;
    let subdivisionFactor = 1;

    // Determine beats to display for 4/4 (8th notes) vs other time signatures
    if (timeSignatureNum === 4) {
        beatsToDisplay = 8; // Show 8 visual beats for 8th notes if 4/4
        subdivisionFactor = 2;
    } else if ([2,3,6,7,8,12].includes(timeSignatureNum)) {
        beatsToDisplay = timeSignatureNum; // For others, show main beats
        subdivisionFactor = 1;
    }


    for (let i = 0; i < beatsToDisplay; i++) {
        const beatDiv = document.createElement('div');
        beatDiv.className = 'beat';
        beatDiv.dataset.beat = i;

        let beatLabel = `${Math.floor(i / subdivisionFactor) + 1}`;
        if (subdivisionFactor > 1 && (i % subdivisionFactor !== 0)) {
            beatLabel += "&";
        }
        beatDiv.innerHTML = beatLabel;

        let defaultSound = soundType === 'drums' ? 'hihat' : soundType;
        let baseVolume = 0.3;
        let color = '#4CAF50'; // Default color

        // Logic for strong beats, snare hits, etc.
        if (timeSignatureNum === 4) { // Assuming 8 displayed beats (8th notes)
            if (i === 0 || i === 4) { // Strong beats (1 and 3)
                baseVolume = 1.0; color = '#1F618D';
                if (soundType === 'drums') defaultSound = 'kick,hihat';
            } else if (i === 2 || i === 6) { // Backbeats (2 and 4)
                baseVolume = 0.8; color = '#D9534F';
                if (soundType === 'drums') defaultSound = 'snare,hihat';
            } else { // Off-beats
                baseVolume = 0.2; color = '#9E9E9E';
                if (soundType === 'drums') defaultSound = 'hihat';
                else defaultSound = 'silent'; // Silent for non-drum off-beats
            }
        } else { // Other time signatures (main beats displayed)
            if (i === 0) { // First beat is strong
                baseVolume = 1.0; color = '#1F618D';
                if (soundType === 'drums') defaultSound = 'kick,hihat';
            } else if ( (timeSignatureNum === 6 && i === 3) || (timeSignatureNum === 12 && (i === 3 || i === 6 || i === 9)) ) { // Secondary accents
                 baseVolume = 0.8; color = '#2ECC71'; // Different color for secondary
                 if (soundType === 'drums') defaultSound = 'kick,hihat'; // Could be snare too
            } else { // Weaker beats
                baseVolume = 0.3; color = '#9E9E9E';
                if (soundType === 'drums') defaultSound = 'hihat';
            }
        }


        beatDiv.dataset.sound = defaultSound;
        beatDiv.dataset.baseVolume = baseVolume;
        beatDiv.dataset.volume = baseVolume;
        beatDiv.style.backgroundColor = color;

        beatDiv.addEventListener('click', () => {
            toggleBeatAccent(beatDiv, soundType, subdivisionFactor > 1 && (i % subdivisionFactor !== 0));
        });
        beatsContainer.appendChild(beatDiv);
    }
}

function toggleBeatAccent(beatElement, currentSoundType, isSubdivision) {
    const currentVolume = parseFloat(beatElement.dataset.volume);
    let newVolume, newSound, newColor;

    if (currentSoundType === 'drums') {
        const drumCycle = [
            { sound: 'silent', volume: 0, color: '#666' },
            { sound: 'hihat', volume: 0.3, color: '#9E9E9E' },
            { sound: 'snare,hihat', volume: 0.8, color: '#D9534F' },
            { sound: 'kick,hihat', volume: 1.0, color: '#1F618D' }
        ];
        let currentIndex = drumCycle.findIndex(s => s.sound === beatElement.dataset.sound);
        if (currentIndex === -1) currentIndex = 1;

        let nextIndex = (currentIndex + 1) % drumCycle.length;

        // Prevent kick/snare on weak subdivisions if they weren't there already
        if (isSubdivision) {
            const currentIsHeavy = beatElement.dataset.sound.includes('kick') || beatElement.dataset.sound.includes('snare');
            let nextIsHeavy = drumCycle[nextIndex].sound.includes('kick') || drumCycle[nextIndex].sound.includes('snare');
            
            if (nextIsHeavy && !currentIsHeavy) { // Trying to add heavy to a light subdivision
                nextIndex = drumCycle.findIndex(s => s.sound === 'hihat'); // Go to hihat
                if (nextIndex === -1) nextIndex = 1; // Fallback
            }
        }
        newSound = drumCycle[nextIndex].sound;
        newVolume = drumCycle[nextIndex].volume;
        newColor = drumCycle[nextIndex].color;

    } else { // Non-drum sound types
        const simpleCycle = [
            { volume: 0, sound: 'silent', color: '#666' },
            { volume: 0.3, sound: currentSoundType, color: '#9E9E9E' },
            { volume: 1.0, sound: currentSoundType, color: '#1F618D' }
        ];
        let currentIndex = simpleCycle.findIndex(s => s.volume === currentVolume && (s.sound === beatElement.dataset.sound || (s.sound === 'silent' && currentVolume === 0) ));
         if (currentIndex === -1) { // Fallback if state is unusual
            if (currentVolume > 0.5) currentIndex = 2;
            else if (currentVolume > 0) currentIndex = 1;
            else currentIndex = 0;
        }
        const nextState = simpleCycle[(currentIndex + 1) % simpleCycle.length];
        newVolume = nextState.volume;
        newSound = nextState.sound;
        newColor = nextState.color;
    }

    beatElement.dataset.volume = newVolume;
    beatElement.dataset.sound = newSound;
    beatElement.dataset.baseVolume = newVolume; // Update baseVolume as well, as user is overriding
    beatElement.style.backgroundColor = newColor;
}

function onMetronomeInstrumentChange(selectedInstrument) {
    const showDrumsUI = selectedInstrument === "drums";

    if (UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.style.display = showDrumsUI ? "inline-block" : "none";
    }
    if (UI.elements.kickVolumeContainer) UI.elements.kickVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    if (UI.elements.snareVolumeContainer) UI.elements.snareVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    if (UI.elements.hihatVolumeContainer) UI.elements.hihatVolumeContainer.style.display = showDrumsUI ? "flex" : "none";

    createBeats();
}


// --- Playback Loop & Control ---
async function playBeat() {
    const beatsUI = document.querySelectorAll('.beats-container .beat');
    const measures = UI.elements.measures.children;
    if (beatsUI.length === 0) { return; }

    let measureToPlayIndex = AppState.currentMeasure;
    if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
        if (AppState.currentMeasure < AppState.loopStartMeasure || AppState.currentMeasure > AppState.loopEndMeasure) {
            AppState.currentMeasure = AppState.loopStartMeasure;
        }
        measureToPlayIndex = AppState.currentMeasure;
    }

    beatsUI.forEach(b => b.classList.remove('active'));
    const currentBeatElement = beatsUI[AppState.currentBeat];
    if (currentBeatElement) {
        currentBeatElement.classList.add('active');
        const volume = parseFloat(currentBeatElement.dataset.volume); 
        if (volume > 0 || (UI.elements.soundType.value === 'drums' && currentBeatElement.dataset.sound !== 'silent') ) { 
            await playMetronomeSound(volume); 
        }
    }

    if (measures.length > 0 && measureToPlayIndex < measures.length) {
        const currentMeasureElement = measures[measureToPlayIndex];
        Array.from(measures).forEach((m, idx) => m.classList.toggle('active', idx === measureToPlayIndex));
        
        const timeSigNum = parseInt(UI.elements.timeSignature.value);
        const isSplitMeasure = currentMeasureElement.dataset.isSplit === 'true';
        const is44Time = timeSigNum === 4;
        const numDisplayedBeats = beatsUI.length; // 8 for 4/4, timeSigNum otherwise

        let activePartIndex = 0; // Default to first part
        let playThisBeat = AppState.currentBeat === 0; // Play chord on first beat of measure by default

        if (is44Time && isSplitMeasure && numDisplayedBeats === 8) {
            if (AppState.currentBeat < 4) { // First half of split measure (beats 1, 1&, 2, 2&)
                activePartIndex = 0;
                playThisBeat = AppState.currentBeat === 0;
            } else { // Second half (beats 3, 3&, 4, 4&)
                activePartIndex = 1;
                playThisBeat = AppState.currentBeat === 4;
            }
        }
        
        // Highlight active part of measure
        currentMeasureElement.querySelectorAll('.measure-part').forEach((part, idx) => {
            part.classList.toggle('part-active', idx === activePartIndex);
        });

        const activeMeasurePart = currentMeasureElement.querySelectorAll('.measure-part')[activePartIndex];

        if (activeMeasurePart) {
            const root = activeMeasurePart.querySelector('.root-note')?.value;
            const quality = activeMeasurePart.querySelector('.chord-quality')?.value;
            const scaleRoot = activeMeasurePart.querySelector('.second-key')?.value;
            const scaleType = activeMeasurePart.querySelector('.scale-select')?.value;

            if (root && quality && scaleRoot && scaleType) {
                const tuning = TUNINGS[UI.elements.chordTuning.value];
                // Update fretboard only when the active part changes or on first beat of measure
                if (playThisBeat || (is44Time && isSplitMeasure && (AppState.currentBeat === 0 || AppState.currentBeat === 4))) {
                    updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning, activeMeasurePart);
                    if (AppState.guideTonesActive) {
                        highlightGuideTones(activeMeasurePart);
                    }
                }


                if (playThisBeat) {
                    const beatDurationSec = 60 / AppState.tempo;
                    let chordPlayDurationSec = beatDurationSec * timeSigNum; // Full measure duration for non-4/4 or non-split
                    if (is44Time && numDisplayedBeats === 8) { // 4/4 time with 8th note subdivisions
                         chordPlayDurationSec = beatDurationSec * (isSplitMeasure ? 2 : 4); // Half measure for split, full for non-split 4/4
                    }
                    await playChord(root, quality, AudioContextManager.context.currentTime, chordPlayDurationSec);
                }
            }
        }
    }

    const totalBeatsInDisplay = beatsUI.length;
    AppState.currentBeat = (AppState.currentBeat + 1) % totalBeatsInDisplay;

    if (AppState.currentBeat === 0) { // End of measure
        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            AppState.currentMeasure++;
            if (AppState.currentMeasure > AppState.loopEndMeasure) {
                AppState.currentMeasure = AppState.loopStartMeasure;
            }
        } else if (measures.length > 0) {
            AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
        }
        updateNextChordDisplay();
        // Guide tones will be updated by updateFretboardNotes call at start of new measure part
    }
}


async function startPlayback() {
    try {
        await AudioContextManager.ensureAudioContext();
        if (AppState.isPlaying) return;

        const timeSignatureNumerator = parseInt(UI.elements.timeSignature.value);
        let intervalMs = (60 / AppState.tempo) * 1000;

        if (timeSignatureNumerator === 4 && document.querySelectorAll('.beats-container .beat').length === 8) {
            intervalMs /= 2; // Play 8th notes if 4/4 and 8 beats displayed
        }

        AppState.currentBeat = 0; // Reset beat counter for the measure

        if (!AppState.intervalId) { // If starting fresh or after full stop
            AppState.currentMeasure = (AppState.loopingActive && AppState.loopStartMeasure !== -1) ? AppState.loopStartMeasure : 0;
        }
        // else, currentMeasure is preserved from previous state (e.g. tempo change while playing)
        
        await playBeat(); // Play first beat immediately

        clearInterval(AppState.intervalId);
        AppState.intervalId = setInterval(async () => {
            await playBeat();
        }, intervalMs);

        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started.");

    } catch (e) {
        console.error('Failed to start playback:', e);
        stopPlayback();
        alert("Error starting playback. Audio system might not be available.");
    }
}

function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false });

    document.querySelectorAll('.beats-container .beat.active').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));
    document.querySelectorAll('.measure-part.part-active').forEach(p => p.classList.remove('part-active'));


    if (AudioContextManager.currentChordGain && AudioContextManager.context) {
        try {
            const now = AudioContextManager.context.currentTime;
            if (AudioContextManager.currentChordGain.gain) {
                AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, now);
                AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            }
        } catch (rampError) {
            console.warn("Gain ramp error on stop:", rampError.message);
        } finally {
             AudioContextManager.currentChordGain = null;
        }
    }


    if (UI.elements.nextChordDisplay) {
        UI.elements.nextChordDisplay.textContent = "";
    }
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped.");
}

// --- Progression Management & UI Updates ---
function updateNextChordDisplay(currentMeasureIndex = AppState.currentMeasure) {
    const nextChordDisplayElement = UI.elements.nextChordDisplay;
    if (!nextChordDisplayElement) return;

    const measures = UI.elements.measures.children;
    if (measures.length === 0) {
        nextChordDisplayElement.textContent = "";
        return;
    }

    let upcomingChords = [];
    let displayCount = 0;
    let tempMeasureIndex = currentMeasureIndex;
    let tempPartIndex = 0; // 0 for first part, 1 for second part of a split measure

    const currentMeasureEl = measures[currentMeasureIndex];
    if (currentMeasureEl && currentMeasureEl.dataset.isSplit === 'true' && parseInt(UI.elements.timeSignature.value) === 4) {
        // If current measure is split, the "next" sequence starts from its second part, or the next measure
        if (AppState.currentBeat < 4 && beatsUI.length === 8) { // If in first half of split 4/4
            tempPartIndex = 1; // Next is second part of current measure
        } else { // In second half of split 4/4, or not split, or not 4/4
            tempMeasureIndex = (currentMeasureIndex + 1);
            tempPartIndex = 0;
        }
    } else {
         tempMeasureIndex = (currentMeasureIndex + 1);
         tempPartIndex = 0;
    }


    while (displayCount < 4) {
        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            if (tempMeasureIndex > AppState.loopEndMeasure || tempMeasureIndex < AppState.loopStartMeasure) {
                tempMeasureIndex = AppState.loopStartMeasure;
                tempPartIndex = 0;
            }
        } else {
            if (tempMeasureIndex >= measures.length) {
                if (measures.length === 0) break; // No measures at all
                tempMeasureIndex = 0; // Wrap around
                tempPartIndex = 0;
            }
        }
        
        if (tempMeasureIndex >= measures.length) break; // Should not happen if logic above is correct

        const measureElement = measures[tempMeasureIndex];
        if (!measureElement) break;

        const measureParts = measureElement.querySelectorAll('.measure-part');
        const isSplit = measureElement.dataset.isSplit === 'true' && parseInt(UI.elements.timeSignature.value) === 4;

        for (let pIdx = tempPartIndex; pIdx < (isSplit ? 2 : 1) && displayCount < 4; pIdx++) {
            const partElement = measureParts[pIdx];
            if (!partElement) continue;

            const root = partElement.querySelector('.root-note')?.value;
            const qualityRaw = partElement.querySelector('.chord-quality')?.value;

            if (root && qualityRaw) {
                let qualityDisplay = qualityRaw;
                const qualityOption = partElement.querySelector(`.chord-quality option[value="${qualityRaw}"]`);
                qualityDisplay = qualityOption ? qualityOption.textContent : qualityRaw;

                upcomingChords.push(`${root}${qualityDisplay}`);
                displayCount++;
            }
        }
        
        tempMeasureIndex++;
        tempPartIndex = 0; // Reset part index for the next measure
        if (displayCount >= 4 || (tempMeasureIndex === currentMeasureIndex && !AppState.loopingActive && measures.length > 1) ) break; // prevent infinite loop if only 1 measure and not looping
         if (AppState.loopingActive && tempMeasureIndex > AppState.loopEndMeasure && AppState.loopStartMeasure === AppState.loopEndMeasure) break; // Loop of 1 measure
    }

    if (upcomingChords.length > 0) {
        nextChordDisplayElement.textContent = `Next: ${upcomingChords.join(', ')}`;
    } else {
        nextChordDisplayElement.textContent = "";
    }
}


function loadProgression(progressionName, overrideKey = null, isUserSong = false) {
    const songTitleElemFretboard = UI.elements.currentSongTitleFretboard;
    const songDescElemFretboard = UI.elements.currentSongDescriptionFretboard;

    let progressionData;
    if (isUserSong) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        progressionData = userSongs[progressionName];
    } else {
        progressionData = progressions[progressionName];
    }

    if (!progressionName || !progressionData) {
        currentProgressionName = "";
        currentFunctionalProgression = [];
        UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
        if (songTitleElemFretboard) songTitleElemFretboard.textContent = "";
        if (songDescElemFretboard) songDescElemFretboard.textContent = "";
        return;
    }

    currentProgressionName = progressionName;
    currentFunctionalProgression = progressionData.progression; // Store original Roman/absolute strings
    const activeKey = overrideKey || progressionData.defaultKey || "C";

    if (songTitleElemFretboard) songTitleElemFretboard.textContent = progressionData.displayName || progressionName.replace(/_/g, ' ');
    if (songDescElemFretboard) songDescElemFretboard.textContent = progressionData.description || "";


    if (UI.elements.keySelect) UI.elements.keySelect.value = activeKey;
    UI.elements.measures.innerHTML = '';
    resetLoop();

    // The actual chords to display and use for playback will be derived from parsing
    // the `currentFunctionalProgression` strings.
    currentFunctionalProgression.forEach((rawChordString, index) => {
        const measureData = {
            isSplit: progressionData.isSplit && progressionData.isSplit[index], // Check if song data has split info
            parts: []
        };
        
        if (measureData.isSplit && rawChordString.includes('/')) {
            const parts = rawChordString.split('/');
            parts.forEach(partStr => {
                const parsed = parseRomanNumeralToAbsoluteChord(partStr.trim(), activeKey);
                measureData.parts.push({
                    root: parsed.root,
                    quality: parsed.quality,
                    scaleRoot: parsed.root,
                    scaleType: suggestScaleForQuality(parsed.quality),
                    originalRoman: partStr.trim() // Store original part
                });
            });
        } else {
            const parsed = parseRomanNumeralToAbsoluteChord(rawChordString, activeKey);
            measureData.parts.push({
                root: parsed.root,
                quality: parsed.quality,
                scaleRoot: parsed.root,
                scaleType: suggestScaleForQuality(parsed.quality),
                originalRoman: rawChordString
            });
            // If loading a user song that was saved as split, but rawChordString is not /
            // This means user song was saved with DOM structure not raw string.
            // For stock progressions, isSplit will be false.
            if (isUserSong && progressionData.splitStatus && progressionData.splitStatus[index]) {
                 measureData.isSplit = true;
                 // If it was split, the second part would be in progressionData.parts[index][1]
                 if (progressionData.parts && progressionData.parts[index] && progressionData.parts[index][1]) {
                    const p2 = progressionData.parts[index][1];
                     measureData.parts.push({
                        root: p2.root, quality: p2.quality, scaleRoot: p2.scaleRoot, scaleType: p2.scaleType,
                        originalRoman: p2.originalRoman || `${p2.root}${p2.quality}`
                    });
                 } else { // Was marked split but no second part data, duplicate first
                    measureData.parts.push({...measureData.parts[0]});
                 }
            }

        }
        addMeasure(measureData.parts[0].root, measureData.parts[0].quality, measureData.parts[0].scaleRoot, measureData.parts[0].scaleType, measureData.isSplit, measureData.parts[1]);
    });


    updateMeasureNumbers(); // This also sets data-measure-index
    addFirstChordListener(); // Update fretboard for the first chord
    updateNextChordDisplay(0);
    log(`Loaded ${isUserSong ? 'user song' : 'standard progression'}: ${progressionName} in key ${activeKey}`);
}

function updateProgressionKey(newKey) {
    const songTitleElemFretboard = UI.elements.currentSongTitleFretboard;
    const songDescElemFretboard = UI.elements.currentSongDescriptionFretboard;

    if (!currentFunctionalProgression || currentFunctionalProgression.length === 0) {
        if (UI.elements.measures.children.length === 0) {
            const tuning = TUNINGS[UI.elements.chordTuning.value];
            updateFretboardNotes(UI.elements.chordFretboard, newKey, 'major', tuning);
            if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = `${newKey} Major`;
            if (songTitleElemFretboard) songTitleElemFretboard.textContent = "";
            if (songDescElemFretboard) songDescElemFretboard.textContent = "";
            updateNextChordDisplay();
        }
        return;
    }
    
    Array.from(UI.elements.measures.children).forEach((measureElement, measureIndex) => {
        if (measureIndex < currentFunctionalProgression.length) {
            const originalRawChordString = currentFunctionalProgression[measureIndex]; // e.g., "Imaj7" or "Cmaj7" or "Imaj7 / V7"
            
            const measureParts = measureElement.querySelectorAll('.measure-part');
            const isSplit = measureElement.dataset.isSplit === 'true';
            
            const rawParts = isSplit && originalRawChordString.includes('/') ? 
                             originalRawChordString.split('/').map(s => s.trim()) : 
                             [originalRawChordString];

            measureParts.forEach((partElement, partIndex) => {
                // Determine the original Roman numeral or absolute chord for this specific part
                let partOriginalString = rawParts[partIndex] || rawParts[0]; // Fallback to first part's string if not enough
                
                // If the original was from a user song that stored full objects, use that.
                // This part is tricky if user songs save detailed structures vs simple strings.
                // For now, assume currentFunctionalProgression holds the original strings.

                const parsedChord = parseRomanNumeralToAbsoluteChord(partOriginalString, newKey);

                const rootSelect = partElement.querySelector('.root-note');
                const qualitySelect = partElement.querySelector('.chord-quality');
                const scaleKeySelect = partElement.querySelector('.second-key');
                const scaleSelect = partElement.querySelector('.scale-select');

                if (rootSelect) rootSelect.value = parsedChord.root;
                if (qualitySelect) qualitySelect.value = parsedChord.quality;
                if (scaleKeySelect) scaleKeySelect.value = parsedChord.root; // Default scale root to chord root
                if (scaleSelect) scaleSelect.value = suggestScaleForQuality(parsedChord.quality);
            });
        }
    });

    addFirstChordListener();
    updateNextChordDisplay();
    log(`Progression '${currentProgressionName}' re-keyed to: ${newKey}`);
}


function createMeasurePartHTML(data, partIndex = 0) {
    return `
        <div class="measure-part" data-part-index="${partIndex}">
            <div class="chord-controls">
                <select class="root-note">${createKeyOptions(data.root)}</select>
                <select class="chord-quality">${createQualityOptions(data.quality)}</select>
            </div>
            <div class="scale-controls">
                <select class="second-key">${createKeyOptions(data.scaleRoot)}</select>
                <select class="scale-select">${createScaleOptions(data.scaleType)}</select>
            </div>
        </div>`;
}

function addMeasure(
    root = 'C', quality = 'maj7', scaleRoot = 'C', scaleType = 'major', 
    isInitiallySplit = false, secondPartData = null
) {
    const measuresContainer = UI.elements.measures;
    const newMeasureIndex = measuresContainer.children.length;

    const measureDiv = document.createElement('div');
    measureDiv.className = 'measure';
    measureDiv.dataset.measureIndex = newMeasureIndex;
    measureDiv.dataset.isSplit = isInitiallySplit ? 'true' : 'false';
    if (isInitiallySplit) measureDiv.classList.add('split-active');


    let measureHTML = `<div class="measure-header"><span class="measure-number">${newMeasureIndex + 1}</span></div>`;
    
    measureHTML += createMeasurePartHTML({ root, quality, scaleRoot, scaleType }, 0);

    if (isInitiallySplit) {
        const spData = secondPartData || { root, quality, scaleRoot, scaleType }; // Duplicate if no second part data
        measureHTML += createMeasurePartHTML(spData, 1);
    }
    
    measureHTML += `<div class="measure-footer"><button class="split-measure-button">Split</button></div>`;
    measureDiv.innerHTML = measureHTML;
    
    measuresContainer.appendChild(measureDiv);

    measureDiv.querySelectorAll('select').forEach(selectElement => {
        selectElement.addEventListener('change', (event) => {
            const partDiv = event.target.closest('.measure-part');
            handleMeasureControlChange(partDiv, event.target);
        });
    });
    
    measureDiv.querySelector('.measure-header').addEventListener('click', (event) => {
        // Allow clicking header (not selects/button) for loop selection
        if (event.target.tagName !== 'SELECT' && event.target.tagName !== 'BUTTON') {
            toggleMeasureLoopSelection(newMeasureIndex);
        }
    });
    
    const splitButton = measureDiv.querySelector('.split-measure-button');
    splitButton.textContent = isInitiallySplit ? 'Unsplit' : 'Split';
    if (parseInt(UI.elements.timeSignature.value) !== 4) {
        splitButton.disabled = true;
        splitButton.title = "Splitting measures only available in 4/4 time.";
    }
    splitButton.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent measure loop selection
        toggleSplitMeasure(measureDiv);
    });

    updateMeasureNumbers();
    if (newMeasureIndex === 0 && !isInitiallySplit) { // If adding the very first, non-split measure
         addFirstChordListener(); // This will trigger fretboard update
    } else if (isInitiallySplit && newMeasureIndex === 0){
         addFirstChordListener();
    }
    updateNextChordDisplay();
    log(`Added measure ${newMeasureIndex + 1}${isInitiallySplit ? ' (split)' : ''}`);
}


function toggleSplitMeasure(measureDiv) {
    if (parseInt(UI.elements.timeSignature.value) !== 4) {
        alert("Splitting measures is only available in 4/4 time.");
        return;
    }

    const isSplit = measureDiv.dataset.isSplit === 'true';
    const splitButton = measureDiv.querySelector('.split-measure-button');
    const firstPart = measureDiv.querySelector('.measure-part[data-part-index="0"]');

    if (isSplit) { // Unsplit: remove second part
        const secondPart = measureDiv.querySelector('.measure-part[data-part-index="1"]');
        if (secondPart) secondPart.remove();
        measureDiv.dataset.isSplit = 'false';
        measureDiv.classList.remove('split-active');
        splitButton.textContent = 'Split';
    } else { // Split: add second part, cloning from first
        if (!firstPart) return; // Should not happen

        const firstPartData = {
            root: firstPart.querySelector('.root-note').value,
            quality: firstPart.querySelector('.chord-quality').value,
            scaleRoot: firstPart.querySelector('.second-key').value,
            scaleType: firstPart.querySelector('.scale-select').value
        };
        
        const newPartHTML = createMeasurePartHTML(firstPartData, 1);
        // Insert the new part HTML before the footer
        measureDiv.querySelector('.measure-footer').insertAdjacentHTML('beforebegin', newPartHTML);

        // Add event listeners to new selects
        const newSecondPart = measureDiv.querySelector('.measure-part[data-part-index="1"]');
        newSecondPart.querySelectorAll('select').forEach(selectElement => {
            selectElement.addEventListener('change', (event) => {
                const partDiv = event.target.closest('.measure-part');
                handleMeasureControlChange(partDiv, event.target);
            });
        });

        measureDiv.dataset.isSplit = 'true';
        measureDiv.classList.add('split-active');
        splitButton.textContent = 'Unsplit';
    }
    updateNextChordDisplay(); // Update display as measure structure changed
    // Trigger fretboard update for the current active part/measure if needed
    const currentActiveMeasure = document.querySelector('.measure.active');
    if (currentActiveMeasure === measureDiv) {
        const activePart = measureDiv.querySelector('.measure-part.part-active') || firstPart;
        if (activePart) handleMeasureControlChange(activePart, activePart.querySelector('select'));
    }
}



function removeMeasure() {
    const measuresChildren = UI.elements.measures.children;
    if (measuresChildren.length > 0) {
        const removedMeasureIndex = measuresChildren.length - 1;
        if (AppState.loopStartMeasure === removedMeasureIndex || AppState.loopEndMeasure === removedMeasureIndex) {
            resetLoop();
        }
        measuresChildren[measuresChildren.length - 1].remove();
        updateMeasureNumbers();
        if (measuresChildren.length > 0) {
            addFirstChordListener();
        } else {
            if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "Select a progression and key.";
        }
        updateNextChordDisplay();
        log('Removed last measure');
    }
}

function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const numberSpan = measure.querySelector('.measure-number');
        if (numberSpan) {
            numberSpan.textContent = index + 1;
        }
        measure.dataset.measureIndex = index; // Keep this for easier selection
    });
}


function handleMeasureControlChange(measurePartDiv, changedElement) {
    // measurePartDiv is the .measure-part element
    const rootSelect = measurePartDiv.querySelector('.root-note');
    const qualitySelect = measurePartDiv.querySelector('.chord-quality');
    const scaleKeySelect = measurePartDiv.querySelector('.second-key');
    const scaleTypeSelect = measurePartDiv.querySelector('.scale-select');

    if (changedElement.classList.contains('root-note') || changedElement.classList.contains('chord-quality')) {
        const newChordRoot = rootSelect.value;
        const newChordQuality = qualitySelect.value;
        const suggestedScaleType = suggestScaleForQuality(newChordQuality); 

        scaleKeySelect.value = newChordRoot;    
        scaleTypeSelect.value = suggestedScaleType; 
    }

    const currentScaleKeyForFretboard = scaleKeySelect.value;
    const currentScaleTypeForFretboard = scaleTypeSelect.value;
    const currentTuning = TUNINGS[UI.elements.chordTuning.value]; 

    updateFretboardNotes(
        UI.elements.chordFretboard,      
        currentScaleKeyForFretboard,     
        currentScaleTypeForFretboard,    
        currentTuning,
        measurePartDiv // Pass the measurePartDiv as context for scale display
    );

    if (AppState.guideTonesActive) { 
        highlightGuideTones(measurePartDiv); 
    }
    updateNextChordDisplay(); 
    const measureDiv = measurePartDiv.closest('.measure');
    log(`Measure ${parseInt(measureDiv.dataset.measureIndex) + 1}, Part ${measurePartDiv.dataset.partIndex} controls changed.`);
}


// --- User Progression Save/Load ---
function saveCurrentProgression() {
    const measures = Array.from(UI.elements.measures.children);
    if (measures.length === 0) {
        alert("No progression to save!");
        return;
    }

    let progressionName = prompt("Enter a name for this progression:", currentProgressionName || "My Custom Song");
    if (!progressionName || progressionName.trim() === "") {
        alert("Save cancelled or empty name provided.");
        return;
    }
    progressionName = progressionName.trim();

    const savedProgressionData = {
        progression: [], // Will store simple chord strings or "chord1/chord2"
        parts: [], // Will store detailed parts data if split
        splitStatus: [], // Array of booleans
        defaultKey: UI.elements.keySelect.value,
        description: `User saved song - ${new Date().toLocaleDateString()}`,
        displayName: progressionName
    };

    measures.forEach(measureEl => {
        const isSplit = measureEl.dataset.isSplit === 'true';
        savedProgressionData.splitStatus.push(isSplit);
        const measurePartsData = [];
        let measureChordString = "";

        measureEl.querySelectorAll('.measure-part').forEach((partEl, partIdx) => {
            const root = partEl.querySelector('.root-note').value;
            const qualityValue = partEl.querySelector('.chord-quality').value;
            const qualityOption = partEl.querySelector(`.chord-quality option[value="${qualityValue}"]`);
            const qualityText = qualityOption ? qualityOption.textContent : qualityValue;
            
            const partData = {
                root: root,
                quality: qualityValue, // Store the value for consistency
                scaleRoot: partEl.querySelector('.second-key').value,
                scaleType: partEl.querySelector('.scale-select').value,
                originalRoman: `${root}${qualityText}` // Store as absolute for now
            };
            measurePartsData.push(partData);

            if (partIdx > 0) measureChordString += " / ";
            measureChordString += `${root}${qualityText}`;
        });
        savedProgressionData.progression.push(measureChordString);
        savedProgressionData.parts.push(measurePartsData);
    });


    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    userSongs[progressionName] = savedProgressionData;
    localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));

    populateUserSongsDropdown();
    UI.elements.userProgressionSelect.value = progressionName; // Select the newly saved song
    alert(`Progression "${progressionName}" saved!`);
    log(`User progression saved: ${progressionName}`);
    
    // Update current state to reflect the saved song is now "active"
    currentProgressionName = progressionName;
    // currentFunctionalProgression should now reflect the saved structure for re-keying
    currentFunctionalProgression = savedProgressionData.progression.map((chordString, index) => {
        // If it's split, we need to ensure `parseRomanNumeralToAbsoluteChord` can handle it or
        // `updateProgressionKey` is aware of the `parts` data.
        // For simplicity here, `updateProgressionKey` will primarily use the `progression` (roman strings)
        // and re-parse. It might need enhancement if `parts[originalRoman]` becomes very different.
        return chordString; 
    });
}


function isUserSongCurrentlyLoaded() {
    if (!currentProgressionName) return false;
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    return userSongs.hasOwnProperty(currentProgressionName);
}

function populateUserSongsDropdown() {
    const selectElement = UI.elements.userProgressionSelect;
    if (!selectElement) return;
    selectElement.innerHTML = '<option value="">-- Select a saved song --</option>';

    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    Object.keys(userSongs).sort().forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = userSongs[name].displayName || name;
        selectElement.appendChild(option);
    });
}

function deleteSelectedUserSong() {
    const selectedSongName = UI.elements.userProgressionSelect.value;
    if (!selectedSongName) {
        alert("Please select a saved song to delete.");
        return;
    }

    if (confirm(`Are you sure you want to delete the song "${selectedSongName}"? This cannot be undone.`)) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        delete userSongs[selectedSongName];
        localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));

        populateUserSongsDropdown();

        if (currentProgressionName === selectedSongName) {
            UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
            if (UI.elements.currentSongTitleFretboard) UI.elements.currentSongTitleFretboard.textContent = "";
            if (UI.elements.currentSongDescriptionFretboard) UI.elements.currentSongDescriptionFretboard.textContent = "";
            currentProgressionName = "";
            currentFunctionalProgression = [];
            resetLoop();
        }
        alert(`Song "${selectedSongName}" deleted.`);
        log(`User song deleted: ${selectedSongName}`);
    }
}


// --- Looper Functionality ---
function toggleMeasureLoopSelection(measureIndex) {
    if (!AppState.loopingActive) {
        toggleLoopingMode(); // This might show an alert
        if (!AppState.loopingActive) return; // If user cancels or mode doesn't switch
    }

    const measureElement = UI.elements.measures.children[measureIndex];
    if (!measureElement) return;

    measureElement.classList.toggle('loop-selected');

    const selectedIndices = Array.from(UI.elements.measures.children)
        .map((m, i) => m.classList.contains('loop-selected') ? i : -1)
        .filter(i => i !== -1)
        .sort((a, b) => a - b);

    if (selectedIndices.length > 0) {
        AppState.loopStartMeasure = selectedIndices[0];
        AppState.loopEndMeasure = selectedIndices[selectedIndices.length - 1];

        // Ensure all measures between start and end are visually selected
        Array.from(UI.elements.measures.children).forEach((m, i) => {
            m.classList.toggle('loop-selected', i >= AppState.loopStartMeasure && i <= AppState.loopEndMeasure);
        });
    } else { // No measures selected, reset loop
        resetLoop();
    }
    log(`Loop range updated: Start ${AppState.loopStartMeasure}, End ${AppState.loopEndMeasure}`);
}

function resetLoop() {
    AppState.loopStartMeasure = -1;
    AppState.loopEndMeasure = -1;
    Array.from(UI.elements.measures.children).forEach(m => m.classList.remove('loop-selected'));
    log("Loop selection cleared.");
}

function toggleLoopingMode() {
    AppState.loopingActive = !AppState.loopingActive;
    UI.elements.loopSelectedToggle.textContent = AppState.loopingActive ? "Looping ON" : "Looping Off";
    UI.elements.loopSelectedToggle.classList.toggle('active', AppState.loopingActive);
    if (!AppState.loopingActive) {
        resetLoop();
    } else {
        alert("Looping is ON. Click the first and last measures of your desired loop range (or just one measure to loop a single one). Click again to deselect.");
    }
    log(`Looping mode: ${AppState.loopingActive ? 'ON' : 'OFF'}`);
}

// --- Guide Tones Functionality (Item 3) ---
function toggleGuideTones() {
    AppState.guideTonesActive = !AppState.guideTonesActive;
    UI.elements.guideTonesToggle.textContent = AppState.guideTonesActive ? "Guide Tones ON" : "Guide Tones Off";
    UI.elements.guideTonesToggle.classList.toggle('active', AppState.guideTonesActive);
    
    const currentMeasureElement = UI.elements.measures.children[AppState.currentMeasure];
    let activePart = null;
    if(currentMeasureElement){
        activePart = currentMeasureElement.querySelector('.measure-part.part-active') || currentMeasureElement.querySelector('.measure-part');
    }

    if (AppState.guideTonesActive) {
        highlightGuideTones(activePart);
    } else {
        clearGuideToneHighlights();
    }
    log(`Guide tones toggled: ${AppState.guideTonesActive ? 'ON' : 'OFF'}`);
}

function highlightGuideTones(activeMeasurePartContext = null) {
    clearGuideToneHighlights();
    if (!AppState.guideTonesActive) return;

    let chordRootStr, chordQualityStr;

    if (activeMeasurePartContext) {
        chordRootStr = activeMeasurePartContext.querySelector('.root-note')?.value;
        chordQualityStr = activeMeasurePartContext.querySelector('.chord-quality')?.value;
    } else { // Fallback to AppState.currentMeasure if no specific context
        const currentMeasureElement = UI.elements.measures.children[AppState.currentMeasure];
        if (!currentMeasureElement) return;
        const firstPart = currentMeasureElement.querySelector('.measure-part'); // Default to first part
        if (!firstPart) return;
        chordRootStr = firstPart.querySelector('.root-note')?.value;
        chordQualityStr = firstPart.querySelector('.chord-quality')?.value;
    }

    if (!chordRootStr || !chordQualityStr) return;

    const chordRootNote = standardizeNoteName(chordRootStr);
    const chordIntervals = CHORD_INTERVALS[chordQualityStr];
    if (!chordIntervals) return;

    const rootNoteIndex = NOTES.indexOf(chordRootNote);
    if (rootNoteIndex === -1) return;

    // Determine guide tone notes (3rd and 7th/6th)
    const guideToneNotesSet = new Set();
    // 3rd (major or minor)
    if (chordIntervals.includes(3)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 3) % 12]); // Minor 3rd
    else if (chordIntervals.includes(4)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 4) % 12]); // Major 3rd
    
    // 7th (major, minor, or diminished) or 6th
    if (chordQualityStr.includes('6')) { // maj6 or min6
        if (chordIntervals.includes(9)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 9) % 12]); // Major 6th
    } else if (chordIntervals.includes(11)) { // Major 7th
        guideToneNotesSet.add(NOTES[(rootNoteIndex + 11) % 12]);
    } else if (chordIntervals.includes(10)) { // Minor 7th (dominant or minor)
        guideToneNotesSet.add(NOTES[(rootNoteIndex + 10) % 12]);
    } else if (chordIntervals.includes(9) && chordQualityStr === 'dim7') { // Diminished 7th
         guideToneNotesSet.add(NOTES[(rootNoteIndex + 9) % 12]);
    }
    
    UI.elements.chordFretboard.querySelectorAll('.note').forEach(noteElement => {
        const noteNameOnFretboard = noteElement.textContent;
        if (noteNameOnFretboard === chordRootNote) {
            noteElement.classList.add('root-highlight-for-guides');
        } else if (guideToneNotesSet.has(noteNameOnFretboard)) {
            noteElement.classList.add('guide-tone-highlight');
        }
    });
}


function clearGuideToneHighlights() {
    UI.elements.chordFretboard.querySelectorAll('.note').forEach(n => {
        n.classList.remove('guide-tone-highlight');
        n.classList.remove('root-highlight-for-guides');
        // Reset transform if it was scaled down
        n.style.transform = 'translate(-50%, -50%) scale(1)';
    });
}


// --- FretFlow ---
function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) return;

    fretboardsGrid.innerHTML = '';
    fretboardsGrid.style.display = 'grid';
    fretboardsGrid.style.gap = '20px';

    for (let i = 0; i < 4; i++) {
        const fretboardSectionDiv = document.createElement('div');
        fretboardSectionDiv.className = 'fretboard-section';

        const scaleOptionsHTML = Object.entries(SCALES).map(([scaleKey, _]) => {
            const displayName = scaleKey.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase()).trim();
            return `<option value="${scaleKey}">${displayName}</option>`;
        }).join('');

        fretboardSectionDiv.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group">
                    <label for="ff-key-${i}">Key:</label>
                    <select id="ff-key-${i}" class="fretflow-key">${createKeyOptions()}</select>
                </div>
                <div class="control-group">
                    <label for="ff-scale-${i}">Scale:</label>
                    <select id="ff-scale-${i}" class="fretflow-scale">${scaleOptionsHTML}</select>
                </div>
                <div class="control-group">
                    <label for="ff-tuning-${i}">Tuning:</label>
                    <select id="ff-tuning-${i}" class="tuning-select">
                        <option value="standard">Std</option>
                        <option value="dropD">DropD</option>
                        <option value="openG">OpG</option>
                        <option value="DADGAD">DADGAD</option>
                        <option value="openE">OpE</option>
                    </select>
                </div>
            </div>
            <div class="scale-display" id="ff-scale-display-${i}"></div>
            <div id="ff-fretboard-${i}" class="fretboard"></div>`;
        fretboardsGrid.appendChild(fretboardSectionDiv);

        const fretboardElement = fretboardSectionDiv.querySelector(`#ff-fretboard-${i}`);
        const keySelectElement = fretboardSectionDiv.querySelector(`#ff-key-${i}`);
        const scaleSelectElement = fretboardSectionDiv.querySelector(`#ff-scale-${i}`);
        const tuningSelectElement = fretboardSectionDiv.querySelector(`#ff-tuning-${i}`);
        const scaleDisplayElement = fretboardSectionDiv.querySelector(`#ff-scale-display-${i}`);

        function updateFretflowFretboard() {
            const selectedKey = keySelectElement.value;
            const selectedScale = scaleSelectElement.value;
            const selectedTuningValue = tuningSelectElement.value;
            const selectedTuningArray = TUNINGS[selectedTuningValue];

            if (!selectedTuningArray) {
                console.error("Invalid tuning selected for FretFlow instance.");
                return;
            }
            const selectedScaleDisplayName = scaleSelectElement.options[scaleSelectElement.selectedIndex].text;
            scaleDisplayElement.textContent = `${selectedKey} ${selectedScaleDisplayName}`;

            createFretboard(fretboardElement, selectedTuningArray);
            updateFretboardNotes(fretboardElement, selectedKey, selectedScale, selectedTuningArray);
        }

        keySelectElement.addEventListener('change', updateFretflowFretboard);
        scaleSelectElement.addEventListener('change', updateFretflowFretboard);
        tuningSelectElement.addEventListener('change', updateFretflowFretboard);

        updateFretflowFretboard();
    }
    log("FretFlow initialized with 2x2 grid.");
}

// --- Event Handling Helpers ---
function addFirstChordListener() {
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const firstPart = firstMeasure.querySelector('.measure-part[data-part-index="0"]');
        if (firstPart) {
            const scaleRootSelect = firstPart.querySelector('.scale-controls .second-key');
            const scaleTypeSelect = firstPart.querySelector('.scale-controls .scale-select');
            const tuningSelect = UI.elements.chordTuning;

            const updatePrimaryFretboard = () => {
                if (scaleRootSelect && scaleTypeSelect && tuningSelect) {
                    const tuning = TUNINGS[tuningSelect.value];
                    updateFretboardNotes(UI.elements.chordFretboard, scaleRootSelect.value, scaleTypeSelect.value, tuning, firstPart);
                }
            };
            updatePrimaryFretboard(); // Initial update
        }
    } else { // No measures exist
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, "C", "major", tuning); // Default display
        if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "C Major (Default)";
    }
}


// --- Event Listeners Setup ---
function setupEventListeners() {
    document.body.addEventListener('click', ensureAudioInitializedUserInteraction, { once: true });

    UI.elements.startStopButton.addEventListener('click', () => {
        if (AppState.isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    });

    if (UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.addEventListener('click', () => {
            currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
            UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
            log(`Switched to drum set: ${drumSoundSets[currentDrumSetIndex].name}`);
        });
    }

    if (UI.elements.soundType) {
        UI.elements.soundType.addEventListener('change', (e) => onMetronomeInstrumentChange(e.target.value));
        onMetronomeInstrumentChange(UI.elements.soundType.value); 
    }

    let currentDarkModeIndex = 0;
    const darkModeClasses = ['', 'dark-mode', 'dark-mode-2', 'dark-mode-3'];
    const activeToggleClasses = ['', 'active', 'active-2', 'active-3'];
    UI.elements.darkModeToggle.addEventListener('click', () => {
        currentDarkModeIndex = (currentDarkModeIndex + 1) % darkModeClasses.length;
        darkModeClasses.forEach(cls => { if (cls) document.body.classList.remove(cls); });
        activeToggleClasses.forEach(cls => { if (cls) UI.elements.darkModeToggle.classList.remove(cls); });

        if (currentDarkModeIndex > 0) {
            document.body.classList.add(darkModeClasses[currentDarkModeIndex]);
            UI.elements.darkModeToggle.classList.add(activeToggleClasses[currentDarkModeIndex]);
        }
        log(`Color mode switched to: ${darkModeClasses[currentDarkModeIndex] || 'Light Mode'}`);
    });


    UI.elements.chordsEnabled.addEventListener('click', () => {
        const isActive = UI.elements.chordsEnabled.classList.toggle('active');
        UI.elements.chordsEnabled.textContent = isActive ? 'Chords Enabled' : 'Chords Disabled';
        log(`Chord playback ${isActive ? 'enabled' : 'disabled'}`);
    });

    UI.elements.tempo.addEventListener('input', () => {
        AppState.tempo = parseInt(UI.elements.tempo.value);
        UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        if (AppState.isPlaying) {
            stopPlayback(); // stop resets intervalId
            startPlayback(); // start uses current AppState.tempo
        }
    });

    UI.elements.tapTempo.addEventListener('click', () => {
        const now = Date.now();
        AppState.tapTempoTimestamps.push(now);
        if (AppState.tapTempoTimestamps.length > 4) {
            AppState.tapTempoTimestamps.shift();
        }

        if (AppState.tapTempoTimestamps.length > 1) {
            let totalInterval = 0;
            for (let i = 1; i < AppState.tapTempoTimestamps.length; i++) {
                totalInterval += AppState.tapTempoTimestamps[i] - AppState.tapTempoTimestamps[i-1];
            }
            const averageInterval = totalInterval / (AppState.tapTempoTimestamps.length - 1);
            if (averageInterval > 0 && averageInterval < 3000) { // Avoid extreme BPMs
                const bpm = Math.round(60000 / averageInterval);
                AppState.tempo = Math.max(40, Math.min(220, bpm));
                UI.elements.tempo.value = AppState.tempo;
                UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                if (AppState.isPlaying) {
                    stopPlayback();
                    startPlayback();
                }
            }
        }
        // Reset timestamps if idle for too long
        setTimeout(() => {
            if (AppState.tapTempoTimestamps.length > 0 && (Date.now() - AppState.tapTempoTimestamps[AppState.tapTempoTimestamps.length - 1] > 3000)) {
                AppState.tapTempoTimestamps = []; // Clear array
            }
        }, 3100); // A bit longer than the max interval considered
    });

    UI.elements.timeSignature.addEventListener('change', () => {
        createBeats();
        // Update split buttons in all measures
        const is44 = parseInt(UI.elements.timeSignature.value) === 4;
        document.querySelectorAll('.measure .split-measure-button').forEach(btn => {
            btn.disabled = !is44;
            btn.title = is44 ? "" : "Splitting measures only available in 4/4 time.";
            // If changing away from 4/4, unsplit any split measures
            if (!is44) {
                const measureDiv = btn.closest('.measure');
                if (measureDiv.dataset.isSplit === 'true') {
                    toggleSplitMeasure(measureDiv); // This will unsplit it
                }
            }
        });

        if (AppState.isPlaying) {
            stopPlayback();
            startPlayback();
        }
    });


    if (UI.elements.reverbDial && UI.elements.reverbDialValue) {
        UI.elements.reverbDial.addEventListener('input', function(event) {
            const value = parseInt(event.target.value, 10);
            AudioContextManager.reverbAmount = value / 100;
            UI.elements.reverbDialValue.textContent = value;
            log(`Reverb amount set to: ${AudioContextManager.reverbAmount}`);
        });
    }

    UI.elements.progressionSelect.addEventListener('change', (event) => {
        const selectedProgression = event.target.value;
        loadProgression(selectedProgression, null, false);
        if (selectedProgression && UI.elements.userProgressionSelect) {
            UI.elements.userProgressionSelect.value = "";
        }
    });

    if (UI.elements.userProgressionSelect) {
        UI.elements.userProgressionSelect.addEventListener('change', (event) => {
            const selectedSong = event.target.value;
            if (selectedSong) {
                const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
                const keyForUserSong = userSongs[selectedSong]?.defaultKey || UI.elements.keySelect.value;
                loadProgression(selectedSong, keyForUserSong, true);
                 if (UI.elements.progressionSelect) UI.elements.progressionSelect.value = "";
            }
        });
    }

    UI.elements.keySelect.addEventListener('change', (event) => {
        updateProgressionKey(event.target.value);
    });

    UI.elements.chordTuning.addEventListener('change', () => {
        addFirstChordListener(); // This will update the main fretboard
        initializeFretFlow(); // Reinitialize FretFlow fretboards with new default tuning
    });


    if (UI.elements.saveProgressionButton) {
        UI.elements.saveProgressionButton.addEventListener('click', saveCurrentProgression);
    }
    if (UI.elements.deleteUserSongButton) {
        UI.elements.deleteUserSongButton.addEventListener('click', deleteSelectedUserSong);
    }

    if (UI.elements.guideTonesToggle) {
        UI.elements.guideTonesToggle.addEventListener('click', toggleGuideTones);
    }
    if (UI.elements.loopSelectedToggle) {
        UI.elements.loopSelectedToggle.addEventListener('click', toggleLoopingMode);
    }

    // Item 5: Keyboard shortcuts
    document.addEventListener('keydown', (event) => {
        // Prevent shortcuts if focus is on an input, select, or textarea
        const targetTagName = event.target.tagName.toLowerCase();
        if (targetTagName === 'input' || targetTagName === 'select' || targetTagName === 'textarea') {
            return;
        }

        let tempoChanged = false;
        if (event.key === ' ' || event.code === 'Space') {
            event.preventDefault(); // Prevent page scroll
            UI.elements.startStopButton.click();
        } else if (event.key === 'ArrowUp' || event.code === 'ArrowUp') {
            event.preventDefault();
            let currentTempo = parseInt(UI.elements.tempo.value);
            currentTempo = Math.min(220, currentTempo + 1);
            UI.elements.tempo.value = currentTempo;
            AppState.tempo = currentTempo;
            UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            tempoChanged = true;
        } else if (event.key === 'ArrowDown' || event.code === 'ArrowDown') {
            event.preventDefault();
            let currentTempo = parseInt(UI.elements.tempo.value);
            currentTempo = Math.max(40, currentTempo - 1);
            UI.elements.tempo.value = currentTempo;
            AppState.tempo = currentTempo;
            UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            tempoChanged = true;
        }

        if (tempoChanged && AppState.isPlaying) {
            stopPlayback();
            startPlayback();
        }
    });


    log("Event listeners set up.");
}

// --- Initialize App ---
async function initializeApp() {
    UI.init();
    createBeats();

    const initialTuningValue = UI.elements.chordTuning?.value || 'standard';
    const initialTuningArray = TUNINGS[initialTuningValue] || TUNINGS.standard;
    createFretboard(UI.elements.chordFretboard, initialTuningArray);

    populateUserSongsDropdown();

    const initialProgressionName = UI.elements.progressionSelect?.value || Object.keys(progressions)[0];
    const initialKey = UI.elements.keySelect?.value || progressions[initialProgressionName]?.defaultKey || "C";
    loadProgression(initialProgressionName, initialKey, false);

    initializeFretFlow();

    setupEventListeners();

    try {
        await AudioContextManager.initialize();
    } catch (e) {
        updateLoadingStatus("Audio initialization failed. Click anywhere to retry.", true);
    }

    updateLoadingStatus("Application initialized.", true);
    setTimeout(() => updateLoadingStatus("", false), 1500);
    log("Application initialized.");
}


// --- DOM Ready Listener ---
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Application initialization failed:", error);
        updateLoadingStatus("Fatal Error: Application could not initialize. Check console.", true);
    });
});

    </script>
</body>
</html>
