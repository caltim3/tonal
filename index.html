<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png"> <!-- Ensure jazzmaster.png is in the same directory -->
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light Mode (Default) */
            --lm-bg: #f0f8ff; /* AliceBlue */
            --lm-bg-alt: #ffffff; /* White */
            --lm-text: #333333; /* Dark Gray */
            --lm-accent: #1f618d; /* Original Blue */
            --lm-accent-hover: #154360; /* Darker Blue */
            --lm-border: #cccccc; /* Light Gray */
            --lm-fretboard-bg: #FFCF79; /* Original Fretboard */
            --lm-fretboard-border: #4B1C2E; /* Original Fretboard Border */
            --lm-note-bg: #1f618d;
            --lm-note-text: white;
            --lm-note-hover-bg: #154360;
            --lm-button-bg: #e0e0e0;
            --lm-button-text: #333333;
            --lm-button-hover-bg: #d0d0d0;
            --lm-input-bg: #ffffff;
            --lm-input-border: #cccccc;
            --lm-input-text: #333333;

            /* Dark Mode 1 (Greenish) */
            --dm1-bg: #283618;
            --dm1-bg-alt: #3a5a40; /* Darker green for fretboard container */
            --dm1-text: #fefae0;
            --dm1-accent: #dda15e;
            --dm1-accent-hover: #bc6c25;
            --dm1-border: #606c38; /* Slightly lighter for borders within dm1 */
            --dm1-fretboard-bg: #606c38; /* Main fretboard wood */
            --dm1-fretboard-border: #fefae0; /* Light border for fretboard */
            --dm1-note-bg: var(--dm1-accent);
            --dm1-note-text: var(--dm1-bg);
            --dm1-note-hover-bg: var(--dm1-accent-hover);
            --dm1-button-bg: var(--dm1-accent);
            --dm1-button-text: var(--dm1-bg);
            --dm1-button-hover-bg: var(--dm1-accent-hover);
            --dm1-input-bg: var(--dm1-bg-alt);
            --dm1-input-border: var(--dm1-accent);
            --dm1-input-text: var(--dm1-text);


            /* Dark Mode 2 (Deep Blue) */
            --dm2-bg: #0a1128;
            --dm2-bg-alt: #001f54; /* Darker blue for fretboard container */
            --dm2-text: #fefcfb;
            --dm2-accent: #1282a2;
            --dm2-accent-hover: #0a6b8b;
            --dm2-border: #034078; /* Mid blue for borders */
            --dm2-fretboard-bg: #034078; /* Main fretboard wood */
            --dm2-fretboard-border: var(--dm2-accent);
            --dm2-note-bg: var(--dm2-accent);
            --dm2-note-text: var(--dm2-bg);
            --dm2-note-hover-bg: var(--dm2-accent-hover);
            --dm2-button-bg: var(--dm2-accent);
            --dm2-button-text: var(--dm2-bg);
            --dm2-button-hover-bg: var(--dm2-accent-hover);
            --dm2-input-bg: var(--dm2-bg-alt);
            --dm2-input-border: var(--dm2-accent);
            --dm2-input-text: var(--dm2-text);

            /* Dark Mode 3 (Earthy/Brown) */
            --dm3-bg: #3d405b; /* Dark grayish purple */
            --dm3-bg-alt: #545877; /* Lighter grayish purple for fretboard container */
            --dm3-text: #f4f1de; /* Creamy white */
            --dm3-accent: #e07a5f; /* Terracotta */
            --dm3-accent-hover: #d45d3d; /* Darker Terracotta */
            --dm3-border: #81b29a; /* Muted green for borders */
            --dm3-fretboard-bg: #6b705c; /* Olive green for fretboard wood */
            --dm3-fretboard-border: var(--dm3-accent);
            --dm3-note-bg: var(--dm3-accent);
            --dm3-note-text: var(--dm3-bg);
            --dm3-note-hover-bg: var(--dm3-accent-hover);
            --dm3-button-bg: var(--dm3-accent);
            --dm3-button-text: var(--dm3-bg);
            --dm3-button-hover-bg: var(--dm3-accent-hover);
            --dm3-input-bg: var(--dm3-bg-alt);
            --dm3-input-border: var(--dm3-accent);
            --dm3-input-text: var(--dm3-text);

            --transition-speed: 0.3s;
        }

        body {
            font-family: 'Lato', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--lm-bg);
            color: var(--lm-text);
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        .app-section, #fretflow-section {
            background: var(--lm-bg-alt);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border: 1px solid var(--lm-border);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        .fretboard-container {
            background: var(--lm-bg-alt);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid var(--lm-border);
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .fretboard {
            position: relative;
            height: 200px; /* Adjust as needed */
            background-color: var(--lm-fretboard-bg);
            border-radius: 5px;
            margin-bottom: 30px;
            border: 2px solid var(--lm-fretboard-border);
            overflow: visible; /* Changed from hidden to allow fret numbers outside */
            transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }

        .fret-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px; /* Standard fret line */
            background: #c0c0c0; /* Light gray for fret wire */
            border-right: 1px solid rgba(0, 0, 0, 0.2); /* Subtle shadow */
            z-index: 1;
        }
        .fret-line:first-child { /* Nut */
            width: 6px; /* Thicker nut */
            background: #5c3c20; /* Darker wood color for nut */
        }

        .string-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px; /* Thin string */
            background: silver;
            border-bottom: 1px solid rgba(0, 0, 0, 0.2); /* Subtle shadow */
            z-index: 0;
        }
        /* Thicker strings for lower notes - example for 6 strings */
        .string-line:nth-last-child(-n+1) { height: 3px; } /* Low E */
        .string-line:nth-last-child(-n+2):not(:nth-last-child(-n+1)) { height: 2.5px; } /* A string */
        .string-line:nth-last-child(-n+3):not(:nth-last-child(-n+2)) { height: 2px; } /* D string */


        .fret-number {
            position: absolute;
            bottom: -25px; /* Position below the fretboard */
            font-size: 12px; /* Smaller font for fret numbers */
            color: var(--lm-text); /* Use theme text color */
            transform: translateX(-50%);
            font-weight: bold;
            z-index: 2;
            width: 20px;
            text-align: center;
            transition: color var(--transition-speed) ease;
        }

        .fret-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #333; /* Dark inlay */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 0; /* Below strings but above fretboard wood */
        }
        body.dark-mode .fret-marker,
        body.dark-mode-2 .fret-marker,
        body.dark-mode-3 .fret-marker {
            background-color: #f0f0f0; /* Light inlay for dark modes */
        }


        .note {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: var(--lm-note-text);
            background-color: var(--lm-note-bg);
            border: 1px solid rgba(0,0,0,0.2);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            z-index: 3;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease, background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        .note:hover {
            transform: translate(-50%, -50%) scale(1.2);
            background-color: var(--lm-note-hover-bg);
        }
        .note.root-note-highlight { /* Style for root notes */
            border: 2px solid gold;
            box-shadow: 0 0 8px gold;
        }
        .note.scale-note-highlight { /* Style for other scale notes */
            opacity: 0.9;
        }
        .note.note-active-feedback { /* For click feedback */
            transform: translate(-50%, -50%) scale(1.1);
            filter: brightness(1.5);
        }

        .scale-display {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: var(--lm-text);
            transition: color var(--transition-speed) ease;
        }

        .controls, .controls-container, .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group label {
            font-weight: bold;
            color: var(--lm-text);
            transition: color var(--transition-speed) ease;
        }

        button, .control-button, .toggle-button {
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid var(--lm-border);
            background-color: var(--lm-button-bg);
            color: var(--lm-button-text);
            cursor: pointer;
            font-weight: bold;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        button:hover, .control-button:hover, .toggle-button:hover {
            background-color: var(--lm-button-hover-bg);
        }
        .toggle-button.active {
            background-color: var(--lm-accent);
            color: var(--lm-bg-alt);
            border-color: var(--lm-accent-hover);
        }

        select, input[type="text"], input[type="number"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid var(--lm-input-border);
            background-color: var(--lm-input-bg);
            color: var(--lm-input-text);
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        input[type="range"] {
            cursor: pointer;
        }
        #tempo-display, .volume-control span, #reverb-dial-value {
            color: var(--lm-text);
            transition: color var(--transition-speed) ease;
        }

        .beats-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            flex-wrap: nowrap; /* Keep beats in a single line */
            overflow-x: auto; /* Allow horizontal scrolling if too many beats */
            padding-bottom: 10px; /* Space for scrollbar if it appears */
        }
        .beat {
            min-width: 40px; /* Ensure beats have a minimum width */
            height: 70px; /* Slightly shorter */
            padding: 5px;
            background: #9E9E9E;
            border-radius: 8px; /* Softer radius */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 12px; /* Smaller text */
            text-align: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .beat.active {
            transform: translateY(-5px) scale(1.05); /* More subtle active state */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #measures {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* Responsive measures */
            gap: 20px;
        }
        .measure {
            position: relative;
            background-color: var(--lm-input-bg); /* Use input bg for consistency */
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--lm-border);
            transition: opacity 0.2s ease, background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .measure.dragging { opacity: 0.5; }
        .measure.active {
            background-color: var(--lm-accent); /* Use accent for active measure */
            border-color: var(--lm-accent-hover);
            color: var(--lm-bg-alt); /* Text color for active measure */
        }
        .measure.active .measure-number,
        .measure.active .chord-controls label,
        .measure.active .scale-controls label {
            color: var(--lm-bg-alt); /* Ensure labels inside active measure are also light */
        }
        .measure-number {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            color: var(--lm-text);
            transition: color var(--transition-speed) ease;
        }
        .chord-controls, .scale-controls {
            display: flex;
            flex-direction: column; /* Stack labels and selects vertically */
            gap: 8px;
            margin-bottom: 10px;
        }
        .chord-controls div, .scale-controls div { /* Group label and select */
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .chord-controls select, .scale-controls select {
            flex: 1; /* Allow select to take available space */
        }
        .delete-measure-btn {
            position: absolute;
            top: 5px;
            left: 5px;
            background: transparent;
            border: none;
            color: #ff4d4d;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 5px;
        }
        .delete-measure-btn:hover { color: #cc0000; }


        /* --- Dark Mode 1 (Greenish) --- */
        body.dark-mode { background-color: var(--dm1-bg); color: var(--dm1-text); }
        body.dark-mode .app-section, body.dark-mode #fretflow-section { background: linear-gradient(145deg, var(--dm1-bg), var(--dm1-bg-alt)); color: var(--dm1-text); border-color: var(--dm1-border); }
        body.dark-mode .fretboard-container { background-color: var(--dm1-bg-alt); border-color: var(--dm1-accent); }
        body.dark-mode .fretboard { background-color: var(--dm1-fretboard-bg); border-color: var(--dm1-fretboard-border); }
        body.dark-mode .fret-number { color: var(--dm1-text); }
        body.dark-mode .note { background-color: var(--dm1-note-bg); color: var(--dm1-note-text); border-color: var(--dm1-accent-hover); }
        body.dark-mode .note:hover { background-color: var(--dm1-note-hover-bg); }
        body.dark-mode .scale-display, body.dark-mode .control-group label, body.dark-mode #tempo-display, body.dark-mode .volume-control span, body.dark-mode #reverb-dial-value { color: var(--dm1-text); }
        body.dark-mode button, body.dark-mode .control-button, body.dark-mode .toggle-button { background-color: var(--dm1-button-bg); color: var(--dm1-button-text); border-color: var(--dm1-accent-hover); }
        body.dark-mode button:hover, body.dark-mode .control-button:hover, body.dark-mode .toggle-button:hover { background-color: var(--dm1-button-hover-bg); }
        body.dark-mode .toggle-button.active { background-color: var(--dm1-accent-hover); color: var(--dm1-text); border-color: var(--dm1-accent); }
        body.dark-mode select, body.dark-mode input[type="text"], body.dark-mode input[type="number"] { background-color: var(--dm1-input-bg); color: var(--dm1-input-text); border-color: var(--dm1-input-border); }
        body.dark-mode .measure { background-color: var(--dm1-bg-alt); color: var(--dm1-text); border-color: var(--dm1-border); }
        body.dark-mode .measure.active { background-color: var(--dm1-accent); border-color: var(--dm1-accent-hover); color: var(--dm1-bg); }
        body.dark-mode .measure.active .measure-number, body.dark-mode .measure.active .chord-controls label, body.dark-mode .measure.active .scale-controls label { color: var(--dm1-bg); }
        body.dark-mode .beat { background-color: var(--dm1-accent); color: var(--dm1-bg); }
        body.dark-mode .beat.active { background-color: var(--dm1-accent-hover); transform: translateY(-5px) scale(1.05); }

        /* --- Dark Mode 2 (Deep Blue) --- */
        body.dark-mode-2 { background-color: var(--dm2-bg); color: var(--dm2-text); }
        body.dark-mode-2 .app-section, body.dark-mode-2 #fretflow-section { background: linear-gradient(145deg, var(--dm2-bg), var(--dm2-bg-alt)); color: var(--dm2-text); border-color: var(--dm2-border); }
        body.dark-mode-2 .fretboard-container { background-color: var(--dm2-bg-alt); border-color: var(--dm2-accent); }
        body.dark-mode-2 .fretboard { background-color: var(--dm2-fretboard-bg); border-color: var(--dm2-fretboard-border); }
        body.dark-mode-2 .fret-number { color: var(--dm2-text); }
        body.dark-mode-2 .note { background-color: var(--dm2-note-bg); color: var(--dm2-note-text); border-color: var(--dm2-accent-hover); }
        body.dark-mode-2 .note:hover { background-color: var(--dm2-note-hover-bg); }
        body.dark-mode-2 .scale-display, body.dark-mode-2 .control-group label, body.dark-mode-2 #tempo-display, body.dark-mode-2 .volume-control span, body.dark-mode-2 #reverb-dial-value { color: var(--dm2-text); }
        body.dark-mode-2 button, body.dark-mode-2 .control-button, body.dark-mode-2 .toggle-button { background-color: var(--dm2-button-bg); color: var(--dm2-button-text); border-color: var(--dm2-accent-hover); }
        body.dark-mode-2 button:hover, body.dark-mode-2 .control-button:hover, body.dark-mode-2 .toggle-button:hover { background-color: var(--dm2-button-hover-bg); }
        body.dark-mode-2 .toggle-button.active { background-color: var(--dm2-accent-hover); color: var(--dm2-text); border-color: var(--dm2-accent); }
        body.dark-mode-2 select, body.dark-mode-2 input[type="text"], body.dark-mode-2 input[type="number"] { background-color: var(--dm2-input-bg); color: var(--dm2-input-text); border-color: var(--dm2-input-border); }
        body.dark-mode-2 .measure { background-color: var(--dm2-bg-alt); color: var(--dm2-text); border-color: var(--dm2-border); }
        body.dark-mode-2 .measure.active { background-color: var(--dm2-accent); border-color: var(--dm2-accent-hover); color: var(--dm2-bg); }
        body.dark-mode-2 .measure.active .measure-number, body.dark-mode-2 .measure.active .chord-controls label, body.dark-mode-2 .measure.active .scale-controls label { color: var(--dm2-bg); }
        body.dark-mode-2 .beat { background-color: var(--dm2-accent); color: var(--dm2-bg); }
        body.dark-mode-2 .beat.active { background-color: var(--dm2-accent-hover); transform: translateY(-5px) scale(1.05); }

        /* --- Dark Mode 3 (Earthy/Brown) --- */
        body.dark-mode-3 { background-color: var(--dm3-bg); color: var(--dm3-text); }
        body.dark-mode-3 .app-section, body.dark-mode-3 #fretflow-section { background: linear-gradient(145deg, var(--dm3-bg), var(--dm3-bg-alt)); color: var(--dm3-text); border-color: var(--dm3-border); }
        body.dark-mode-3 .fretboard-container { background-color: var(--dm3-bg-alt); border-color: var(--dm3-accent); }
        body.dark-mode-3 .fretboard { background-color: var(--dm3-fretboard-bg); border-color: var(--dm3-fretboard-border); }
        body.dark-mode-3 .fret-number { color: var(--dm3-text); }
        body.dark-mode-3 .note { background-color: var(--dm3-note-bg); color: var(--dm3-note-text); border-color: var(--dm3-accent-hover); }
        body.dark-mode-3 .note:hover { background-color: var(--dm3-note-hover-bg); }
        body.dark-mode-3 .scale-display, body.dark-mode-3 .control-group label, body.dark-mode-3 #tempo-display, body.dark-mode-3 .volume-control span, body.dark-mode-3 #reverb-dial-value { color: var(--dm3-text); }
        body.dark-mode-3 button, body.dark-mode-3 .control-button, body.dark-mode-3 .toggle-button { background-color: var(--dm3-button-bg); color: var(--dm3-button-text); border-color: var(--dm3-accent-hover); }
        body.dark-mode-3 button:hover, body.dark-mode-3 .control-button:hover, body.dark-mode-3 .toggle-button:hover { background-color: var(--dm3-button-hover-bg); }
        body.dark-mode-3 .toggle-button.active { background-color: var(--dm3-accent-hover); color: var(--dm3-text); border-color: var(--dm3-accent); }
        body.dark-mode-3 select, body.dark-mode-3 input[type="text"], body.dark-mode-3 input[type="number"] { background-color: var(--dm3-input-bg); color: var(--dm3-input-text); border-color: var(--dm3-input-border); }
        body.dark-mode-3 .measure { background-color: var(--dm3-bg-alt); color: var(--dm3-text); border-color: var(--dm3-border); }
        body.dark-mode-3 .measure.active { background-color: var(--dm3-accent); border-color: var(--dm3-accent-hover); color: var(--dm3-bg); }
        body.dark-mode-3 .measure.active .measure-number, body.dark-mode-3 .measure.active .chord-controls label, body.dark-mode-3 .measure.active .scale-controls label { color: var(--dm3-bg); }
        body.dark-mode-3 .beat { background-color: var(--dm3-accent); color: var(--dm3-bg); }
        body.dark-mode-3 .beat.active { background-color: var(--dm3-accent-hover); transform: translateY(-5px) scale(1.05); }

        /* Range input styling for dark modes */
        body.dark-mode input[type="range"]::-webkit-slider-runnable-track,
        body.dark-mode-2 input[type="range"]::-webkit-slider-runnable-track,
        body.dark-mode-3 input[type="range"]::-webkit-slider-runnable-track { background: var(--dm1-input-bg, var(--dm2-input-bg, var(--dm3-input-bg))); }
        body.dark-mode input[type="range"]::-webkit-slider-thumb,
        body.dark-mode-2 input[type="range"]::-webkit-slider-thumb,
        body.dark-mode-3 input[type="range"]::-webkit-slider-thumb { background: var(--dm1-accent, var(--dm2-accent, var(--dm3-accent))); border: 1px solid var(--dm1-accent-hover, var(--dm2-accent-hover, var(--dm3-accent-hover)));}
        body.dark-mode input[type="range"]::-moz-range-track,
        body.dark-mode-2 input[type="range"]::-moz-range-track,
        body.dark-mode-3 input[type="range"]::-moz-range-track { background: var(--dm1-input-bg, var(--dm2-input-bg, var(--dm3-input-bg))); }
        body.dark-mode input[type="range"]::-moz-range-thumb,
        body.dark-mode-2 input[type="range"]::-moz-range-thumb,
        body.dark-mode-3 input[type="range"]::-moz-range-thumb { background: var(--dm1-accent, var(--dm2-accent, var(--dm3-accent))); border: 1px solid var(--dm1-accent-hover, var(--dm2-accent-hover, var(--dm3-accent-hover)));}

        /* Loading Indicator Styles */
        #audio-loading-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10001; /* Ensure it's on top */
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            text-align: center;
            display: none; /* Hidden by default, shown by JS */
        }
        #audio-loading-indicator p { margin: 0 0 5px 0; font-size: 0.9em; }
        #audio-loading-indicator .progress-bar-container {
            width: 200px; /* Fixed width for the bar itself */
            height: 10px;
            background-color: #555;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px auto 0; /* Center the bar */
        }
        #audio-loading-indicator .progress-bar-fill {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease-out;
        }
        #audio-loading-indicator .progress-text {
            font-size: 0.8em;
            display: block; /* On its own line */
            margin-top: 3px;
        }
        .drum-pads {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .drum-pads button {
            min-width: 80px;
        }

    </style>
</head>
<body>
    <div class="app-section" id="global-controls-section">
        <h1>BEBOP BLUEPRINT</h1>
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Theme</button>
        <button id="startAppButton">Initialize Audio</button> <!-- For user gesture -->
         <!-- Unified Loading Indicator Structure -->
        <div id="audio-loading-indicator">
            <p id="audio-loading-status-message">Loading audio...</p>
            <div class="progress-bar-container">
                <div id="audio-loading-progress-bar-fill" class="progress-bar-fill"></div>
            </div>
            <span id="audio-loading-progress-text" class="progress-text">0%</span>
        </div>
    </div>

    <div class="app-section" id="chord-fretboard-section">
        <h3>Fretflow - Dynamic Fretboard</h3>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.05" value="0.3">
        </div>
        <div class="fretboard-container">
            <div class="scale-display" id="scale-display">C Major</div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <div class="controls">
            <div class="control-group">
                <label for="time-signature">Time Sig:</label>
                <select id="time-signature" aria-label="Select time signature">
                    <option value="2/4">2/4</option>
                    <option value="3/4">3/4</option>
                    <option value="4/4" selected>4/4</option>
                    <option value="6/8">6/8</option>
                    <option value="7/8">7/8</option>
                    <option value="8/8">8/8 (4/4 with 8th notes)</option>
                    <option value="12/8">12/8</option>
                </select>
            </div>
            <div class="control-group">
                <label for="sound-type">Sound:</label>
                <select id="sound-type" aria-label="Select metronome sound">
                    <option value="click">Click</option>
                    <option value="woodblock">Woodblock</option>
                    <option value="drums">Drums</option>
                </select>
            </div>
            <button id="drumSetToggleBtn" class="control-button" style="display:none;">Default Kit</button>
            <div class="volume-control">
                <span>Metro Vol:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.05" value="0.25" aria-label="Metronome volume">
            </div>
             <div class="control-group">
                <label for="tempo">Tempo:</label>
                <input type="range" id="tempo-slider" min="40" max="240" value="120" aria-label="Tempo">
                <span id="tempo-display">120 BPM</span>
            </div>
            <button id="tap-tempo" aria-label="Tap tempo">Tap</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>
        <div class="beats-container"></div>
        <div class="volume-control">
            <label for="accent-intensity">Accent Intensity:</label>
            <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
        </div>
        <div class="drum-pads" id="drum-pad-container">
            <h4>Drum Pad Previews:</h4>
            <button id="kickButton" class="drum-pad">Kick</button>
            <button id="snareButton" class="drum-pad">Snare</button>
            <button id="hihatClosedButton" class="drum-pad">HiHat (C)</button>
            <!-- Add more if your drum kits have them, e.g., open hat, crash -->
            <!-- <button id="hihatOpenButton" class="drum-pad">HiHat (O)</button> -->
            <!-- <button id="crashButton" class="drum-pad">Crash</button> -->
        </div>
    </div>
    
    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <div class="controls-container">
            <div class="control-group">
                <label for="progression-select">Progression:</label>
                <select id="progression-select" aria-label="Select chord progression">
                    <!-- Options populated by JS -->
                </select>
            </div>
            <div class="control-group">
                <label for="keySelect">Key:</label>
                <select id="keySelect" aria-label="Select key">
                    <!-- Options populated by JS -->
                </select>
            </div>
        </div>
        <div id="measures">
            <!-- Measures will be populated dynamically -->
        </div>
        <button id="addMeasureBtn" aria-label="Add measure">Add Measure</button>
        <button id="removeMeasureBtn" aria-label="Remove measure">Remove Measure</button>
        <div class="checkbox-wrapper">
            <button id="chordsEnabled" class="toggle-button active">Chords ON</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.05" value="0.5" aria-label="Chord volume">
        </div>
        <div class="control-group">
            <label for="reverb-dial">Reverb:</label>
            <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
            <span id="reverb-dial-value">20</span>%
        </div>
    </div>

    <div class="app-section" id="fretflow-section">
        <h2>FretFlow - Multi-Scale Workout</h2>
        <div class="fretboards-grid"></div>
    </div>

    <script>
    // --- Configuration Constants ---
    const LOG_PREFIX = "[Bebop Blueprint]";
    const PIANO_SAMPLE_BASE_PATH = './'; // Samples in root
    const DRUM_SAMPLE_BASE_PATH = './';   // Samples in root
    const METRONOME_SOUND_BASE_PATH = './'; // Samples in root
    const REVERB_IMPULSE_PATH = './ir-sweep.wav'; // Ensure ir-sweep.wav is in root
    const PIANO_FILE_FORMAT = 'wav';

    // --- Utility Functions ---
    function log(message) { console.log(`${LOG_PREFIX} ${message}`); }

    function updateLoadingStatus(message, percentage = null, isError = false) {
        const indicator = document.getElementById('audio-loading-indicator');
        const statusMessageEl = document.getElementById('audio-loading-status-message');
        const progressBarFillEl = document.getElementById('audio-loading-progress-bar-fill');
        const progressTextEl = document.getElementById('audio-loading-progress-text');

        if (!indicator || !statusMessageEl || !progressBarFillEl || !progressTextEl) {
            console.warn(`${LOG_PREFIX} Loading status UI elements not found.`);
            return;
        }

        indicator.style.display = 'block';
        statusMessageEl.textContent = message;
        statusMessageEl.style.color = isError ? 'red' : 'white';

        if (percentage !== null) {
            progressBarFillEl.style.width = `${percentage}%`;
            progressTextEl.textContent = `${percentage}%`;
            progressBarFillEl.parentElement.style.display = 'block'; // Show progress bar container
            progressTextEl.style.display = 'block';
        } else {
            progressBarFillEl.parentElement.style.display = 'none'; // Hide progress bar container
            progressTextEl.style.display = 'none';
        }
    }

    function hideLoadingStatus(delay = 1500) {
        const indicator = document.getElementById('audio-loading-indicator');
        if (indicator) {
            setTimeout(() => {
                indicator.style.opacity = '0';
                setTimeout(() => { 
                    indicator.style.display = 'none'; 
                    indicator.style.opacity = '1'; // Reset for next time
                }, 500); // Wait for fade out
            }, delay);
        }
    }


    function debounce(func, wait) {
        let timeout;
        return function (...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    // --- Music Constants ---
    const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    // For filenames: c, cs, d, ds, e, f, fs, g, gs, a, as, b
    const PIANO_SAMPLE_NOTES_FILENAME_FORMAT = NOTES.map(n => {
        let fn = n.toLowerCase();
        if (fn.includes('b')) { // Convert flats to sharps for consistency if your files use sharps
            const equivalentSharpIndex = (NOTES.indexOf(n) - 1 + 12) % 12;
            fn = NOTES[equivalentSharpIndex].toLowerCase(); // Get sharp name
            if (fn.length > 1) fn = fn.charAt(0) + 's'; // Ensure it's like 'cs', 'ds'
            else fn = fn + 's'; // Should not happen if NOTES is correct
        }
        if (fn.includes('#')) fn = fn.replace('#', 's');
        return fn;
    });
    const PIANO_OCTAVES = [2, 3, 4, 5];

    const ENHARMONIC_MAP = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
    const DISPLAY_TO_SAMPLE_NOTE_MAP = { // Maps display notes to filename format (e.g., C#, Db -> cs)
        'C': 'c', 'C#': 'cs', 'Db': 'cs',
        'D': 'd', 'D#': 'ds', 'Eb': 'ds',
        'E': 'e',
        'F': 'f', 'F#': 'fs', 'Gb': 'fs',
        'G': 'g', 'G#': 'gs', 'Ab': 'gs',
        'A': 'a', 'A#': 'as', 'Bb': 'as',
        'B': 'b'
    };

    function standardizeNoteName(note) {
        if (!note || typeof note !== 'string') return '';
        let standardized = note.toUpperCase().trim();
        standardized = standardized.replace('♭', 'b').replace('♯', '#');
        return ENHARMONIC_MAP[standardized] || standardized;
    }

    const SCALES = {
        major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10], harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
        melodicMinor: [0, 2, 3, 5, 7, 9, 11], dorian: [0, 2, 3, 5, 7, 9, 10], phrygian: [0, 1, 3, 5, 7, 8, 10],
        lydian: [0, 2, 4, 6, 7, 9, 11], mixolydian: [0, 2, 4, 5, 7, 9, 10], locrian: [0, 1, 3, 5, 6, 8, 10],
        bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11], bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11], bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10],
        altered: [0, 1, 3, 4, 6, 8, 10], lydianDominant: [0, 2, 4, 6, 7, 9, 10],
        diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11], diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10], wholeTone: [0, 2, 4, 6, 8, 10],
        pentatonicMajor: [0, 2, 4, 7, 9], pentatonicMinor: [0, 3, 5, 7, 10], blues: [0, 3, 5, 6, 7, 10]
    };
    const SCALES_DISPLAY_NAMES = {
        major: "Major (Ionian)", minor: "Minor (Aeolian)", harmonicMinor: "Harmonic Minor", melodicMinor: "Melodic Minor (Jazz)",
        dorian: "Dorian", phrygian: "Phrygian", lydian: "Lydian", mixolydian: "Mixolydian (Dominant)", locrian: "Locrian",
        bebopDominant: "Bebop Dominant", bebopMajor: "Bebop Major", bebopDorian: "Bebop Dorian",
        altered: "Altered (Super Locrian)", lydianDominant: "Lydian Dominant",
        diminishedWH: "Diminished (W-H)", diminishedHW: "Diminished (H-W)", wholeTone: "Whole Tone",
        pentatonicMajor: "Pentatonic Major", pentatonicMinor: "Pentatonic Minor", blues: "Blues"
    };

    const TUNINGS = {
        standard: ['E4', 'B3', 'G3', 'D3', 'A2', 'E2'], // With octaves for precision
        dropD:    ['E4', 'B3', 'G3', 'D3', 'A2', 'D2'],
        openG:    ['D4', 'B3', 'G3', 'D3', 'G2', 'D2'],
        DADGAD:   ['D4', 'A3', 'G3', 'D3', 'A2', 'D2'],
        openE:    ['E4', 'B3', 'Ab3', 'E3', 'B2', 'E2'] // G#3 is Ab3
    };
    // Helper to get just note names from TUNINGS for fretboard display logic
    function getTuningNoteNames(tuningKey) {
        return TUNINGS[tuningKey].map(noteWithOctave => noteWithOctave.slice(0, -1));
    }


    let currentDrumSetIndex = 0;
    const drumSoundSets = [
        { name: "Default Kit", kick: "Kick.wav", snare: "Snare.wav", hihat: "HiHat.wav" }, // Ensure these files exist
        { name: "Makaya Kit", kick: "Kick2.wav", snare: "Snare2.wav", hihat: "HiHat2.wav" }, // Ensure these files exist
        { name: "PhillyJoe Kit", kick: 'jazzkick.wav', snare: 'jazzsnare.wav', hihat: 'jazzhat.wav' } // Ensure these files exist
    ];
    const METRONOME_SOUND_PATHS = {
        click: 'Click.wav', // Ensure Click.wav exists
        woodblock: 'woodblock.wav' // Ensure woodblock.wav exists
    };

  const progressions = {
    "i-v7": {
    displayName: "I-V7 Progression",
    defaultKey: "C",
    progression: ["Imaj7", "V7"],
    description: "A simple I-V7 progression, common in jazz standards."
    },
    "jazz-blues": {
    displayName: "Jazz Blues",
    defaultKey: "Bb",
    progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "IIm7", "V7", "I7", "V7"],
    description: "A standard 12-bar jazz blues progression."
    },
    "minor-blues": {
    displayName: "Minor Blues",
    defaultKey: "Am",
    progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"],
    description: "A 12-bar minor blues progression."
    },
    "rhythm-changes": {
    displayName: "Rhythm Changes",
    defaultKey: "Bb",
    progression: ["I6", "vim7", "iim7", "V7", "I6", "vim7", "iim7", "V7", "I6", "IV7", "I6", "I6", "iim7", "V7", "I6", "V7"],
    description: "Based on Gershwin's 'I Got Rhythm', a common jazz form."
    },
    "ii-v-i": {
    displayName: "ii-V-I Progression",
    defaultKey: "C",
    progression: ["iim7", "V7", "Imaj7", "Imaj7"],
    description: "A fundamental jazz progression."
    },
    "vi-ii-v-i": {
    displayName: "vi-ii-V-I Progression",
    defaultKey: "C",
    progression: ["vim7", "iim7", "V7", "Imaj7", "Imaj7"],
    description: "An extended ii-V-I with a vi minor start."
    },
    "minor-ii-v-i": {
    displayName: "Minor ii-V-I",
    defaultKey: "Am",
    progression: ["iim7b5", "V7b9", "im7", "im7"],
    description: "A minor key ii-V-I progression."
    },
    "dark-eyes": {
    displayName: "Dark Eyes",
    defaultKey: "Dm",
    progression: ["V7", "V7", "im7", "im7", "V7", "V7", "VI6", "VI6", "ivm6", "ivm6", "im7", "im7", "V7", "V7", "im7", "im7"],
    description: "A gypsy jazz progression from the folk song."
    },
    "ill-see-you-in-my-dreams": {
    displayName: "I'll See You in My Dreams",
    defaultKey: "F",
    progression: ["IV6", "IV6", "ivm6", "ivm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "iim7", "V7", "Imaj7"],
    description: "Progression from the jazz standard."
    },
    "rose-room": {
    displayName: "Rose Room",
    defaultKey: "Ab",
    progression: ["II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"],
    description: "Progression from the classic jazz tune."
    },
    "black-orpheus": {
    displayName: "Black Orpheus",
    defaultKey: "Am",
    progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"],
    description: "Bossa nova progression from the film."
    },
    "all-the-things-you-are": {
    displayName: "All the Things You Are",
    defaultKey: "Ab",
    progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"],
    description: "Complex progression from the jazz standard."
    },
    "all-of-me": {
    displayName: "All of Me",
    defaultKey: "C",
    progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IVmaj7", "ivm7", "Imaj7", "V7"],
    description: "Progression from the popular standard."
    },
    "stella-by-starlight": {
    displayName: "Stella by Starlight",
    defaultKey: "Bb",
    progression: ["iim7b5", "V7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "biiim7b5", "VI7b9", "iim7", "V7", "im7", "IV7", "IVmaj7", "V7"],
    description: "Complex progression from the jazz standard."
    },
    "autumn-leaves": {
    displayName: "Autumn Leaves",
    defaultKey: "Em",
    progression: ["ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "im7"],
    description: "Classic jazz standard progression."
    },
    "summertime": {
    displayName: "Summertime",
    defaultKey: "Am",
    progression: ["im7", "V7", "im7", "V7", "im7", "V7", "im7", "V7", "iv7", "im7", "V7", "im7", "iv7", "im7", "V7", "im7"],
    description: "Progression from Gershwin's opera."
    },
    "girl-from-ipanema": {
    displayName: "The Girl from Ipanema",
    defaultKey: "F",
    progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "#IVmaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7"],
    description: "Bossa nova classic."
    },
    "coltrane-changes": {
    displayName: "Coltrane Changes",
    defaultKey: "C",
    progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"],
    description: "John Coltrane's harmonic cycle."
    },
    "bird-blues": {
    displayName: "Bird Blues",
    defaultKey: "F",
    progression: ["I7", "IV7", "I7", "vim7", "iim7", "V7", "IV7", "ivm7", "I7", "vim7", "iim7", "V7"],
    description: "Charlie Parker's blues variation."
    },
    "just-friends": {
    displayName: "Just Friends",
    defaultKey: "G",
    progression: ["Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7"],
    description: "Upbeat jazz standard."
    },
    "blue-bossa": {
    displayName: "Blue Bossa",
    defaultKey: "Cm",
    progression: ["im7", "im7", "bVII7", "bVII7", "im7", "im7", "ivm7", "bVII7", "im7", "V7", "im7", "im7"],
    description: "Bossa nova with a minor feel."
    },
    "on-green-dolphin-street": {
    displayName: "On Green Dolphin Street",
    defaultKey: "C",
    progression: ["Imaj7", "bIII7", "bVImaj7", "iim7", "V7", "Imaj7", "bIII7", "bVImaj7", "iim7", "V7", "Imaj7"],
    description: "Jazz standard with modal shifts."
    },
    "solar": {
    displayName: "Solar",
    defaultKey: "C",
    progression: ["im7", "im7", "bIIImaj7", "bIIImaj7", "bVImaj7", "bVImaj7", "bII7", "bII7", "im7", "im7"],
    description: "Miles Davis' moody standard."
    },
    "misty": {
    displayName: "Misty",
    defaultKey: "Eb",
    progression: ["Imaj7", "I7", "IVmaj7", "ivm7", "Imaj7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7"],
    description: "Erroll Garner's romantic ballad."
    },
    "days-of-wine-and-roses": {
    displayName: "Days of Wine and Roses",
    defaultKey: "F",
    progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7"],
    description: "Henry Mancini's jazz standard."
    },
    "cherokee": {
    displayName: "Cherokee",
    defaultKey: "Bb",
    progression: ["Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7", "bVI7", "bVI7", "V7", "V7", "Imaj7", "Imaj7", "iim7", "V7"],
    description: "Fast-paced Ray Noble standard."
    },
    "caravan": {
    displayName: "Caravan",
    defaultKey: "Eb",
    progression: ["im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "bVII7", "bVII7", "Imaj7", "Imaj7", "V7", "V7", "im7", "im7"],
    description: "Exotic Duke Ellington tune."
    },
    "nows-the-time": {
    displayName: "Now's the Time",
    defaultKey: "F",
    progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "V7", "IV7", "I7", "I7"],
    description: "Charlie Parker's blues."
    },
    "tenor-madness": {
    displayName: "Tenor Madness",
    defaultKey: "Bb",
    progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "iim7", "V7", "I7", "I7"],
    description: "Sonny Rollins' bluesy standard."
    }
};


    // --- State Management ---
    const AppState = {
        isPlaying: false, currentBeatInMeasureCycle: 0, currentMeasureIndex: 0, tempo: 120,
        audioInitialized: false, currentDarkMode: 0, // 0: light, 1: dm1, 2: dm2, 3: dm3
        chordsEnabled: true, intervalId: null, lastTapTime: 0, tapTempoIntervals: [],
        activeFretboardNotes: {}, // To store { noteKey: sourceNode } for fretboard clicks
        listeners: [],
        updateState(newState) { Object.assign(this, newState); this.notifyListeners(); },
        addListener(callback) { this.listeners.push(callback); },
        notifyListeners() { this.listeners.forEach(callback => callback(this)); }
    };

    const UI = { // Simplified, direct element access
        elements: {},
        init() {
            const ids = [
                'chord-fretboard', 'measures', 'tempo-display', 'start-stop', 'progression-select',
                'keySelect', 'scale-display', 'chord-tuning', 'time-signature', 'sound-type',
                'metronome-volume', 'tempo-slider', 'tap-tempo', 'chord-fretboard-volume',
                'chord-volume', 'chordsEnabled', 'fretboardsGrid', 'dark-mode-toggle',
                'accent-intensity', 'drumSetToggleBtn', 'reverb-dial', 'reverb-dial-value',
                'addMeasureBtn', 'removeMeasureBtn', 'startAppButton',
                'kickButton', 'snareButton', 'hihatClosedButton', // Drum Pad Buttons
                // Loading indicator elements
                'audio-loading-indicator', 'audio-loading-status-message', 
                'audio-loading-progress-bar-fill', 'audio-loading-progress-text'
            ];
            ids.forEach(id => this.elements[id] = document.getElementById(id));
            this.elements.fretboardsGrid = document.querySelector('.fretboards-grid'); // Class selector

            this.populateProgressionSelect();
            this.populateKeySelect();
            log("UI elements cached.");
        },
        populateProgressionSelect() {
            if (!this.elements.progressionSelect) return;
            this.elements.progressionSelect.innerHTML = ''; // Clear existing
            Object.entries(progressions).forEach(([id, { displayName }]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = displayName;
                this.elements.progressionSelect.appendChild(option);
            });
        },
        populateKeySelect() {
            if (!this.elements.keySelect) return;
            this.elements.keySelect.innerHTML = createKeyOptions('C'); // Default to C
        }
    };
        
    // --- AudioContextManager ---
    const AudioContextManager = {
        context: null, soundBuffers: {}, reverbNode: null, reverbBuffer: null, reverbGainNode: null,
        samplesFullyLoaded: false, currentChordSources: [],

        async initialize() {
            if (this.context) return this.context;
            try {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                if (this.context.state === 'suspended') await this.context.resume();
                await this.setupReverb();
                AppState.updateState({ audioInitialized: true });
                log("AudioContext initialized.");
            } catch (error) {
                console.error(`${LOG_PREFIX} AudioContext initialization failed:`, error);
                updateLoadingStatus("AudioContext Error. Try a different browser or check permissions.", null, true);
                AppState.updateState({ audioInitialized: false });
                throw error;
            }
            return this.context;
        },
        async ensureAudioContext() {
            if (!this.context || this.context.state === 'suspended') {
                await this.initialize();
                if (this.context && this.context.state === 'suspended') await this.context.resume();
            }
            return this.context;
        },
        async loadAllSoundSamples() {
            if (this.samplesFullyLoaded || !this.context) return;
            log("Starting to load all sound samples...");
            updateLoadingStatus("Loading audio samples...", 0);

            const samplesToLoad = [];
            // 1. Piano Samples (using DISPLAY_TO_SAMPLE_NOTE_MAP for consistency)
            // We need unique note names for sample files, e.g., c, cs, d, ds...
            const uniqueSampleFileNotes = [...new Set(Object.values(DISPLAY_TO_SAMPLE_NOTE_MAP))];

            uniqueSampleFileNotes.forEach(sampleFileNote => {
                PIANO_OCTAVES.forEach(octave => {
                    const fileName = `${sampleFileNote}${octave}.${PIANO_FILE_FORMAT}`;
                    samplesToLoad.push({
                        key: `piano_${sampleFileNote}${octave}`, // e.g., piano_c3, piano_cs3
                        path: `${PIANO_SAMPLE_BASE_PATH}${fileName}`
                    });
                });
            });

            // 2. Drum Kit Samples
            drumSoundSets.forEach((kit) => {
                const kitNameKey = kit.name.replace(/\s+/g, '_').toLowerCase();
                ['kick', 'snare', 'hihat'].forEach(drumType => {
                    if (kit[drumType]) {
                        samplesToLoad.push({
                            key: `drum_${kitNameKey}_${drumType}`,
                            path: `${DRUM_SAMPLE_BASE_PATH}${kit[drumType]}`
                        });
                    }
                });
            });
            
            // 3. Metronome Sounds
            Object.entries(METRONOME_SOUND_PATHS).forEach(([name, filePath]) => {
                samplesToLoad.push({ key: `metronome_${name}`, path: `${METRONOME_SOUND_BASE_PATH}${filePath}`});
            });

            let loadedCount = 0;
            const totalSamples = samplesToLoad.length;

            for (const sample of samplesToLoad) {
                try {
                    const response = await fetch(sample.path);
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} for ${sample.path}`);
                    const arrayBuffer = await response.arrayBuffer();
                    this.soundBuffers[sample.key] = await this.context.decodeAudioData(arrayBuffer);
                    loadedCount++;
                    const percentage = Math.round((loadedCount / totalSamples) * 100);
                    updateLoadingStatus(`Loading: ${sample.key.split('_').pop()}`, percentage);
                } catch (error) {
                    console.error(`${LOG_PREFIX} Failed to load sample ${sample.key} from ${sample.path}:`, error);
                    updateLoadingStatus(`Error loading ${sample.key}. Check console.`, null, true);
                }
            }
            this.samplesFullyLoaded = true;
            log(`All sound samples processed. ${loadedCount}/${totalSamples} loaded successfully.`);
            if (loadedCount === totalSamples) {
                updateLoadingStatus("Audio samples loaded!", 100);
                hideLoadingStatus();
            } else {
                updateLoadingStatus(`Finished. ${loadedCount}/${totalSamples} loaded. Some errors occurred.`, 100, true);
                // Don't auto-hide if there were errors, let user see.
            }
        },
        async setupReverb() {
            try {
                const response = await fetch(REVERB_IMPULSE_PATH);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} for ${REVERB_IMPULSE_PATH}`);
                const arrayBuffer = await response.arrayBuffer();
                this.reverbBuffer = await this.context.decodeAudioData(arrayBuffer);
                this.reverbNode = this.context.createConvolver();
                this.reverbNode.buffer = this.reverbBuffer;
                this.reverbGainNode = this.context.createGain();
                this.reverbGainNode.gain.value = parseFloat(UI.elements.reverbDial?.value || 20) / 100;
                this.reverbNode.connect(this.reverbGainNode);
                this.reverbGainNode.connect(this.context.destination);
                log("Reverb set up.");
            } catch (error) {
                console.error(`${LOG_PREFIX} Failed to set up reverb:`, error);
                this.reverbNode = null; this.reverbGainNode = null;
            }
        },
        _playBuffer(bufferKey, volume, destination, pan = 0, pitchBend = 0, isChordNote = false) {
            if (!this.context || !this.soundBuffers[bufferKey]) {
                console.warn(`${LOG_PREFIX} Buffer not found or context not ready for key: ${bufferKey}`);
                return null;
            }
            const source = this.context.createBufferSource();
            source.buffer = this.soundBuffers[bufferKey];
            if (pitchBend !== 0) source.detune.value = pitchBend * 100;

            const gainNode = this.context.createGain();
            gainNode.gain.value = Math.max(0, Math.min(1, volume));

            const pannerNode = this.context.createStereoPanner();
            pannerNode.pan.value = Math.max(-1, Math.min(1, pan));

            source.connect(gainNode);
            gainNode.connect(pannerNode);
            pannerNode.connect(destination || this.context.destination);

            // Reverb send for piano and drums (if not already handled by destination)
            if (this.reverbNode && this.reverbGainNode && this.reverbGainNode.gain.value > 0 && (bufferKey.startsWith('piano_') || bufferKey.startsWith('drum_'))) {
                const reverbSendGain = this.context.createGain();
                // Adjust send level: more for piano, less for drums, or make it configurable
                reverbSendGain.gain.value = bufferKey.startsWith('piano_') ? 0.5 : 0.3; 
                pannerNode.connect(reverbSendGain); // Send after panning
                reverbSendGain.connect(this.reverbNode);
            }
            
            source.start(this.context.currentTime);
            return { source, gainNode }; // Return both for potential stopping/fading
        },
        playPianoNote(noteNameWithOctave, volume, durationMs = 1000, isChordNote = false) {
            // noteNameWithOctave should be like "c3", "cs4" (matching sample file format)
            const bufferKey = `piano_${noteNameWithOctave.toLowerCase()}`;
            const played = this._playBuffer(bufferKey, volume, this.context.destination, 0, 0, isChordNote);
            if (played && durationMs > 0 && !isChordNote) { // Chord notes stopped by stopCurrentChord
                played.source.stop(this.context.currentTime + durationMs / 1000);
            }
            return played;
        },
        stopCurrentChord() {
            this.currentChordSources.forEach(({ source, gainNode }) => {
                try {
                    if (gainNode) {
                        gainNode.gain.cancelScheduledValues(this.context.currentTime);
                        gainNode.gain.setValueAtTime(gainNode.gain.value, this.context.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, this.context.currentTime + 0.05); // Faster fade
                        source.stop(this.context.currentTime + 0.06);
                    } else {
                        source.stop(this.context.currentTime + 0.05);
                    }
                } catch (e) { /* ignore */ }
            });
            this.currentChordSources = [];
        },
        stopAllSounds() { // General stop for everything managed by this context
            this.stopCurrentChord();
            // Stop any active fretboard notes (if you implement sustained fretboard notes)
            Object.values(AppState.activeFretboardNotes).forEach(node => {
                try { node.source.stop(); } catch(e){}
            });
            AppState.activeFretboardNotes = {};
            // Could also iterate over all soundBuffers and try to disconnect/stop any active sources,
            // but that's more complex if sources aren't tracked.
            log("All managed sounds stopped.");
        }
    };

    async function playMetronomeSound(baseBeatVolume) { /* ... (Keep your existing robust playMetronomeSound logic) ... */
        await AudioContextManager.ensureAudioContext();
        if (!AudioContextManager.samplesFullyLoaded) return;

        const metronomeVolumeSetting = parseFloat(UI.elements.metronomeVolume?.value || 0.7);
        const combinedVolume = baseBeatVolume * metronomeVolumeSetting;
        if (combinedVolume <= 0) return;

        const soundType = UI.elements.soundType?.value || 'click';
        const beatElement = document.querySelector(`.beat[data-beat-index="${AppState.currentBeatInMeasureCycle}"]`);
        if (!beatElement) return;

        const drumSoundKeys = beatElement.dataset.sound?.split(',').map(s => s.trim()).filter(s => s) || ['click'];
        const accentBoost = parseFloat(UI.elements.accentIntensity?.value || 1.0);
        const isStrongBeat = parseFloat(beatElement.dataset.baseVolume) >= 1.0;

        for (let soundKey of drumSoundKeys) {
            if (soundKey === 'silent') continue;
            let bufferKeyToPlay, soundSpecificVolumeAdjustment = 1.0;

            if (soundType === 'drums') {
                const currentSet = drumSoundSets[currentDrumSetIndex];
                const kitNameKey = currentSet.name.replace(/\s+/g, '_').toLowerCase();
                bufferKeyToPlay = `drum_${kitNameKey}_${soundKey}`;
                if (!AudioContextManager.soundBuffers[bufferKeyToPlay]) { // Fallback
                    bufferKeyToPlay = `drum_default_kit_${soundKey}`;
                    if (!AudioContextManager.soundBuffers[bufferKeyToPlay]) continue;
                }
                if (soundKey === 'kick') soundSpecificVolumeAdjustment = 1.1;
                else if (soundKey === 'hihat') soundSpecificVolumeAdjustment = 0.7;
            } else {
                bufferKeyToPlay = `metronome_${soundType}`;
                if (!AudioContextManager.soundBuffers[bufferKeyToPlay]) continue;
            }

            let finalVolume = combinedVolume * soundSpecificVolumeAdjustment;
            if (isStrongBeat) finalVolume = Math.min(finalVolume * accentBoost, 1.0);
            finalVolume = Math.max(0, Math.min(finalVolume, 1.0));

            AudioContextManager._playBuffer(bufferKeyToPlay, finalVolume, AudioContextManager.context.destination);
        }
    }


    // --- Chord and Scale Utilities ---
    function getNoteFromScaleDegree(scaleDegree, key, scaleIntervals = SCALES.major) { /* ... (Keep your existing logic) ... */
        const rootIndex = NOTES.indexOf(standardizeNoteName(key));
        if (rootIndex === -1) return null;
        const offset = scaleIntervals[scaleDegree % scaleIntervals.length];
        return NOTES[(rootIndex + offset + 12) % 12];
    }

    function getChordNotes(root, quality) { /* ... (Keep your existing logic, ensure CHORD_INTERVALS is defined) ... */
        const CHORD_INTERVALS = {
            'maj': [0, 4, 7], 'min': [0, 3, 7], 'dim': [0, 3, 6], 'aug': [0, 4, 8],
            'sus4': [0, 5, 7], 'sus2': [0, 2, 7],
            'maj7': [0, 4, 7, 11], 'dom7': [0, 4, 7, 10], 'min7': [0, 3, 7, 10],
            'dim7': [0, 3, 6, 9], 'min7b5': [0, 3, 6, 10], 'aug7': [0, 4, 8, 10],
            '6': [0, 4, 7, 9], 'm6': [0, 3, 7, 9],
            'maj9': [0, 4, 7, 11, 14], 'dom9': [0, 4, 7, 10, 14], 'min9': [0, 3, 7, 10, 14],
            'V7alt': [0, 4, 10] // Root, 3rd, b7 - alterations added by context
        };
        const intervals = CHORD_INTERVALS[quality] || CHORD_INTERVALS['maj'];
        const rootStd = standardizeNoteName(root);
        const rootIndex = NOTES.indexOf(rootStd);
        if (rootIndex === -1) return [rootStd];
        return intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
    }
    
    function getChordFromFunction(romanNumeralInput, key = "C") { /* ... (Keep your existing robust getChordFromFunction) ... */
        const romanMap = { "I":0, "II":2, "III":4, "IV":5, "V":7, "VI":9, "VII":11 };
        const qualityMap = { // Suffix to internal quality name
            "maj7": "maj7", "Δ": "maj7", "M7": "maj7",
            "m7": "min7", "-7": "min7",
            "7": "dom7", // Default 7 is dominant
            "m7b5": "min7b5", "ø": "min7b5", "min7(b5)": "min7b5",
            "dim7": "dim7", "°7": "dim7", "dim": "dim", "°": "dim", // Triad
            "6": "6", "m6": "m6",
            "maj": "maj", // Triad
            "m": "min", "min": "min", // Triad
            "aug": "aug", "+": "aug", // Triad
            "alt": "V7alt", "7alt": "V7alt",
            "sus": "sus4", "sus4": "sus4"
        };

        if (typeof romanNumeralInput !== 'string') return { root: key, quality: 'maj7' };
        const match = romanNumeralInput.match(/([b#♭♯]*)?([IViv]+)(.*)/i);
        if (!match) return { root: key, quality: 'maj7' };

        let [, accidental, numeralStr, suffix] = match;
        let quality = null; // Default quality
        let isExplicitlyMinorNumeral = numeralStr === numeralStr.toLowerCase();

        suffix = suffix.trim();
        for (const [qSuffix, qInternal] of Object.entries(qualityMap)) {
            if (suffix.startsWith(qSuffix)) { // Use startsWith for more precise matching
                quality = qInternal;
                break;
            }
        }
        
        // Infer quality from Roman numeral case if no suffix quality was found
        if (!quality) {
            if (isExplicitlyMinorNumeral) quality = 'min'; // Default to minor triad for lowercase
            else quality = 'maj'; // Default to major triad for uppercase
        }
        // If it's a V chord and no quality specified, often implies V7
        if (numeralStr.toUpperCase() === 'V' && (suffix === "" || suffix.toLowerCase() === "7")) {
             quality = 'dom7';
        }


        let semitoneOffset = romanMap[numeralStr.toUpperCase()];
        if (semitoneOffset === undefined) return { root: key, quality: 'maj7' };

        if (accidental) {
            if (accidental.includes('b') || accidental.includes('♭')) semitoneOffset--;
            if (accidental.includes('#') || accidental.includes('♯')) semitoneOffset++;
        }

        const keyStd = standardizeNoteName(key);
        const keyIndex = NOTES.indexOf(keyStd);
        if (keyIndex === -1) return { root: key, quality: 'maj7' };

        const rootNote = NOTES[(keyIndex + semitoneOffset + 12) % 12];
        return { root: rootNote, quality: quality };
    }

    function getQualityValue(quality) { return quality; } // Assuming internal names match select values

    function suggestScaleForQuality(quality) { /* ... (Keep your existing logic) ... */
        const scaleMap = {
            'maj': 'major', 'maj7': 'lydian', 
            'min': 'dorian', 'min7': 'dorian', 
            'dom7': 'mixolydian', 'V7alt': 'altered',
            'min7b5': 'locrian', 'dim7': 'diminishedWH',
            '6': 'major', 'm6': 'melodicMinor'
        };
        return scaleMap[quality] || 'major'; // Default to major
    }

    // --- DOM Utilities ---
    function createKeyOptions(selectedKey = 'C') {
        return NOTES.map(note => `<option value="${note}"${note === selectedKey ? ' selected' : ''}>${note}</option>`).join('');
    }
    function createQualityOptions(selectedQuality = 'maj7') {
        const qualities = [
            { value: 'maj', label: 'Major Triad' }, { value: 'min', label: 'Minor Triad' },
            { value: 'aug', label: 'Augmented Triad' }, { value: 'dim', label: 'Diminished Triad' },
            { value: 'maj7', label: 'Major 7th (Imaj7, IVmaj7)' }, { value: 'min7', label: 'Minor 7th (iim7, vim7)' },
            { value: 'dom7', label: 'Dominant 7th (V7, secondary doms)' },
            { value: 'min7b5', label: 'Minor 7th ♭5 (Half-Diminished, iim7b5)' },
            { value: 'dim7', label: 'Diminished 7th (°7)' },
            { value: 'V7alt', label: 'Altered Dominant (V7alt)' },
            { value: '6', label: 'Major 6th' }, { value: 'm6', label: 'Minor 6th' },
            { value: 'sus4', label: 'Sus4' }
        ];
        return qualities.map(q => `<option value="${q.value}" ${q.value === selectedQuality ? 'selected' : ''}>${q.label}</option>`).join('');
    }
    function createScaleOptions(selectedScale = 'major') {
        return Object.entries(SCALES_DISPLAY_NAMES)
            .map(([value, displayName]) => `<option value="${value}"${value === selectedScale ? ' selected' : ''}>${displayName}</option>`)
            .join('');
    }

    // --- Audio Playback Functions ---
    async function playNoteOnFretboard(noteNameWithOctave, volume = 0.7) {
        await AudioContextManager.ensureAudioContext();
        if (!AudioContextManager.samplesFullyLoaded) return;
        const standardizedNoteKey = noteNameWithOctave.toLowerCase(); // e.g. c4, cs3
        const played = AudioContextManager.playPianoNote(standardizedNoteKey, volume, 700, false); // Not a chord note
        if (played) { // Track for potential stopping if needed, or just play-and-forget
            AppState.activeFretboardNotes[standardizedNoteKey] = played;
            played.source.onended = () => { delete AppState.activeFretboardNotes[standardizedNoteKey]; };
        }
    }

    async function playChord(root, quality, durationMs = 2000) {
        await AudioContextManager.ensureAudioContext();
        if (!AudioContextManager.samplesFullyLoaded) return;
        AudioContextManager.stopCurrentChord();

        const chordNotes = getChordNotes(root, quality);
        const chordVolume = parseFloat(UI.elements.chordVolume?.value || 0.5);
        if (chordVolume <= 0 || chordNotes.length === 0) return;

        chordNotes.forEach((note, index) => {
            let baseOctave = 3; // Default octave
            // Simple voicing: try to keep root lower if it's C,D,E
            if (index === 0 && (note === 'C' || note === 'D' || note === 'E')) baseOctave = 2;
            
            let currentOctave = baseOctave;
            // If current note is "before" root in NOTES array (e.g. root G, note C), push to higher octave
            if (index > 0 && NOTES.indexOf(note) < NOTES.indexOf(chordNotes[0])) {
                currentOctave = baseOctave + 1;
            }
            // Ensure octave is within piano sample range
            currentOctave = Math.min(PIANO_OCTAVES[PIANO_OCTAVES.length-1], Math.max(PIANO_OCTAVES[0], currentOctave));

            const sampleNoteFilePart = DISPLAY_TO_SAMPLE_NOTE_MAP[note];
            if (!sampleNoteFilePart) {
                console.warn(`${LOG_PREFIX} No sample file mapping for note: ${note}`);
                return; // Skip this note
            }
            const noteKeyForSample = `${sampleNoteFilePart}${currentOctave}`;
            
            const played = AudioContextManager.playPianoNote(noteKeyForSample, chordVolume * (0.8 + Math.random() * 0.2), durationMs, true);
            if (played) AudioContextManager.currentChordSources.push(played);
        });
    }
    
    async function playDrumSamplePreview(drumType) {
        await AudioContextManager.ensureAudioContext();
        if (!AudioContextManager.samplesFullyLoaded) return;
        const currentSet = drumSoundSets[currentDrumSetIndex];
        const kitNameKey = currentSet.name.replace(/\s+/g, '_').toLowerCase();
        const bufferKey = `drum_${kitNameKey}_${drumType.toLowerCase()}`; // Ensure lowercase key
        const volume = parseFloat(UI.elements.metronomeVolume?.value || 0.7);
        AudioContextManager._playBuffer(bufferKey, volume, AudioContextManager.context.destination);
    }


    // --- Fretboard Rendering ---
    function createFretboard(container, tuningNoteNameArray) { // tuningNoteNameArray: ['E', 'B', 'G', 'D', 'A', 'E']
        container.innerHTML = '';
        const numFrets = 12; // Display up to 12 frets
        const numStrings = tuningNoteNameArray.length;

        for (let i = 0; i <= numFrets; i++) { // Fret lines and numbers
            const fretLine = document.createElement('div');
            fretLine.className = 'fret-line';
            fretLine.style.left = `${(i / numFrets) * 100}%`;
            container.appendChild(fretLine);
            if (i > 0) {
                const fretNumber = document.createElement('div');
                fretNumber.className = 'fret-number';
                fretNumber.textContent = i;
                fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
                container.appendChild(fretNumber);
            }
        }
        for (let i = 0; i < numStrings; i++) { // String lines
            const stringLine = document.createElement('div');
            stringLine.className = 'string-line';
            stringLine.style.top = `${(i / (numStrings - 1)) * 100}%`;
            // Add data attribute for string index if needed for advanced styling
            stringLine.dataset.stringIndex = i;
            container.appendChild(stringLine);
        }
        // Fret markers (dots)
        const markerFrets = [3, 5, 7, 9, 12];
        markerFrets.forEach(fretPos => {
            if (fretPos > numFrets) return;
            const marker = document.createElement('div');
            marker.className = 'fret-marker';
            // Position marker in the middle of the fret space
            marker.style.left = `${((fretPos - 0.5) / numFrets) * 100}%`;
            if (fretPos === 12) { // Double dot at 12th fret
                const m1 = marker.cloneNode(true); m1.style.top = '25%'; container.appendChild(m1);
                const m2 = marker.cloneNode(true); m2.style.top = '75%'; container.appendChild(m2);
            } else {
                marker.style.top = '50%'; container.appendChild(marker);
            }
        });
    }

    function updateFretboardNotes(container, rootNote, scaleName, tuningKey) {
        const tuningNoteNameArray = getTuningNoteNames(tuningKey); // ['E', 'B', 'G', ...]
        const tuningWithOctaves = TUNINGS[tuningKey]; // ['E4', 'B3', 'G3', ...]

        if (!(container instanceof HTMLElement)) return;
        const standardizedRoot = standardizeNoteName(rootNote);
        if (!NOTES.includes(standardizedRoot) || !SCALES[scaleName] || !tuningNoteNameArray) return;

        container.querySelectorAll('.note').forEach(noteEl => noteEl.remove());

        if (container.id === 'chord-fretboard' && UI.elements.measures?.children.length > 0 && AppState.currentMeasureIndex < UI.elements.measures.children.length) {
            const currentMeasureEl = UI.elements.measures.children[AppState.currentMeasureIndex];
            const chordRoot = currentMeasureEl.querySelector('.chord-controls .root-note')?.value;
            const chordQuality = currentMeasureEl.querySelector('.chord-controls .chord-quality')?.value;
            const displayScaleName = SCALES_DISPLAY_NAMES[scaleName] || scaleName;
            if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = `${standardizedRoot} ${displayScaleName} (for ${chordRoot || "?"}${chordQuality || "?"})`;
        }

        const scaleIntervals = SCALES[scaleName];
        const rootNoteIndex = NOTES.indexOf(standardizedRoot);
        const scaleNotesInKey = scaleIntervals.map(interval => NOTES[(rootNoteIndex + interval) % 12]);

        const numStrings = tuningNoteNameArray.length;
        const numFrets = 12;

        for (let stringIdx = 0; stringIdx < numStrings; stringIdx++) {
            const openStringFull = tuningWithOctaves[stringIdx]; // e.g., "E4"
            const openNoteName = openStringFull.slice(0, -1); // "E"
            const openNoteOctave = parseInt(openStringFull.slice(-1)); // 4
            const openNoteIndexGlobal = NOTES.indexOf(standardizeNoteName(openNoteName));

            if (openNoteIndexGlobal === -1) continue;

            for (let fret = 0; fret <= numFrets; fret++) {
                const noteAbsIndex = openNoteIndexGlobal + fret;
                const currentNoteName = NOTES[noteAbsIndex % 12];

                if (scaleNotesInKey.includes(currentNoteName)) {
                    const noteElement = document.createElement('div');
                    noteElement.className = 'note';
                    noteElement.textContent = currentNoteName;

                    const fretOffset = fret === 0 ? 0.02 : ((fret - 0.5) / numFrets);
                    noteElement.style.left = `${fretOffset * 100}%`;
                    noteElement.style.top = `${(stringIdx / (numStrings - 1)) * 100}%`;

                    const currentOctave = openNoteOctave + Math.floor((NOTES.indexOf(standardizeNoteName(openNoteName)) + fret) / 12);
                    const sampleNoteFilePart = DISPLAY_TO_SAMPLE_NOTE_MAP[currentNoteName];
                    noteElement.dataset.note = `${sampleNoteFilePart}${currentOctave}`;

                    if (currentNoteName === standardizedRoot) noteElement.classList.add('root-note-highlight');
                    else noteElement.classList.add('scale-note-highlight');
                    
                    container.appendChild(noteElement);
                }
            }
        }
    }


    // --- Beat Creation and Playback Logic ---
    function createBeats() { /* ... (Keep your existing robust createBeats logic, ensure dataset.beatIndex is used) ... */
        const container = UI.elements.beatsContainer;
        if (!container) { console.error(`${LOG_PREFIX} Beats container not found.`); return; }
        container.innerHTML = '';

        const timeSigStr = UI.elements.timeSignature?.value || '4/4';
        const [beatsPerMeasureNum, beatUnit] = timeSigStr.split('/').map(Number);
        const soundType = UI.elements.soundType?.value || 'click';
        
        // Determine total subdivisions based on time signature
        let totalDisplayBeatsInCycle;
        if (timeSigStr === '8/8') { // Special case for 4/4 with 8th notes
            totalDisplayBeatsInCycle = 8;
        } else if (beatUnit === 8) { // For x/8 time signatures like 6/8, 12/8
            totalDisplayBeatsInCycle = beatsPerMeasureNum; // Each beat is an 8th note
        } else { // For x/4 time signatures
            totalDisplayBeatsInCycle = beatsPerMeasureNum * 2; // Default to 8th note subdivisions
        }


        const beatPatternConfig = { // Example patterns, expand as needed
            '4/4_drums': [ // This is for 4/4 when treated as 8 subdivisions
                { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
                { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50', label: '2' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
                { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D', label: '3' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
                { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50', label: '4' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
            ],
            '4/4_click': [ // For 4/4 with 8 subdivisions
                { sound: ['click'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
                { sound: ['click'], volume: '0.7', color: '#4CAF50', label: '2' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
                { sound: ['click'], volume: '1', color: '#1F618D', label: '3' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
                { sound: ['click'], volume: '0.7', color: '#4CAF50', label: '4' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            ],
             '8/8_drums': beatPatternConfig['4/4_drums'], // Alias for clarity
             '8/8_click': beatPatternConfig['4/4_click'], // Alias for clarity
            '3/4_drums': [ // 6 subdivisions for 3/4
                { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
                { sound: ['snare', 'hihat'], volume: '0.8', color: '#4CAF50', label: '2' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
                { sound: ['snare', 'hihat'], volume: '0.8', color: '#4CAF50', label: '3' }, { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '&' },
            ],
            '3/4_click': [ // 6 subdivisions for 3/4
                { sound: ['click'], volume: '1', color: '#1F618D', label: '1' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
                { sound: ['click'], volume: '0.7', color: '#4CAF50', label: '2' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
                { sound: ['click'], volume: '0.7', color: '#4CAF50', label: '3' }, { sound: ['silent'], volume: '0', color: '#666666', label: '&' },
            ],
            '6/8_drums': [ // 6 beats, each an 8th note
                { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D', label: '1' }, 
                { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '2' },
                { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '3' },
                { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50', label: '4' },
                { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '5' },
                { sound: ['hihat'], volume: '0.7', color: '#9E9E9E', label: '6' },
            ],
            '6/8_click': [
                { sound: ['click'], volume: '1', color: '#1F618D', label: '1' }, 
                { sound: ['click'], volume: '0.7', color: '#9E9E9E', label: '2' },
                { sound: ['click'], volume: '0.7', color: '#9E9E9E', label: '3' },
                { sound: ['click'], volume: '1', color: '#4CAF50', label: '4' },
                { sound: ['click'], volume: '0.7', color: '#9E9E9E', label: '5' },
                { sound: ['click'], volume: '0.7', color: '#9E9E9E', label: '6' },
            ]
            // Add more patterns for 2/4, 7/8, 12/8 etc.
        };
        const currentPatternKey = `${timeSigStr}_${soundType}`;
        const pattern = beatPatternConfig[currentPatternKey] || beatPatternConfig[`${beatsPerMeasureNum}/${beatUnit}_click`] || beatPatternConfig['4/4_click']; // Fallback

        for (let i = 0; i < totalDisplayBeatsInCycle; i++) {
            const beatEl = document.createElement('div');
            beatEl.className = 'beat';
            beatEl.dataset.beatIndex = i.toString(); // Store 0-based index in the cycle
            const config = pattern[i % pattern.length]; // Cycle through pattern if not enough defined
            beatEl.textContent = config.label || (Math.floor(i / (beatUnit === 8 ? 1 : 2)) + 1).toString(); // Basic label
            beatEl.dataset.sound = Array.isArray(config.sound) ? config.sound.join(',') : config.sound;
            beatEl.dataset.baseVolume = config.volume;
            beatEl.style.backgroundColor = config.color;
            beatEl.addEventListener('click', () => toggleBeatState(beatEl, timeSigStr, soundType));
            container.appendChild(beatEl);
        }
    }

    function toggleBeatState(beatElement, timeSignature, soundType) { /* ... (Keep your existing toggleBeatState logic) ... */
        const currentSounds = beatElement.dataset.sound.split(',');
        const currentVolume = parseFloat(beatElement.dataset.baseVolume);
        let nextState;

        if (soundType === 'click' || soundType === 'woodblock') {
            if (currentVolume >= 1.0) nextState = { sound: [soundType], volume: '0.7', color: '#4CAF50' }; // Strong to normal
            else if (currentVolume > 0) nextState = { sound: ['silent'], volume: '0', color: '#666666' }; // Normal to silent
            else nextState = { sound: [soundType], volume: '1.0', color: '#1F618D' }; // Silent to strong
        } else if (soundType === 'drums') {
            const drumCycle = ['kick', 'snare', 'hihat', 'silent']; // Simple cycle
            let currentMainSound = currentSounds.find(s => drumCycle.includes(s) && s !== 'hihat') || currentSounds[0];
            let currentSoundIndex = drumCycle.indexOf(currentMainSound);
            if (currentSoundIndex === -1 || currentMainSound === 'silent') currentSoundIndex = drumCycle.length -1; // Start from silent -> kick
            
            const nextSound = drumCycle[(currentSoundIndex + 1) % drumCycle.length];
            if (nextSound === 'silent') {
                nextState = { sound: ['silent'], volume: '0', color: '#666666' };
            } else {
                const newSounds = [nextSound];
                // Optionally re-add hihat if it was there or if it's kick/snare
                if (nextSound !== 'hihat' && (currentSounds.includes('hihat') || ['kick', 'snare'].includes(nextSound))) {
                     // newSounds.push('hihat'); // Decide if hihat is always added or toggled separately
                }
                nextState = { 
                    sound: newSounds, 
                    volume: (nextSound === 'kick' || nextSound === 'snare') ? '1.0' : '0.7', 
                    color: (nextSound === 'kick') ? '#1F618D' : (nextSound === 'snare' ? '#4CAF50' : '#9E9E9E')
                };
            }
        } else { // Fallback
            nextState = { sound: ['click'], volume: '0.7', color: '#4CAF50' };
        }
        beatElement.dataset.sound = nextState.sound.join(',');
        beatElement.dataset.baseVolume = nextState.volume;
        beatElement.style.backgroundColor = nextState.color;
    }

    async function playBeat() {
        if (!AppState.isPlaying) return;
        const allBeatElements = UI.elements.beatsContainer?.querySelectorAll('.beat');
        if (!allBeatElements || allBeatElements.length === 0) return;

        allBeatElements.forEach(b => b.classList.remove('active'));
        const currentBeatVisualEl = allBeatElements[AppState.currentBeatInMeasureCycle % allBeatElements.length];
        if (currentBeatVisualEl) {
            currentBeatVisualEl.classList.add('active');
            const baseBeatVol = parseFloat(currentBeatVisualEl.dataset.baseVolume) || 0;
            if (baseBeatVol > 0 && UI.elements.metronomeVolume?.value > 0) {
                await playMetronomeSound(baseBeatVol);
            }
        }

        const measureElements = UI.elements.measures?.children;
        const timeSigStr = UI.elements.timeSignature?.value || '4/4';
        const [beatsPerMeasureNum, beatUnit] = timeSigStr.split('/').map(Number);
        
        let totalSubdivisionsInCycle;
        if (timeSigStr === '8/8') totalSubdivisionsInCycle = 8;
        else if (beatUnit === 8) totalSubdivisionsInCycle = beatsPerMeasureNum;
        else totalSubdivisionsInCycle = beatsPerMeasureNum * 2; // Default 8th note subdivisions for x/4

        if (measureElements && measureElements.length > 0) {
            const currentMeasureEl = measureElements[AppState.currentMeasureIndex % measureElements.length];
            if (currentMeasureEl) {
                if (AppState.currentBeatInMeasureCycle === 0) { // Start of a new measure cycle
                    Array.from(measureElements).forEach((m, idx) => {
                        m.classList.toggle('active', idx === (AppState.currentMeasureIndex % measureElements.length));
                    });
                    const scaleRoot = currentMeasureEl.querySelector('.scale-controls .second-key')?.value;
                    const scaleType = currentMeasureEl.querySelector('.scale-controls .scale-select')?.value;
                    const tuningVal = UI.elements.chordTuning?.value;
                    if (scaleRoot && scaleType && tuningVal && UI.elements.chordFretboard) {
                        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuningVal);
                    }
                }

                if (AppState.chordsEnabled) {
                    const root = currentMeasureEl.querySelector('.chord-controls .root-note')?.value;
                    const quality = currentMeasureEl.querySelector('.chord-controls .chord-quality')?.value;
                    const tempo = AppState.tempo;
                    const beatDurationSec = 60 / tempo;
                    
                    let shouldPlayChord = false;
                    let chordDurationBeats = beatsPerMeasureNum; // Default: chord lasts whole measure (main beats)

                    if (totalSubdivisionsInCycle === 8 && beatsPerMeasureNum === 4) { // 4/4 with 8th notes
                        if (AppState.currentBeatInMeasureCycle === 0 || AppState.currentBeatInMeasureCycle === 4) shouldPlayChord = true;
                        chordDurationBeats = 2; // Chord lasts 2 quarter notes (4 eighths)
                    } else if (AppState.currentBeatInMeasureCycle === 0) { // For other sigs, play on first beat
                        shouldPlayChord = true;
                    }
                    
                    if (shouldPlayChord && root && quality) {
                        // Duration in ms: if subdivided, use subdivision interval, else main beat interval
                        const singleBeatIntervalMs = (beatUnit === 8) ? beatDurationSec * 1000 : (beatDurationSec / 2) * 1000;
                        const chordDurationMs = singleBeatIntervalMs * ( (totalSubdivisionsInCycle === 8 && beatsPerMeasureNum === 4) ? 4 : totalSubdivisionsInCycle );
                        await playChord(root, quality, chordDurationMs);
                    }
                }
            }
        }
        
        AppState.currentBeatInMeasureCycle = (AppState.currentBeatInMeasureCycle + 1) % totalSubdivisionsInCycle;
        if (AppState.currentBeatInMeasureCycle === 0 && measureElements && measureElements.length > 0) {
            AppState.currentMeasureIndex = (AppState.currentMeasureIndex + 1) % measureElements.length;
        }
    }

    async function startPlayback() {
        try {
            await AudioContextManager.ensureAudioContext();
            if (!AudioContextManager.samplesFullyLoaded && !confirm("Audio samples might still be loading. Continue?")) return;
            if (AppState.isPlaying) return;
            if (!UI.elements.measures?.children.length) { alert('No measures defined.'); return; }

            AppState.tempo = parseInt(UI.elements.tempoSlider?.value || 120);
            AppState.updateState({ isPlaying: true, currentBeatInMeasureCycle: 0, currentMeasureIndex: 0 });
            if (AppState.intervalId) clearInterval(AppState.intervalId);

            const timeSigStr = UI.elements.timeSignature?.value || '4/4';
            const [, beatUnit] = timeSigStr.split('/').map(Number);
            let intervalMs = (60 / AppState.tempo) * 1000; // Duration of one main beat (e.g., quarter note)
            
            // If time signature implies 8th note pulse (e.g. x/8 or 4/4 displayed as 8/8)
            if (beatUnit === 8 || timeSigStr === '8/8') {
                // Interval is already for the 8th note if tempo is for 8th notes.
                // If tempo is for quarter notes in x/8, then intervalMs should be halved.
                // Assuming tempo slider always refers to quarter notes for simplicity here, adjust if needed.
                // For 6/8, 12/8, tempo is often felt in dotted quarters.
                // For this metronome, let's assume tempo is per main beat unit shown in time sig (e.g. quarter for 4/4, eighth for 6/8)
                // If it's 4/4 but we're doing 8th note subdivisions (selected as "8/8"), then halve quarter note interval.
                if (timeSigStr === '8/8') intervalMs /= 2; 
            } else { // For x/4, default to 8th note subdivision interval
                 intervalMs /= 2;
            }


            // Initial setup for first beat/measure
            const firstMeasureEl = UI.elements.measures.children[0];
            if (firstMeasureEl) {
                Array.from(UI.elements.measures.children).forEach(m => m.classList.remove('active'));
                firstMeasureEl.classList.add('active');
                const initialScaleRoot = firstMeasureEl.querySelector('.scale-controls .second-key')?.value;
                const initialScaleType = firstMeasureEl.querySelector('.scale-controls .scale-select')?.value;
                const tuningValue = UI.elements.chordTuning?.value;
                if (initialScaleRoot && initialScaleType && tuningValue) {
                    updateFretboardNotes(UI.elements.chordFretboard, initialScaleRoot, initialScaleType, tuningValue);
                }
            }
            
            await playBeat(); // Play first beat immediately
            AppState.intervalId = setInterval(playBeat, intervalMs);
            UI.elements.startStop.textContent = 'Stop';
            log(`Playback started. Interval: ${intervalMs}ms`);
        } catch (error) {
            console.error(`${LOG_PREFIX} Failed to start playback:`, error);
            alert(`Error starting playback: ${error.message}.`);
            stopPlayback();
        }
    }

    function stopPlayback() {
        if (AppState.intervalId) clearInterval(AppState.intervalId);
        AppState.intervalId = null;
        AudioContextManager.stopAllSounds();
        AppState.updateState({ isPlaying: false });
        document.querySelectorAll('.beat.active, .measure.active').forEach(el => el.classList.remove('active'));
        if (UI.elements.startStop) UI.elements.startStop.textContent = 'Start';
        log("Playback stopped.");
    }

    // --- Progression and Measure Management ---
    function loadProgression(progressionName, overrideKey = null) { /* ... (Keep your existing robust loadProgression) ... */
        const progressionData = progressions[progressionName];
        if (!progressionData) { console.error(`${LOG_PREFIX} Progression not found: ${progressionName}`); return; }

        const selectedKey = overrideKey || UI.elements.keySelect?.value || progressionData.defaultKey || "C";
        if (UI.elements.keySelect) UI.elements.keySelect.value = selectedKey;
        
        const measuresContainer = UI.elements.measures;
        if (!measuresContainer) return;
        measuresContainer.innerHTML = ''; 

        let firstChordDetails = null;
        if (!progressionData.progression || !Array.isArray(progressionData.progression)) return;

        progressionData.progression.forEach((chordFunc, index) => {
            const parsedChord = getChordFromFunction(chordFunc, selectedKey);
            if (!parsedChord || !parsedChord.root || !parsedChord.quality) return; 
            if (index === 0) firstChordDetails = { ...parsedChord, scaleType: suggestScaleForQuality(parsedChord.quality) };
            addMeasureWithChordDOM(parsedChord, index); // 0-based index for internal consistency
        });
        updateMeasureNumbers(); // Renumber after adding all

        if (UI.elements.chordFretboard && firstChordDetails) {
            const tuningValue = UI.elements.chordTuning?.value || 'standard';
            if (TUNINGS[tuningValue] && firstChordDetails.scaleType) {
                updateFretboardNotes(UI.elements.chordFretboard, firstChordDetails.root, firstChordDetails.scaleType, tuningValue);
            }
        }
        log(`Loaded progression: ${progressionData.displayName || progressionName} in key ${selectedKey}.`);
    }

    function addMeasureWithChordDOM(parsedChord, measureIndex) { // measureIndex is 0-based
        const measure = document.createElement('div');
        measure.className = 'measure';
        measure.draggable = true;
        measure.dataset.measureIndex = measureIndex; // Store 0-based index

        const rootNote = parsedChord.root || 'C';
        const quality = parsedChord.quality || 'maj7';
        const suggestedScale = suggestScaleForQuality(quality) || 'major';

        measure.innerHTML = `
            <span class="measure-number">${measureIndex + 1}</span>
            <div class="chord-controls">
                <div><label>Chord:</label><select class="root-note">${createKeyOptions(rootNote)}</select></div>
                <div><label>Quality:</label><select class="chord-quality">${createQualityOptions(quality)}</select></div>
            </div>
            <div class="scale-controls">
                <div><label>Scale Root:</label><select class="second-key">${createKeyOptions(rootNote)}</select></div>
                <div><label>Scale Type:</label><select class="scale-select">${createScaleOptions(suggestedScale)}</select></div>
            </div>
            <button class="delete-measure-btn" title="Delete measure">X</button>
        `;
        UI.elements.measures.appendChild(measure);
        setupIndividualMeasureEventListeners(measure);
    }
    function updateProgressionKey(newKey) { /* ... (Keep your existing robust updateProgressionKey) ... */
        const selectedProgName = UI.elements.progressionSelect?.value;
        const progressionData = progressions[selectedProgName];
        if (!progressionData || !progressionData.progression) return;

        Array.from(UI.elements.measures?.children || []).forEach((measureEl, index) => {
            const chordFunc = progressionData.progression[index]; // Assumes progression array matches measures
            if (!chordFunc) return;
            const parsedChord = getChordFromFunction(chordFunc, newKey);
            if (!parsedChord) return;
            measureEl.querySelector('.root-note').value = parsedChord.root;
            measureEl.querySelector('.chord-quality').value = getQualityValue(parsedChord.quality);
            measureEl.querySelector('.second-key').value = parsedChord.root; // Default scale root to chord root
            measureEl.querySelector('.scale-select').value = suggestScaleForQuality(parsedChord.quality);
        });
        updateFretboardFromFirstMeasure();
        log(`Progression "${progressionData.displayName}" updated to key: ${newKey}`);
    }

    function addMeasure() {
        const measureCount = UI.elements.measures?.children.length || 0;
        addMeasureWithChordDOM({ root: 'C', quality: 'maj7' }, measureCount); // Add as next 0-based index
        updateMeasureNumbers();
    }
    function removeMeasure() {
        if (UI.elements.measures?.lastElementChild) {
            UI.elements.measures.lastElementChild.remove();
            updateMeasureNumbers();
        }
    }
    function updateMeasureNumbers() {
        Array.from(UI.elements.measures?.children || []).forEach((measure, index) => {
            measure.dataset.measureIndex = index; // Update 0-based index
            const numEl = measure.querySelector('.measure-number');
            if (numEl) numEl.textContent = (index + 1).toString(); // Display 1-based
        });
    }

    // --- Drag and Drop for Measures ---
    let draggedMeasure = null;
    function dragStart(e) { /* ... (Keep existing) ... */
        draggedMeasure = e.target.closest('.measure');
        if (!draggedMeasure) return;
        e.dataTransfer.effectAllowed = 'move';
        // e.dataTransfer.setData('text/plain', draggedMeasure.dataset.measureIndex); // Use index
        setTimeout(() => draggedMeasure.classList.add('dragging'), 0);
    }
    function dragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
    function drop(e) { /* ... (Keep existing, ensure updateMeasureNumbers is called) ... */
        e.preventDefault();
        const targetMeasure = e.target.closest('.measure');
        if (targetMeasure && draggedMeasure && draggedMeasure !== targetMeasure && UI.elements.measures?.contains(targetMeasure) && UI.elements.measures?.contains(draggedMeasure)) {
            const measuresArray = Array.from(UI.elements.measures.children);
            const draggedIdx = measuresArray.indexOf(draggedMeasure);
            const targetIdx = measuresArray.indexOf(targetMeasure);
            if (draggedIdx < targetIdx) {
                UI.elements.measures.insertBefore(draggedMeasure, targetMeasure.nextSibling);
            } else {
                UI.elements.measures.insertBefore(draggedMeasure, targetMeasure);
            }
        }
        if(draggedMeasure) draggedMeasure.classList.remove('dragging');
        draggedMeasure = null;
        updateMeasureNumbers(); // Crucial after reordering
    }
    function dragEnd(e) { if(e.target.classList) e.target.classList.remove('dragging'); draggedMeasure = null; }


    // --- FretFlow Multi-Fretboard Section ---
    function initializeFretFlow() { /* ... (Keep your existing robust initializeFretFlow) ... */
        const grid = UI.elements.fretboardsGrid;
        if (!grid) return;
        grid.innerHTML = ''; 
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(350px, 1fr))';
        grid.style.gap = '20px';

        for (let i = 0; i < 2; i++) { // Reduced to 2 for example, can be 4
            const section = document.createElement('div');
            section.className = 'fretboard-section app-section'; // Inherit app-section styling
            section.innerHTML = `
                <h4>Fretboard ${i + 1}</h4>
                <div class="fretboard-controls">
                    <div class="control-group"><label for="ff-key-${i}">Key:</label><select id="ff-key-${i}" class="fretflow-key">${createKeyOptions()}</select></div>
                    <div class="control-group"><label for="ff-scale-${i}">Scale:</label><select id="ff-scale-${i}" class="fretflow-scale">${createScaleOptions()}</select></div>
                    <div class="control-group"><label for="ff-tuning-${i}">Tuning:</label><select id="ff-tuning-${i}" class="tuning-select">${Object.keys(TUNINGS).map(val => `<option value="${val}">${val.charAt(0).toUpperCase() + val.slice(1)}</option>`).join('')}</select></div>
                </div>
                <div class="scale-display" id="ff-scale-display-${i}">C Major</div>
                <div id="ff-fretboard-${i}" class="fretboard fretflow-instance"></div>
            `;
            grid.appendChild(section);

            const fretboardEl = section.querySelector(`#ff-fretboard-${i}`);
            const keySelect = section.querySelector(`#ff-key-${i}`);
            const scaleSelect = section.querySelector(`#ff-scale-${i}`);
            const tuningSelect = section.querySelector(`#ff-tuning-${i}`);
            const scaleDisplayEl = section.querySelector(`#ff-scale-display-${i}`);

            const updateDisplay = () => {
                const key = keySelect.value;
                const scale = scaleSelect.value;
                const tuningName = tuningSelect.value;
                scaleDisplayEl.textContent = `${key} ${SCALES_DISPLAY_NAMES[scale] || scale}`;
                createFretboard(fretboardEl, getTuningNoteNames(tuningName));
                updateFretboardNotes(fretboardEl, key, scale, tuningName);
            };
            [keySelect, scaleSelect, tuningSelect].forEach(sel => sel.addEventListener('change', updateDisplay));
            setupFretboardInteractions(fretboardEl);
            updateDisplay(); 
        }
    }


    // --- Event Listener Setup ---
    function setupFretboardInteractions(fretboardContainer) {
        if (!fretboardContainer) return;
        fretboardContainer.addEventListener('click', async (event) => {
            const noteElement = event.target.closest('.note');
            if (noteElement && noteElement.dataset.note) {
                try {
                    const noteToPlay = noteElement.dataset.note;
                    const volume = parseFloat(UI.elements.chordFretboardVolume?.value || 0.7);
                    await playNoteOnFretboard(noteToPlay, volume);
                    noteElement.classList.add('note-active-feedback');
                    setTimeout(() => noteElement.classList.remove('note-active-feedback'), 150);
                } catch (error) { console.error(`${LOG_PREFIX} Error playing note from fretboard:`, error); }
            }
        });
    }
    function setupIndividualMeasureEventListeners(measureElement) {
        measureElement.addEventListener('dragstart', dragStart);
        // dragover and drop are on the container (UI.elements.measures)
        measureElement.addEventListener('dragend', dragEnd);

        measureElement.querySelectorAll('select').forEach(select => {
            select.addEventListener('change', (e) => {
                const rootVal = measureElement.querySelector('.root-note').value;
                const qualityVal = measureElement.querySelector('.chord-quality').value;
                if (e.target.matches('.root-note, .chord-quality')) {
                    measureElement.querySelector('.second-key').value = rootVal;
                    measureElement.querySelector('.scale-select').value = suggestScaleForQuality(qualityVal);
                }
                if (measureElement.dataset.measureIndex === '0') { // If it's the first measure
                    updateFretboardFromFirstMeasure();
                }
            });
        });
        measureElement.querySelector('.delete-measure-btn')?.addEventListener('click', () => {
            measureElement.remove();
            updateMeasureNumbers();
            if (UI.elements.measures.children.length > 0 && measureElement.dataset.measureIndex === '0') {
                 updateFretboardFromFirstMeasure(); // Update if first was deleted and new first exists
            } else if (UI.elements.measures.children.length === 0 && UI.elements.scaleDisplay) {
                UI.elements.scaleDisplay.textContent = "Add a measure"; // Clear display if no measures
            }
        });
    }
    function updateFretboardFromFirstMeasure() {
        const firstMeasure = UI.elements.measures?.firstElementChild;
        if (firstMeasure) {
            const scaleRoot = firstMeasure.querySelector(".second-key")?.value;
            const scaleType = firstMeasure.querySelector(".scale-select")?.value;
            const tuningName = UI.elements.chordTuning?.value || 'standard';
            if (scaleRoot && scaleType && TUNINGS[tuningName] && UI.elements.chordFretboard) {
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuningName);
            }
        } else if (UI.elements.scaleDisplay) { // No measures left
             UI.elements.scaleDisplay.textContent = "Add a measure";
             if(UI.elements.chordFretboard) UI.elements.chordFretboard.querySelectorAll('.note').forEach(n => n.remove());
        }
    }

    function setupGlobalEventListeners() {
        const addSafeListener = (element, event, handler) => {
            if (element) element.addEventListener(event, handler);
            else console.warn(`${LOG_PREFIX} Element not found for listener for event: ${event}`);
        };
        
        addSafeListener(UI.elements.startAppButton, 'click', async () => {
            if (!AppState.audioInitialized) {
                try {
                    UI.elements.startAppButton.disabled = true;
                    UI.elements.startAppButton.textContent = "Initializing...";
                    await AudioContextManager.initialize();
                    await AudioContextManager.loadAllSoundSamples(); // Load samples after context is ready
                    UI.elements.startAppButton.textContent = "Audio Ready";
                    setTimeout(() => { UI.elements.startAppButton.style.display = 'none'; }, 1000);
                } catch (error) {
                    UI.elements.startAppButton.textContent = "Audio Init Failed";
                    UI.elements.startAppButton.disabled = false;
                }
            }
        }, { once: true });


        addSafeListener(UI.elements.startStop, 'click', () => AppState.isPlaying ? stopPlayback() : startPlayback());
        addSafeListener(UI.elements.progressionSelect, 'change', e => loadProgression(e.target.value));
        addSafeListener(UI.elements.keySelect, 'change', e => updateProgressionKey(e.target.value));
        
        addSafeListener(UI.elements.tempoSlider, 'input', debounce(() => {
            AppState.tempo = parseInt(UI.elements.tempoSlider.value);
            if (UI.elements.tempoDisplay) UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            if (AppState.isPlaying) { stopPlayback(); startPlayback(); } // Restart with new tempo
        }, 100)); // Debounce to avoid too many restarts

        addSafeListener(UI.elements.tapTempo, 'click', () => {
            const now = performance.now();
            if (AppState.lastTapTime > 0) {
                const diff = now - AppState.lastTapTime;
                if (diff < 2000) { // Max 2 seconds between taps
                    AppState.tapTempoIntervals.push(diff);
                    if (AppState.tapTempoIntervals.length > 4) AppState.tapTempoIntervals.shift();
                    if (AppState.tapTempoIntervals.length >= 2) {
                        const avgInterval = AppState.tapTempoIntervals.reduce((a,b) => a+b, 0) / AppState.tapTempoIntervals.length;
                        const newTempo = Math.round(60000 / avgInterval);
                        AppState.tempo = Math.max(40, Math.min(240, newTempo));
                        if(UI.elements.tempoSlider) UI.elements.tempoSlider.value = AppState.tempo;
                        if(UI.elements.tempoDisplay) UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                        if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
                    }
                } else { AppState.tapTempoIntervals = []; } // Reset if tap too late
            } else { AppState.tapTempoIntervals = []; } // First tap
            AppState.lastTapTime = now;
        });

        addSafeListener(UI.elements.timeSignature, 'change', () => { createBeats(); if (AppState.isPlaying) { stopPlayback(); startPlayback(); } });
        addSafeListener(UI.elements.soundType, 'change', e => {
            if (UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.style.display = e.target.value === 'drums' ? 'inline-block' : 'none';
            createBeats();
        });
        addSafeListener(UI.elements.drumSetToggleBtn, 'click', () => {
            currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
            UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
            playDrumSamplePreview('kick'); // Preview new kit
        });

        addSafeListener(UI.elements.reverbDial, 'input', e => {
            const newReverbValue = parseFloat(e.target.value) / 100;
            if (AudioContextManager.reverbGainNode) AudioContextManager.reverbGainNode.gain.value = newReverbValue;
            if (UI.elements.reverbDialValue) UI.elements.reverbDialValue.textContent = e.target.value;
        });

        addSafeListener(UI.elements.darkModeToggle, 'click', () => {
            AppState.currentDarkMode = (AppState.currentDarkMode + 1) % 4; // 0: light, 1-3: dark modes
            document.body.classList.remove('dark-mode', 'dark-mode-2', 'dark-mode-3');
            UI.elements.darkModeToggle.classList.remove('active', 'active-2', 'active-3');
            if (AppState.currentDarkMode === 1) { document.body.classList.add('dark-mode'); UI.elements.darkModeToggle.classList.add('active'); }
            else if (AppState.currentDarkMode === 2) { document.body.classList.add('dark-mode-2'); UI.elements.darkModeToggle.classList.add('active-2'); }
            else if (AppState.currentDarkMode === 3) { document.body.classList.add('dark-mode-3'); UI.elements.darkModeToggle.classList.add('active-3'); }
            // Else it's light mode (class removed)
        });
        addSafeListener(UI.elements.chordsEnabled, 'click', () => {
            AppState.chordsEnabled = !AppState.chordsEnabled;
            UI.elements.chordsEnabled.textContent = AppState.chordsEnabled ? "Chords ON" : "Chords OFF";
            UI.elements.chordsEnabled.classList.toggle('active', AppState.chordsEnabled);
        });
        addSafeListener(UI.elements.chordTuning, 'change', () => {
            updateFretboardFromFirstMeasure();
            initializeFretFlow(); // Re-init FretFlow as tunings affect it
        });

        addSafeListener(UI.elements.addMeasureBtn, 'click', addMeasure);
        addSafeListener(UI.elements.removeMeasureBtn, 'click', removeMeasure);

        // Drum Pad Listeners
        ['kickButton', 'snareButton', 'hihatClosedButton'].forEach(id => {
            addSafeListener(UI.elements[id], 'click', () => {
                let drumSound = id.replace('Button', '').replace('hihatClosed', 'hihat'); // Simplify name
                playDrumSamplePreview(drumSound);
            });
        });
        
        // Event delegation for measure controls (drag/drop on container)
        if (UI.elements.measures) {
            UI.elements.measures.addEventListener('dragover', dragOver);
            UI.elements.measures.addEventListener('drop', drop);
        }
        log("Global event listeners set up.");
    }

    // --- Application Initialization ---
    async function initializeApp() {
        updateLoadingStatus("Initializing UI...", null);
        UI.init();
        
        updateLoadingStatus("Setting up interface components...", null);
        createBeats();
        if (UI.elements.chordFretboard && UI.elements.chordTuning) {
            createFretboard(UI.elements.chordFretboard, getTuningNoteNames(UI.elements.chordTuning.value));
            setupFretboardInteractions(UI.elements.chordFretboard);
            updateFretboardNotes(UI.elements.chordFretboard, 'C', 'major', UI.elements.chordTuning.value);
        }
        initializeFretFlow();

        setupGlobalEventListeners();

        if (UI.elements.progressionSelect?.value) {
            loadProgression(UI.elements.progressionSelect.value);
        } else if (UI.elements.progressionSelect && progressions && Object.keys(progressions).length > 0) {
            // Auto-load the first progression from the list if none explicitly selected
            const firstProgKey = Object.keys(progressions)[0];
            UI.elements.progressionSelect.value = firstProgKey;
            loadProgression(firstProgKey);
        } else {
            addMeasure(); // Add one default measure if no progressions
        }
        
        if (UI.elements.tempoDisplay && UI.elements.tempoSlider) UI.elements.tempoDisplay.textContent = `${UI.elements.tempoSlider.value} BPM`;
        if (UI.elements.reverbDialValue && UI.elements.reverbDial) UI.elements.reverbDialValue.textContent = UI.elements.reverbDial.value;
        if (UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;

        updateLoadingStatus("Ready. Click 'Initialize Audio' to load sounds.", null);
        log("Application initialized. Waiting for audio interaction.");
    }

    // --- Global Error Handling ---
    window.addEventListener('error', (event) => {
        console.error(`${LOG_PREFIX} Global error:`, event.error, event.message);
        updateLoadingStatus('An unexpected error occurred. Please refresh.', null, true);
    });
    window.addEventListener('unhandledrejection', (event) => {
        console.error(`${LOG_PREFIX} Unhandled promise rejection:`, event.reason);
        updateLoadingStatus('Async error. Please refresh.', null, true);
    });

    // --- Start the App ---
    document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
