<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png"> <!-- Ensure jazzmaster.png exists -->
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
    font-family: 'Lato', sans-serif;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background-color: #1f618d; /* Default light mode background */
    color: #333; /* Default light mode text */
    transition: background-color 0.3s ease, color 0.3s ease;
    }
    .app-section {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    .fretboards-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-bottom: 30px;
    }
    .fretboard-container {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    .scale-display {
    font-size: 1.2em;
    font-weight: bold;
    text-align: center;
    margin-bottom: 15px;
    color: #333; /* Default light mode text */
    transition: color 0.3s ease;
    }
    .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    flex-wrap: wrap;
    }

    .controls-container {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
    }

    .control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    }

    .control-group label {
    font-weight: bold;
    }

    .control-group select {
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #ccc;
    background-color: white; /* Default light mode */
    color: #333; /* Default light mode */
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    .fretboard {
    position: relative;
    height: 200px;
    background-color: #FFCF79; /* Light wood color */
    border-radius: 5px;
    margin-bottom: 30px;
    border: 2px solid #4B1C2E; /* Dark wood border */
    overflow: visible;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    .fret-line {
    position: absolute;
    top: 0;
    height: 100%;
    width: 2px;
    background: #c0c0c0;
    border-right: 1px solid rgba(0, 0, 0, 0.3);
    z-index: 1;
    }
    .string-line {
    position: absolute;
    left: 0;
    width: 100%;
    height: 1px;
    background: silver;
    border-bottom: 1px solid rgba(0, 0, 0, 0.3);
    z-index: 0;
    }
    .fret-number {
    position: absolute;
    bottom: -40px; /* Adjusted for better spacing */
    font-size: 16px;
    color: #1f618d; /* Match body background */
    transform: translateX(-50%);
    font-weight: bold;
    z-index: 2;
    width: 20px;
    text-align: center;
    transition: color 0.3s ease;
    }
    .fret-marker {
    position: absolute;
    width: 12px;
    height: 12px;
    background-color: #333; /* Dark marker */
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: background-color 0.3s ease;
    }
    .note {
    position: absolute;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: white; /* Text color inside note */
    background-color: #4CAF50; /* Default note color */
    z-index: 3;
    cursor: pointer;
    transform: translate(-50%, -50%);
    transition: transform 0.1s ease, background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .note:hover {
    transform: translate(-50%, -50%) scale(1.2);
    }
    .note.root {
        background-color: #BD2031; /* Red for root notes */
    }
    .note.degree-2-4-6 {
        background-color: #006400; /* Dark green for specific degrees */
    }

    .beat {
    width: 40px;
    height: 80px;
    background: #9E9E9E; /* Default beat color */
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: white;
    font-weight: bold;
    transition: all 0.2s ease;
    font-size: 14px;
    margin: 0 2px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .beats-container {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin: 20px 0;
    flex-wrap: nowrap; /* Keep beats in a line */
    overflow-x: auto; /* Allow scrolling if too many beats */
    padding-bottom: 10px; /* Space for scrollbar */
    }
    .beat.active {
    transform: translateY(-10px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    #measures {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
    gap: 20px;
    margin-top: 15px; /* Space above measures */
    }
    .measure {
    position: relative;
    background-color: #e9ecef;
    padding: 15px;
    border-radius: 4px;
    transition: opacity 0.2s ease, background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    border: 1px solid #ced4da;
    color: #333; /* Default text color */
    }
    .measure.dragging {
    opacity: 0.5;
    }
    .measure.active {
    background-color: #c3e6cb; /* Light green highlight */
    border: 2px solid #28a745; /* Green border */
    }
    .measure-number {
    position: absolute;
    top: 5px;
    right: 5px;
    font-size: 12px;
    color: #6c757d; /* Grey number */
    transition: color 0.3s ease;
    }
    .chord-controls, .scale-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    }
    .chord-controls select, .scale-controls select {
    flex: 1; /* Make selects fill space */
    min-width: 80px; /* Prevent selects from becoming too small */
    }

    .fretboard-section {
    border: 1px solid #ccc;
    padding: 15px;
    border-radius: 8px;
    background-color: #f9f9f9;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .fretboard-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 15px;
    }

    .volume-control {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
    transition: color 0.3s ease;
    }
    .volume-control label, .volume-control span {
        min-width: 100px; /* Ensure label width consistency */
    }
    .volume-control input[type="range"] {
        flex-grow: 1; /* Allow slider to take available space */
    }

    button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    background: #4CAF50; /* Green */
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    button:hover {
        background-color: #45a049; /* Darker green */
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    select {
    padding: 5px;
    margin: 5px 0; /* Adjusted margin */
    border-radius: 5px;
    border: 1px solid #ddd;
    background-color: white;
    color: #333;
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    #tempo-display {
    font-size: 1.2em;
    font-weight: bold;
    margin: 0 10px;
    min-width: 80px; /* Ensure space for BPM */
    text-align: center;
    }
    #loading-indicator {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 5px;
    z-index: 1000;
    }

    .checkbox-wrapper {
    margin-top: 10px; /* Reduced space */
    margin-left: 0; /* Align with other controls */
    display: flex;
    align-items: center;
    }

    .control-button {
    padding: 8px 16px;
    border: none;
    border-radius: 5px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .control-button:hover {
    background: #45a049;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .toggle-button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    background: #4CAF50; /* Active state */
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .toggle-button:not(.active) {
    background: #9E9E9E; /* Inactive state */
    }
    .toggle-button:hover {
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    #dark-mode-toggle {
        margin-bottom: 10px; /* Space below toggle */
    }

    /* --- Dark Mode 1 --- */
    body.dark-mode { background-color: #283618; color: #fefae0; }
    .dark-mode .app-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
    .dark-mode .fretboard-container { background-color: #606c38; border: 1px solid #dda15e; }
    .dark-mode .fretboard { background-color: #dda15e; border: 2px solid #4b4b4b; }
    .dark-mode .fret-number { color: #fefae0; }
    .dark-mode .fret-marker { background-color: #fefae0; }
    .dark-mode .note { background-color: #bc6c25; color: #283618; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    .dark-mode .note.root { background-color: #e76f51; } /* Adjusted root color */
    .dark-mode .note.degree-2-4-6 { background-color: #a7c957; } /* Adjusted degree color */
    .dark-mode .note:hover { background-color: #a5a58d; }
    .dark-mode .scale-display { color: #fefae0; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
    .dark-mode button, .dark-mode .control-button, .dark-mode .toggle-button { background-color: #dda15e; color: #283618; border: 1px solid #bc6c25; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode button:hover, .dark-mode .control-button:hover, .dark-mode .toggle-button:hover { background-color: #bc6c25; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
    .dark-mode .toggle-button:not(.active) { background: #606c38; border-color: #dda15e; }
    .dark-mode select { background-color: #dda15e; color: #283618; border: 1px solid #bc6c25; }
    .dark-mode select:hover { background-color: #bc6c25; }
    .dark-mode .measure { background-color: #606c38; color: #fefae0; border: 1px solid #dda15e; }
    .dark-mode .measure.active { background-color: #dda15e; border-color: #bc6c25; color: #283618; }
    .dark-mode .measure-number { color: #fefae0; opacity: 0.7; }
    .dark-mode .beat { background-color: #dda15e; color: #283618; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode .beat.active { background-color: #bc6c25; transform: translateY(-5px); }
    .dark-mode .volume-control { color: #fefae0; }
    .dark-mode #fretflow-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; }
    .dark-mode #dark-mode-toggle.active { background-color: #283618; color: #fefae0; border: 1px solid #dda15e; }

    /* --- Dark Mode 2 --- */
    body.dark-mode-2 { background-color: #0a1128; color: #fefcfb; }
    .dark-mode-2 .app-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 .fretboard-container { background-color: #034078; border: 1px solid #1282a2; }
    .dark-mode-2 .fretboard { background-color: #001f54; border: 2px solid #1282a2; }
    .dark-mode-2 .fret-number { color: #fefcfb; }
    .dark-mode-2 .fret-marker { background-color: #fefcfb; }
    .dark-mode-2 .note { background-color: #1282a2; color: #fefcfb; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 .note.root { background-color: #0a9396; }
    .dark-mode-2 .note.degree-2-4-6 { background-color: #94d2bd; color: #0a1128; }
    .dark-mode-2 .note:hover { background-color: #005f73; }
    .dark-mode-2 .scale-display { color: #fefcfb; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
    .dark-mode-2 button, .dark-mode-2 .control-button, .dark-mode-2 .toggle-button { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 button:hover, .dark-mode-2 .control-button:hover, .dark-mode-2 .toggle-button:hover { background-color: #005f73; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
    .dark-mode-2 .toggle-button:not(.active) { background: #034078; border-color: #1282a2; }
    .dark-mode-2 select { background-color: #034078; color: #fefcfb; border: 1px solid #1282a2; }
    .dark-mode-2 select:hover { background-color: #005f73; }
    .dark-mode-2 .measure { background-color: #034078; color: #fefcfb; border: 1px solid #1282a2; }
    .dark-mode-2 .measure.active { background-color: #1282a2; border-color: #fefcfb; color: #0a1128; }
    .dark-mode-2 .measure-number { color: #fefcfb; opacity: 0.7; }
    .dark-mode-2 .beat { background-color: #1282a2; color: #fefcfb; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-2 .beat.active { background-color: #005f73; transform: translateY(-5px); }
    .dark-mode-2 .volume-control { color: #fefcfb; }
    .dark-mode-2 #fretflow-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
    .dark-mode-2 #dark-mode-toggle.active-2 { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }

    /* --- Dark Mode 3 --- */
    body.dark-mode-3 { background-color: #6b705c; color: #ffe8d6; }
    .dark-mode-3 .app-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 .fretboard-container { background-color: #a5a58d; border: 1px solid #cb997e; }
    .dark-mode-3 .fretboard { background-color: #cb997e; border: 2px solid #6b705c; }
    .dark-mode-3 .fret-number { color: #ffe8d6; }
    .dark-mode-3 .fret-marker { background-color: #ffe8d6; }
    .dark-mode-3 .note { background-color: #b7b7a4; color: #6b705c; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 .note.root { background-color: #ddbea9; }
    .dark-mode-3 .note.degree-2-4-6 { background-color: #e9edc9; color: #6b705c; }
    .dark-mode-3 .note:hover { background-color: #a5a58d; }
    .dark-mode-3 .scale-display { color: #ffe8d6; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }
    .dark-mode-3 button, .dark-mode-3 .control-button, .dark-mode-3 .toggle-button { background-color: #cb997e; color: #6b705c; border: 1px solid #6b705c; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 button:hover, .dark-mode-3 .control-button:hover, .dark-mode-3 .toggle-button:hover { background-color: #b7b7a4; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
    .dark-mode-3 .toggle-button:not(.active) { background: #a5a58d; border-color: #cb997e; }
    .dark-mode-3 select { background-color: #ddbea9; color: #6b705c; border: 1px solid #cb997e; }
    .dark-mode-3 select:hover { background-color: #cb997e; }
    .dark-mode-3 .measure { background-color: #a5a58d; color: #ffe8d6; border: 1px solid #cb997e; }
    .dark-mode-3 .measure.active { background-color: #ddbea9; border-color: #cb997e; color: #6b705c; }
    .dark-mode-3 .measure-number { color: #ffe8d6; opacity: 0.7; }
    .dark-mode-3 .beat { background-color: #ddbea9; color: #6b705c; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
    .dark-mode-3 .beat.active { background-color: #cb997e; transform: translateY(-5px); }
    .dark-mode-3 .volume-control { color: #ffe8d6; }
    .dark-mode-3 #fretflow-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; }
    .dark-mode-3 #dark-mode-toggle.active-3 { background-color: #cb997e; color: #ffe8d6; border: 1px solid #6b705c; }

    @media (max-width: 768px) {
        .fretboards-grid {
            grid-template-columns: 1fr; /* Stack fretboards on smaller screens */
        }
        .controls-container {
            flex-direction: column; /* Stack controls vertically */
            align-items: flex-start;
        }
        .controls {
            flex-direction: column;
            align-items: stretch;
        }
        .volume-control {
            flex-direction: column;
            align-items: flex-start;
        }
        .volume-control input[type="range"] {
            width: 100%;
        }
        #measures {
            grid-template-columns: 1fr; /* Single column for measures */
        }
    }

    </style>
</head>
<body>
    <div class="app-section" id="chord-fretboard-section">
    <h1>BEBOP BLUEPRINT</h1>
    <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
    <button id="dark-mode-toggle" aria-label="Toggle dark mode">Theme</button>
    <div class="volume-control">
    <label for="chord-fretboard-volume">Fretboard Volume:</label>
    <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.05" value="0.3">
    </div>
    <div class="fretboard-container">
    <div class="scale-display" id="scale-display">C Major</div> <!-- Default text -->
    <div class="controls">
        <label for="chord-tuning">Tuning:</label>
        <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
            <option value="standard">Standard (EADGBE)</option>
            <option value="dropD">Drop D (DADGBE)</option>
            <option value="openG">Open G (DGDGBD)</option>
            <option value="DADGAD">DADGAD</option>
            <option value="openE">Open E (EBEG#BE)</option>
        </select>
    </div>
    <div id="chord-fretboard" class="fretboard"></div>
    </div>
    </div>

    <div class="app-section" id="metronome-section">
    <h2>BeatForge Metronome</h2>
    <h3>Click beats to change sound/accent</h3>
    <div class="controls">
        <label for="time-signature">Time Sig:</label>
        <select id="time-signature" aria-label="Select time signature">
            <option value="2">2/4</option>
            <option value="3">3/4</option>
            <option value="4" selected>4/4</option>
            <option value="6">6/8</option>
            <option value="7">7/8</option>
            <!-- <option value="8">8/8</option> --> <!-- 8/8 often felt as 4/4 -->
            <option value="12">12/8</option>
        </select>
        <label for="sound-type">Sound:</label>
        <select id="sound-type" aria-label="Select metronome sound">
            <option value="click">Click</option>
            <option value="woodblock">Woodblock</option>
            <option value="drums">Drums</option>
        </select>
        <button id="drumSetToggleBtn" class="control-button" style="display: none;">Drums</button> <!-- Hidden by default -->
        <label for="tempo">Tempo:</label>
        <input type="range" id="tempo" min="40" max="240" value="120" aria-label="Tempo">
        <span id="tempo-display">120 BPM</span>
        <button id="tap-tempo" aria-label="Tap tempo">Tap</button>
        <button id="start-stop" aria-label="Start or stop metronome">Start</button>
    </div>
        <!-- Add these inside the div with class="controls-section" -->
    <div>
        <label for="rhythm-pattern">Rhythm:</label>
        <select id="rhythm-pattern">
            <option value="downbeats">Downbeats</option>
            <option value="beats13">Beats 1 & 3</option>
            <option value="charleston">Charleston</option>
            <!-- Add more patterns later -->
        </select>
    </div>
    <div>
        <label for="two-chords">Two Chords/Measure:</label>
        <input type="checkbox" id="two-chords">
    </div>
    <div>
        <label for="voicing-type">Voicing Type:</label>
        <select id="voicing-type">
            <option value="standard">Standard</option>
            <option value="drop2">Drop 2</option>
            <option value="drop3">Drop 3</option>
            <option value="drop24">Drop 2 & 4</option>
            <!-- Add Rootless, Quartal later if needed -->
        </select>
    </div>
    <!-- End of new controls -->
     <div class="volume-control">
        <label for="metronome-volume">Metronome Vol:</label>
        <input type="range" id="metronome-volume" min="0" max="1" step="0.05" value="0.25" aria-label="Metronome volume">
    </div>
    <div class="volume-control">
        <label for="accent-intensity">Accent Intensity:</label>
        <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
    </div>
    <div class="beats-container"></div>
    </div>

    <div class="app-section" id="chord-progression-section">
    <h2>Chord Progression Practice</h2>
    <h3>Create a progression or pick one. Drag measures to reorder.</h3>
     <div class="controls">
        <label for="progression-select">Load Progression:</label>
        <select id="progression-select" aria-label="Select chord progression">
            <option value="">-- Select Standard --</option>
            <option value="I V7">I-V7</option>
            <option value="jazz_blues">Jazz Blues</option>
            <option value="minor_blues">Minor Blues</option>
            <option value="rhythm_changes">Rhythm Changes</option>
            <option value="2_5_1">II-V-I</option>
            <option value="6_2_5_1">VI-II-V-I</option>
            <option value="minor_2_5_1">Minor iim-V7-im</option>
            <option value="dark_eyes">Dark Eyes</option>
            <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams</option>
            <option value="rose_room">Rose Room</option>
            <option value="black_orpheus">Black Orpheus</option>
            <option value="all_the_things_you_are">All The Things You Are</option>
            <option value="all_of_me">All of Me</option>
            <option value="stella_by_starlight">Stella By Starlight</option>
            <option value="autumn_leaves">Autumn Leaves</option>
            <option value="summertime">Summertime</option>
            <option value="girl_from_ipanema">Girl From Ipanema</option>
            <option value="coltrane_changes">Coltrane Changes</option>
            <option value="bird_blues">Bird Blues</option>
            <option value="just_friends">Just Friends</option>
            <option value="blue_bossa">Blue Bossa</option>
            <option value="on_green_dolphin_street">On Green Dolphin Street</option>
            <option value="solar">Solar</option>
            <option value="misty">Misty</option>
            <option value="days_of_wine_and_roses">Days of Wine and Roses</option>
            <option value="cherokee">Cherokee</option>
            <option value="caravan">Caravan</option>
            <option value="nows_the_time">Now's The Time</option>
            <option value="tenor_madness">Tenor Madness</option>
        </select>
        <label for="keySelect">Key:</label>
        <select id="keySelect" aria-label="Select key">
            <!-- Options populated by JS -->
        </select>
        <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
        <button onclick="removeMeasure()" aria-label="Remove measure">Remove Last</button>
    </div>
    <div class="controls">
         <div class="checkbox-wrapper">
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.05" value="0.75" aria-label="Chord volume">
        </div>
    </div>
    <div id="measures">
        <!-- Measures will be populated dynamically -->
    </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <!-- FretFlow controls moved inside initializeFretFlow -->
    <div class="volume-control">
        <label for="fretboard-volume">FretFlow Volume:</label>
        <input type="range" id="fretboard-volume" min="0" max="1" step="0.05" value="0.3" aria-label="Fretboard volume">
    </div>
    <div class="fretboards-grid">
        <!-- 4 Fretboards populated by JS -->
    </div>
</div>
    <div id="loading-indicator" style="display: none;">Loading...</div>

    <script>

// --- Constants ---
const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const SAMPLE_NOTES = ['c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs', 'a', 'as', 'b']; // For audio file names
const OCTAVES = [2, 3, 4, 5]; // Available sample octaves
const FILE_FORMAT = 'wav'; // Assumed sample format

const SAMPLE_NOTE_MAP = { // Maps standard notation to sample file notation
    'C': 'c', 'C#': 'cs', 'Db': 'cs', 'D': 'd', 'D#': 'ds', 'Eb': 'ds', 'E': 'e',
    'F': 'f', 'F#': 'fs', 'Gb': 'fs', 'G': 'g', 'G#': 'gs', 'Ab': 'gs', 'A': 'a',
    'A#': 'as', 'Bb': 'as', 'B': 'b'
};

const SCALES = {
    major: { name: "Major (Ionian)", intervals: [0, 2, 4, 5, 7, 9, 11] },
    minor: { name: "Minor (Aeolian)", intervals: [0, 2, 3, 5, 7, 8, 10] },
    dorian: { name: "Dorian", intervals: [0, 2, 3, 5, 7, 9, 10] },
    phrygian: { name: "Phrygian", intervals: [0, 1, 3, 5, 7, 8, 10] },
    lydian: { name: "Lydian", intervals: [0, 2, 4, 6, 7, 9, 11] },
    mixolydian: { name: "Mixolydian", intervals: [0, 2, 4, 5, 7, 9, 10] },
    locrian: { name: "Locrian", intervals: [0, 1, 3, 5, 6, 8, 10] },
    harmonicMinor: { name: "Harmonic Minor", intervals: [0, 2, 3, 5, 7, 8, 11] },
    melodicMinor: { name: "Melodic Minor", intervals: [0, 2, 3, 5, 7, 9, 11] },
    bebopDominant: { name: "Bebop Dominant", intervals: [0, 2, 4, 5, 7, 9, 10, 11] },
    bebopMajor: { name: "Bebop Major", intervals: [0, 2, 4, 5, 7, 8, 9, 11] },
    // bebopDorian: { name: "Bebop Dorian", intervals: [0, 2, 3, 4, 5, 7, 9, 10] }, // Less common
    altered: { name: "Altered (Super Locrian)", intervals: [0, 1, 3, 4, 6, 8, 10] },
    lydianDominant: { name: "Lydian Dominant", intervals: [0, 2, 4, 6, 7, 9, 10] },
    diminishedWH: { name: "Diminished (W-H)", intervals: [0, 2, 3, 5, 6, 8, 9, 11] },
    diminishedHW: { name: "Diminished (H-W)", intervals: [0, 1, 3, 4, 6, 7, 9, 10] },
    wholeTone: { name: "Whole Tone", intervals: [0, 2, 4, 6, 8, 10] },
    pentatonicMajor: { name: "Pentatonic Major", intervals: [0, 2, 4, 7, 9] },
    pentatonicMinor: { name: "Pentatonic Minor", intervals: [0, 3, 5, 7, 10] },
    blues: { name: "Blues", intervals: [0, 3, 5, 6, 7, 10] },
    // majorBlues: { name: "Major Blues", intervals: [0, 2, 3, 4, 7, 9] }, // Less common standard name
    harmonicMajor: { name: "Harmonic Major", intervals: [0, 2, 4, 5, 7, 8, 11] },
    doubleHarmonic: { name: "Double Harmonic", intervals: [0, 1, 4, 5, 7, 8, 11] },
};

const TUNINGS = {
    standard: { name: 'Standard (EADGBE)', notes: ['E', 'A', 'D', 'G', 'B', 'E'] },
    dropD:    { name: 'Drop D (DADGBE)', notes: ['D', 'A', 'D', 'G', 'B', 'E'] },
    openG:    { name: 'Open G (DGDGBD)', notes: ['D', 'G', 'D', 'G', 'B', 'D'] },
    DADGAD:   { name: 'DADGAD', notes: ['D', 'A', 'D', 'G', 'A', 'D'] },
    openE:    { name: 'Open E (EBEG#BE)', notes: ['E', 'B', 'E', 'G#', 'B', 'E'] }
};

const CHORD_QUALITIES = { // Maps internal value to display name and intervals (Root=0)
    'maj': { name: 'Major', intervals: [0, 4, 7] },
    'min': { name: 'Minor', intervals: [0, 3, 7] },
    'maj7': { name: 'Maj7', intervals: [0, 4, 7, 11] },
    '7': { name: '7', intervals: [0, 4, 7, 10] }, // Dominant 7th
    'min7': { name: 'm7', intervals: [0, 3, 7, 10] },
    'm7b5': { name: 'm7b5', intervals: [0, 3, 6, 10] }, // Half-diminished
    'dim7': { name: 'dim7', intervals: [0, 3, 6, 9] }, // Fully diminished 7th
    'dim': { name: 'dim', intervals: [0, 3, 6] }, // Diminished triad
    'aug': { name: 'aug', intervals: [0, 4, 8] }, // Augmented triad
    '6': { name: '6', intervals: [0, 4, 7, 9] }, // Major 6th
    'm6': { name: 'm6', intervals: [0, 3, 7, 9] }, // Minor 6th
    'sus4': { name: 'sus4', intervals: [0, 5, 7] },
    'sus2': { name: 'sus2', intervals: [0, 2, 7] },
    '7sus4': { name: '7sus4', intervals: [0, 5, 7, 10] },
    'add9': { name: 'add9', intervals: [0, 4, 7, 14] }, // Major triad + 9th
    'madd9': { name: 'm(add9)', intervals: [0, 3, 7, 14] }, // Minor triad + 9th
    'maj9': { name: 'Maj9', intervals: [0, 4, 7, 11, 14] },
    '9': { name: '9', intervals: [0, 4, 7, 10, 14] }, // Dominant 9th
    'min9': { name: 'm9', intervals: [0, 3, 7, 10, 14] },
    'maj13': { name: 'Maj13', intervals: [0, 4, 7, 11, 14, 21] }, // Often implies 9th too
    '13': { name: '13', intervals: [0, 4, 7, 10, 14, 21] }, // Dominant 13th, implies 9th
    'min13': { name: 'm13', intervals: [0, 3, 7, 10, 14, 21] }, // Implies 9th
    '7b9': { name: '7b9', intervals: [0, 4, 7, 10, 13] },
    '7#9': { name: '7#9', intervals: [0, 4, 7, 10, 15] },
    '7b5': { name: '7b5', intervals: [0, 4, 6, 10] },
    '7#5': { name: '7#5', intervals: [0, 4, 8, 10] }, // Same as 7aug
    // '7alt': { name: '7alt', intervals: [0, 4, 10] } // Alt chords are complex, often imply b9, #9, b5, #5 - handle via scale choice
};

    const drumSoundSets = [
        { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" },
        { name: "Makaya", snare: "Snare2.wav", hihat: "HiHat2.wav", kick: "Kick2.wav" },
        { name: "PhillyJoe", kick: 'jazzkick.wav', snare: 'jazzsnare.wav', hihat: 'jazzhat.wav' }
    ];
    let currentDrumSetIndex = 0;
    let selectedRhythmPattern = 'downbeats';
    let twoChordsPerMeasureEnabled = false;
    let selectedVoicingType = 'standard';
    let currentPlaybackIntervalId = null; // Keep track of the interval

        const rhythmPatterns = {
    'downbeats': [1],
    'beats13': [1, 3],
    'charleston': [1, 3.5], // Beat 1 and the '&' of 3 - requires finer timing resolution
    // Add more patterns here
};
        
const progressions = {
    "I V7": { defaultKey: "C", progression: ["Imaj7", "V7"] }, // Using Maj7 for I
    "jazz_blues": { defaultKey: "Bb", progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "IIm7", "V7", "I7", "V7"] },
    "minor_blues": { defaultKey: "Cm", progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"] }, // Start in Cm
    "rhythm_changes": { defaultKey: "Bb", progression: ["I6", "vim7", "iim7", "V7", "I6", "vim7", "iim7", "V7", "I6", "IV7", "I6", "I6", "iim7", "V7", "I6", "V7"] }, // A section only for simplicity
    "2_5_1": { defaultKey: "C", progression: ["IIm7", "V7", "Imaj7", "Imaj7"] },
    "6_2_5_1": { defaultKey: "C", progression: ["VIm7", "IIm7", "V7", "Imaj7"] }, // Often 4 bars
    "minor_2_5_1": { defaultKey: "Cm", progression: ["IIm7b5", "V7", "Im7", "Im7"] }, // V7 often altered (b9)
    "dark_eyes": { defaultKey: "Dm", progression: ["V7", "V7", "Im7", "Im7", "V7", "V7", "VI6", "VI6", "IVm6", "IVm6", "Im7", "Im7", "V7", "V7", "Im7", "Im7"] },
    "ill_see_you_in_my_dreams": { defaultKey: "F", progression: ["IV6", "IV6", "IVm6", "IVm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "IIm7", "V7", "Imaj7"] },
    "rose_room": {defaultKey: "Ab", progression: ["II7", "V7", "I6", "I7", "IV6", "IVm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "IVm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"] },
    "black_orpheus": { defaultKey: "Am", progression: ["Im7", "IIm7b5", "V7", "Im7", "IVm7", "VII7", "bIIImaj7", "bVImaj7", "IIm7b5", "V7", "Im7", "IIm7b5", "V7", "Im7", "IVm7", "VII7"] }, // V7 often altered
    "all_the_things_you_are": { defaultKey: "Ab", progression: ["VIm7", "IIm7", "V7", "Imaj7", "IVmaj7", "VIIm7b5", "III7", "VIm7", "IIm7", "V7", "Imaj7", "IVmaj7", "bVIIm7", "bIII7", "bVImaj7", "bIImaj7", "V7sus4", "V7", "Imaj7"] }, // Simplified common changes
    "all_of_me": { defaultKey: "C", progression: ["Imaj7", "III7", "VI7", "IIm7", "E7", "Am7", "D7", "Dm7", "G7", "Cmaj7", "E7", "A7", "Dm7", "Fmaj7", "Fm6", "Cmaj7", "G7"] }, // Common changes
    "stella_by_starlight": { defaultKey: "Bb", progression: ["Em7b5", "A7", "Cm7", "F7", "Fm7", "Bb7", "Ebmaj7", "Ab7", "Dm7b5", "G7", "Cm7", "F7", "Bbmaj7"] }, // Simplified first part
    "autumn_leaves": { defaultKey: "Gm", progression: ["Cm7", "F7", "Bbmaj7", "Ebmaj7", "Am7b5", "D7", "Gm7", "Gm7"] }, // Key Gm
    "summertime": { defaultKey: "Am", progression: ["Am7", "E7", "Am7", "E7", "Am7", "Dm7", "Am7", "E7", "Dm7", "Am7", "E7", "Am7"] }, // Simplified
    "girl_from_ipanema": { defaultKey: "F", progression: ["Fmaj7", "G7", "Gm7", "C7", "Fmaj7", "Gb7", "Fmaj7"] }, // A section
    "coltrane_changes": { defaultKey: "C", progression: ["Cmaj7", "Eb7", "Abmaj7", "B7", "Emaj7", "G7", "Cmaj7"] }, // Basic cycle
    "bird_blues": { defaultKey: "F", progression: ["Fmaj7", "Em7b5", "A7", "Dm7", "G7", "Cm7", "F7", "Bbmaj7", "Bbm7", "Eb7", "Am7", "D7", "Gm7", "C7", "Fmaj7", "D7", "Gm7", "C7"] }, // Parker Blues
    "just_friends": { defaultKey: "G", progression: ["Gmaj7", "B7", "Em7", "A7", "Am7", "D7", "Gmaj7"] }, // Simplified A section
    "blue_bossa": { defaultKey: "Cm", progression: ["Cm7", "Fm7", "Bb7", "Ebmaj7", "Dm7b5", "G7", "Cm7"] }, // Simplified
    "on_green_dolphin_street": { defaultKey: "C", progression: ["Cmaj7", "Cm7", "F7", "Bbmaj7", "Ebmaj7", "Am7b5", "D7", "Gm7", "C7", "Fmaj7", "Fm7", "Bb7", "Ebmaj7", "Abmaj7", "Dm7", "G7", "Cmaj7"] }, // Common changes
    "solar": { defaultKey: "Cm", progression: ["Cm7", "Gm7", "C7", "Fmaj7", "Fm7", "Bb7", "Ebmaj7", "Am7b5", "D7", "Gm7", "C7", "Fmaj7"] }, // Miles Davis changes
    "misty": { defaultKey: "Eb", progression: ["Ebmaj7", "Bbm7", "Eb7", "Abmaj7", "Abm7", "Db7", "Ebmaj7", "Cm7", "Fm7", "Bb7", "Ebmaj7"] }, // A section
    "days_of_wine_and_roses": { defaultKey: "F", progression: ["Fmaj7", "Eb7", "Abmaj7", "Db7", "Gm7", "C7", "Fmaj7"] }, // Simplified A section
    "cherokee": { defaultKey: "Bb", progression: ["Bbmaj7", "Bbmaj7", "Cm7", "F7", "Bbmaj7", "Bbmaj7", "Gm7", "C7", "Fmaj7", "Fmaj7", "Gm7", "C7", "Fmaj7", "Fmaj7", "Cm7", "F7"] }, // A section
    "caravan": { defaultKey: "Fm", progression: ["Fm7", "C7", "Fm7", "C7", "Fm7", "Bbm7", "Eb7", "Abmaj7", "Dbmaj7", "Gm7b5", "C7", "Fm7"] }, // A section
    "nows_the_time": { defaultKey: "F", progression: ["F7", "F7", "F7", "F7", "Bb7", "Bb7", "F7", "F7", "C7", "Bb7", "F7", "F7"] }, // Basic Blues
    "tenor_madness": { defaultKey: "Bb", progression: ["Bb7", "Bb7", "Bb7", "Bb7", "Eb7", "Eb7", "Bb7", "Bb7", "F7", "Eb7", "Bb7", "Bb7"] } // Basic Blues
};

// --- State Management ---
const AppState = {
    isPlaying: false,
    currentBeat: 0, // 0-indexed beat within the measure
    currentMeasure: 0, // 0-indexed measure within the progression
    tempo: 120,
    audioInitialized: false,
    darkMode: 0, // 0: light, 1, 2, 3: dark modes
    listeners: [],
    intervalId: null,
    lastTap: null,
    chordsPlaybackEnabled: true,
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};

// --- UI Management ---
const UI = {
    elements: {}, // Populated in init
    init() {
        this.elements = {
            chordFretboard: document.getElementById('chord-fretboard'),
            measures: document.getElementById('measures'),
            tempoDisplay: document.getElementById('tempo-display'),
            startStopButton: document.getElementById('start-stop'),
            progressionSelect: document.getElementById('progression-select'),
            keySelect: document.getElementById('keySelect'),
            scaleDisplay: document.getElementById('scale-display'),
            chordTuning: document.getElementById('chord-tuning'),
            timeSignature: document.getElementById('time-signature'),
            soundType: document.getElementById('sound-type'),
            metronomeVolume: document.getElementById('metronome-volume'),
            tempo: document.getElementById('tempo'),
            tapTempo: document.getElementById('tap-tempo'),
            chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
            chordVolume: document.getElementById('chord-volume'),
            chordsEnabled: document.getElementById('chordsEnabled'),
            fretboardVolume: document.getElementById('fretboard-volume'),
            fretboardsGrid: document.querySelector('.fretboards-grid'),
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            accentIntensity: document.getElementById('accent-intensity'),
            loadingIndicator: document.getElementById('loading-indicator'),
            drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
            beatsContainer: document.querySelector('.beats-container'),
            fretflowSection: document.getElementById('fretflow-section') // Added for FretFlow controls
        };
        // Check if all elements were found
        Object.entries(this.elements).forEach(([key, el]) => {
            if (!el) console.warn(`[UI Init] Missing DOM element: ${key}`);
        });
        log("[UI Init] Elements cached.");
    }
};

// --- Utility Functions ---
function log(message) {
    console.log(`[Bebop Blueprint] ${message}`);
}

function updateLoadingStatus(message, show = true) {
    if (UI.elements.loadingIndicator) {
        UI.elements.loadingIndicator.textContent = message;
        UI.elements.loadingIndicator.style.display = show ? 'block' : 'none';
    }
}

function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

function getSampleFileName(note, octave) {
  // note should be in SAMPLE_NOTES format (e.g., 'cs')
  return `${note}${octave}.${FILE_FORMAT}`;
}

// --- Audio Management ---
const AudioContextManager = {
    context: null,
    soundBuffers: {}, // For metronome clicks, woodblocks, default drums
    pianoSampleBuffers: {}, // For piano chords/notes
    reverbNode: null,
    samplesLoaded: false,
    currentChordGain: null, // Gain node for the currently playing chord

    initialize: async function() {
        if (this.context && this.context.state === 'running') return this.context;

        try {
            if (!this.context) {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                log("AudioContext created.");
            }

            if (this.context.state === 'suspended') {
                await this.context.resume();
                log("AudioContext resumed.");
            }

            // Load sounds only if not already loaded or if context was recreated
            if (Object.keys(this.soundBuffers).length === 0) {
                 updateLoadingStatus("Loading sounds...");
                 await this.loadSounds(); // Metronome sounds
            }
             if (Object.keys(this.pianoSampleBuffers).length === 0) {
                 updateLoadingStatus("Loading piano samples...");
                 await this.loadPianoSamples(); // Piano sounds
            }
            if (!this.reverbNode) {
                 await this.setupReverb();
            }

            AppState.updateState({ audioInitialized: true });
            log("AudioContext initialized successfully.");
            return this.context;
        } catch (error) {
            console.error("AudioContext initialization failed:", error);
            alert("Could not initialize audio. Please ensure your browser supports the Web Audio API and try refreshing the page.");
            AppState.updateState({ audioInitialized: false });
            throw error; // Re-throw error to be caught by caller
        }
    },

    ensureAudioContext: async function() {
        // This is the primary function to call before any audio playback
        if (!AppState.audioInitialized || !this.context || this.context.state !== 'running') {
            log("Ensuring AudioContext is running...");
            await this.initialize();
        }
        return this.context;
    },

    loadSounds: async function() {
        const soundFiles = {
            'click': 'Click.wav',
            'hihat': 'HiHat.wav', // Default hihat
            'kick': 'Kick.wav',   // Default kick
            'snare': 'Snare.wav', // Default snare
            'woodblock': 'woodblock.wav'
        };
        // Also load drum set samples here for fallback
        for (const set of drumSoundSets) {
            soundFiles[`kick_${set.name}`] = set.kick;
            soundFiles[`snare_${set.name}`] = set.snare;
            soundFiles[`hihat_${set.name}`] = set.hihat;
        }

        let loadedCount = 0;
        const totalSounds = Object.keys(soundFiles).length;

        const loadPromises = Object.entries(soundFiles).map(async ([type, filename]) => {
            try {
                // Assume samples are in the same directory as the HTML
                const response = await fetch(`./${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${filename}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
                loadedCount++;
                updateLoadingStatus(`Loading sounds... (${loadedCount}/${totalSounds})`);
                // log(`Loaded ${type} sound from ${filename}`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                // Optionally create a fallback synthetic sound if loading fails
                if (type === 'click' || type === 'woodblock' || type === 'kick' || type === 'snare' || type === 'hihat') {
                    this.soundBuffers[type] = await this.createSynthSound(type);
                    log(`Using fallback synthetic sound for ${type}`);
                }
            }
        });

        await Promise.all(loadPromises);
        log(`Loaded ${loadedCount} of ${totalSounds} metronome/drum sounds.`);
        updateLoadingStatus("Drum sounds loaded.");
    },
/**
 * Gets the specific notes for a chord based on root, quality, and voicing rules.
 * TODO: Implement octave constraints and selected voicing types.
 * @param {string} rootNote - e.g., "C", "F#".
 * @param {string} quality - e.g., "maj7", "m7", "7", "m7b5".
 * @param {string} voicingType - 'standard', 'drop2', 'drop3', 'drop24'.
 * @param {number} targetOctaveStart - Preferred starting octave (e.g., 3).
 * @returns {string[]} Array of note names with octaves (e.g., ["C3", "E3", "G3", "B3"]).
 */
function getChordVoicing(rootNote, quality, voicingType = 'standard', targetOctaveStart = 3) {
    console.log(`Getting voicing for: ${rootNote}${quality}, Type: ${voicingType}`);
    const chordTones = getChordTones(rootNote, quality); // Use existing function
    if (!chordTones || chordTones.length === 0) {
        console.error(`Could not get tones for ${rootNote}${quality}`);
        return [];
    }

    // 1. Create a basic close voicing starting near the target octave
    let octave = targetOctaveStart;
    let previousNoteMidi = -1;
    let closeVoicing = chordTones.map((noteName, index) => {
        let currentNoteMidi = noteNameToMidi(noteName + octave);
        // If this note is lower than the previous, bump the octave
        if (index > 0 && currentNoteMidi < previousNoteMidi) {
            octave++;
            currentNoteMidi = noteNameToMidi(noteName + octave);
        }
        previousNoteMidi = currentNoteMidi;
        return noteName + octave;
    });

    // Ensure it's mostly within octaves 2 and 3 (MIDI ~36 to ~60) - Rough adjustment
    // Calculate average MIDI note
    let avgMidi = closeVoicing.reduce((sum, note) => sum + noteNameToMidi(note), 0) / closeVoicing.length;
    let targetAvgMidi = (noteNameToMidi("C2") + noteNameToMidi("C4")) / 2; // Middle of octave 2 & 3

    // Shift octave if needed (simple whole chord shift for now)
    let octaveShift = Math.round((targetAvgMidi - avgMidi) / 12);
    if (octaveShift !== 0) {
         console.log(`Shifting octave by ${octaveShift}`);
         closeVoicing = closeVoicing.map(note => {
             let midi = noteNameToMidi(note);
             return midiToNoteName(midi + octaveShift * 12);
         });
    }


    // 2. Apply Drop Voicings if requested (requires 4 notes)
    if (closeVoicing.length === 4 && (voicingType === 'drop2' || voicingType === 'drop3' || voicingType === 'drop24')) {
        return applyDropVoicing(closeVoicing, voicingType);
    } else if (closeVoicing.length !== 4 && voicingType !== 'standard') {
         console.warn(`Cannot apply drop voicing to ${closeVoicing.length}-note chord. Using standard voicing.`);
    }

    // Return the adjusted close voicing if no drop voicing applied
    console.log(`Final voicing for ${rootNote}${quality}: ${closeVoicing.join(', ')}`);
    return closeVoicing;
}

/**
 * Applies Drop 2, Drop 3, or Drop 2&4 voicing to a 4-note close voicing.
 * Assumes input notes are sorted lowest to highest.
 * @param {string[]} closeVoicing - Array of 4 note names with octaves, sorted low to high.
 * @param {string} type - 'drop2', 'drop3', or 'drop24'.
 * @returns {string[]} The rearranged notes for the drop voicing.
 */
function applyDropVoicing(closeVoicing, type) {
    if (closeVoicing.length !== 4) {
        console.error("Drop voicings require exactly 4 notes.");
        return closeVoicing; // Return original if not 4 notes
    }

    let notes = [...closeVoicing]; // Copy the array
    let noteToDrop;

    switch (type) {
        case 'drop2':
            // Drop the 2nd note from the top (index 2) down an octave
            noteToDrop = notes.splice(2, 1)[0]; // Remove 2nd note from top
            notes.unshift(adjustOctave(noteToDrop, -1)); // Add to bottom, down octave
            break;
        case 'drop3':
             // Drop the 3rd note from the top (index 1) down an octave
            noteToDrop = notes.splice(1, 1)[0]; // Remove 3rd note from top
            notes.unshift(adjustOctave(noteToDrop, -1)); // Add to bottom, down octave
            break;
        case 'drop24':
            // Drop the 2nd (index 2) and 4th (index 0) notes from the top down an octave
            let note2 = notes.splice(2, 1)[0]; // 2nd from top
            let note4 = notes.splice(0, 1)[0]; // 4th from top (original lowest)
            notes.unshift(adjustOctave(note2, -1)); // Add 2nd to bottom, down octave
            notes.unshift(adjustOctave(note4, -1)); // Add 4th to bottom, down octave
            break;
        default:
            console.warn(`Unknown drop voicing type: ${type}`);
            return closeVoicing; // Return original if type is unknown
    }

    // Sort the resulting notes by MIDI value to ensure correct order for playback/analysis
    notes.sort((a, b) => noteNameToMidi(a) - noteNameToMidi(b));
    console.log(`Applied ${type} voicing: ${notes.join(', ')}`);
    return notes;
}

/**
 * Adjusts the octave of a note name.
 * @param {string} noteName - e.g., "C#4".
 * @param {number} octaveChange - e.g., -1, 1.
 * @returns {string} Note name with adjusted octave.
 */
function adjustOctave(noteName, octaveChange) {
    const midi = noteNameToMidi(noteName);
    if (midi === -1) return noteName; // Invalid note
    return midiToNoteName(midi + octaveChange * 12);
}

// --- Helper function to get MIDI (can reuse existing if available) ---
// Ensure you have noteNameToMidi and midiToNoteName functions defined correctly.
// Example stubs if missing:
/*
function noteNameToMidi(noteName) {
    // Basic implementation - needs refinement for sharps/flats and octave parsing
    const noteMap = { 'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11 };
    const match = noteName.match(/([A-G][#b]?)(-?\d+)/);
    if (!match) return -1;
    const note = match[1];
    const octave = parseInt(match[2], 10);
    return noteMap[note] + (octave + 1) * 12; // MIDI C4 is 60
}

function midiToNoteName(midi) {
    // Basic implementation
    if (midi < 0 || midi > 127) return "Invalid";
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(midi / 12) - 1;
    const noteIndex = midi % 12;
    return noteNames[noteIndex] + octave;
}
*/

// --- Modify playChord ---
/**
 * Plays a chord using pre-loaded piano samples.
 * Accepts an array of specific note names with octaves.
 * @param {string[]} notes - Array of note names (e.g., ["C3", "E3", "G3", "Bb3"]).
 * @param {number} duration - Duration in seconds.
 * @param {number} [startTime] - Optional AudioContext time to schedule playback.
 */
async function playChord(notes, duration, startTime) {
    const now = AudioContextManager.context.currentTime;
    const playAt = startTime !== undefined ? startTime : now;
    const volume = parseFloat(document.getElementById('chord-volume').value);

    console.log(`Playing chord: ${notes.join(', ')} at time ${playAt.toFixed(2)} for ${duration}s`);

    if (!notes || notes.length === 0) {
        console.warn("playChord called with empty notes array.");
        return;
    }

    notes.forEach(noteName => {
        // Find the corresponding buffer
        const buffer = AudioContextManager.pianoSampleBuffers[noteName];
        if (buffer) {
            const source = AudioContextManager.context.createBufferSource();
            source.buffer = buffer;

            const gainNode = AudioContextManager.context.createGain();
            gainNode.gain.setValueAtTime(volume, playAt);
            // Fade out quickly at the end
            gainNode.gain.linearRampToValueAtTime(0.0001, playAt + duration);

            source.connect(gainNode);
            gainNode.connect(AudioContextManager.context.destination);
            source.start(playAt);
            // Optional: Stop the source slightly after the fade ends to release resources
            source.stop(playAt + duration + 0.1);
        } else {
            console.warn(`Piano sample buffer not found for note: ${noteName}`);
        }
    });
}

// --- Modify getChordTones (if needed) ---
// Ensure getChordTones returns an array of note names *without* octaves,
// e.g., ["C", "E", "G", "B"] for Cmaj7. The getChordVoicing function adds the octaves.
// Example structure:
/*
function getChordTones(root, quality) {
    const rootIndex = noteNames.indexOf(standardizeNoteName(root));
    if (rootIndex === -1) return null;
    const intervals = chordFormulas[quality];
    if (!intervals) return null;
    return intervals.map(interval => noteNames[(rootIndex + interval) % 12]);
}
*/
    createSynthSound: async function(type) {
        // Simple synth sounds as fallback
        const sampleRate = this.context.sampleRate;
        const duration = type === 'hihat' ? 0.05 : 0.15;
        const buffer = this.context.createBuffer(1, Math.floor(sampleRate * duration), sampleRate);
        const data = buffer.getChannelData(0);
        let freq = 1000; // Default click/hihat

        if (type === 'kick') freq = 100;
        else if (type === 'snare') freq = 300;
        else if (type === 'woodblock') freq = 1500;

        for (let i = 0; i < data.length; i++) {
            const t = i / sampleRate;
            let envelope = Math.exp(-t * (type === 'hihat' ? 50 : 25));
            let noise = (type === 'snare' || type === 'hihat') ? (Math.random() * 2 - 1) * 0.5 : 0;
            data[i] = (Math.sin(2 * Math.PI * freq * t * (1 - t * 2)) + noise) * envelope; // Pitch drop for kick/snare
        }
        return buffer;
    },

    loadPianoSamples: async function() {
        this.pianoSampleBuffers = {}; // Reset
        let loadedCount = 0;
        const totalSamples = SAMPLE_NOTES.length * OCTAVES.length;

        const loadPromises = [];
        for (const note of SAMPLE_NOTES) {
            for (const octave of OCTAVES) {
                const fileName = getSampleFileName(note, octave); // e.g., 'cs4.wav'
                const key = `${note}${octave}`; // e.g., 'cs4'

                const promise = (async () => {
                    try {
                        // Assume samples are in the same directory as the HTML
                        const response = await fetch(`./${fileName}`);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${fileName}`);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
                        this.pianoSampleBuffers[key] = audioBuffer;
                        loadedCount++;
                        updateLoadingStatus(`Loading piano samples... (${loadedCount}/${totalSamples})`);
                        // log(`Loaded piano sample: ${fileName}`);
                    } catch (e) {
                        console.error(`Failed to load sample: ${fileName}`, e);
                        // No fallback for piano samples currently
                    }
                })();
                loadPromises.push(promise);
            }
        }
        await Promise.all(loadPromises);
        this.samplesLoaded = loadedCount > 0;
        log(`Loaded ${loadedCount} of ${totalSamples} piano samples.`);
        if (!this.samplesLoaded) {
             console.warn("No piano samples loaded. Chord playback will be silent.");
             alert("Warning: Could not load piano samples. Chord playback will be silent. Ensure sample files (e.g., c3.wav, cs3.wav...) are present.");
        }
        updateLoadingStatus("Piano samples loaded.");
    },

    setupReverb: async function() {
        // Simple algorithmic reverb as fallback if impulse response fails
        try {
            this.reverbNode = this.context.createConvolver();
            // Attempt to load an impulse response if available (optional)
            // const response = await fetch('./impulse-response.wav');
            // if (!response.ok) throw new Error('Failed to load impulse response');
            // const arrayBuffer = await response.arrayBuffer();
            // this.reverbNode.buffer = await this.context.decodeAudioData(arrayBuffer);

            // If no impulse response, create a simple synthetic one
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 1.5; // 1.5 seconds reverb time
            const impulse = this.context.createBuffer(2, length, sampleRate);
            const impulseL = impulse.getChannelData(0);
            const impulseR = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
            }
            this.reverbNode.buffer = impulse;
            this.reverbNode.connect(this.context.destination);
            log("Reverb node set up.");
        } catch (error) {
            console.error("Failed to set up reverb:", error);
            this.reverbNode = null; // Disable reverb if setup fails
        }
    }
};

// --- Music Theory Utilities ---

function standardizeNoteName(note) {
    if (!note || typeof note !== 'string') return 'C'; // Default to C if invalid
    note = note.trim();
    // Handle flats first, converting to sharps for internal consistency
    const flatToSharp = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
    note = flatToSharp[note.charAt(0).toUpperCase() + note.slice(1)] || note;
    // Ensure format like 'C#' or 'A'
    const match = note.match(/^([A-G])(#)?$/i);
    if (!match) return 'C'; // Default if format is wrong
    return match[1].toUpperCase() + (match[2] || '');
}

function getNoteIndex(note) {
    return NOTES.indexOf(standardizeNoteName(note));
}

function getScaleNotes(root, scaleKey) {
    const scale = SCALES[scaleKey];
    if (!root || !scale || !scale.intervals) return [];
    const rootIndex = getNoteIndex(root);
    if (rootIndex === -1) return [];
    return scale.intervals.map(interval => NOTES[(rootIndex + interval) % 12]);
}

function getNoteAtFret(stringNote, fretNumber) {
    const startIndex = getNoteIndex(stringNote);
    if (startIndex === -1) return '?';
    return NOTES[(startIndex + fretNumber) % 12];
}

function isMinorKeyName(key) {
    return key && typeof key === 'string' && key.toLowerCase().endsWith('m');
}

function getQualityValue(qualityString) {
    // Find the closest match in CHORD_QUALITIES keys
    const lowerQuality = qualityString.toLowerCase().replace('ø', 'm7b5').replace('°', 'dim').replace('Δ', 'maj7');
    for (const key in CHORD_QUALITIES) {
        if (lowerQuality === key || lowerQuality === CHORD_QUALITIES[key].name.toLowerCase()) {
            return key;
        }
    }
    // More lenient matching
    if (lowerQuality.includes('maj')) return 'maj7';
    if (lowerQuality.includes('m') && !lowerQuality.includes('dim')) return 'min7';
    if (lowerQuality.includes('dom') || lowerQuality.match(/^7$|\d/)) return '7'; // Basic dominant
    if (lowerQuality.includes('dim') || lowerQuality.includes('m7b5')) return 'm7b5';

    return 'maj'; // Default fallback
}

function suggestScaleForQuality(qualityKey) {
    // Simple suggestions based on common practice
    if (!qualityKey) return 'major';
    if (qualityKey.includes('maj') || qualityKey === '6') return 'major'; // or Lydian
    if (qualityKey === '7' || qualityKey === '9' || qualityKey === '13' || qualityKey.includes('sus')) return 'mixolydian'; // or Lydian Dominant, Bebop Dominant
    if (qualityKey.includes('min') && !qualityKey.includes('b5') && qualityKey !== 'm6') return 'dorian'; // or Aeolian, Phrygian
    if (qualityKey === 'm7b5') return 'locrian'; // or Locrian #2
    if (qualityKey === 'dim7') return 'diminishedWH'; // Whole-Half Diminished
    if (qualityKey === 'm6') return 'melodicMinor'; // Often used over m6
    if (qualityKey.includes('alt') || qualityKey.match(/7[b#]\d/)) return 'altered'; // Altered scale for altered dominants

    return 'major'; // Default fallback
}

// --- Chord/Progression Parsing ---

// *** NEW Function: Translates Roman Numeral + Key -> Chord Symbol ***
function getChordFromFunction(romanNumeral, key) {
    if (!romanNumeral || !key) return null;

    const isMinor = isMinorKeyName(key);
    const rootKey = standardizeNoteName(key.replace(/m$/i, ''));
    const rootKeyIndex = NOTES.indexOf(rootKey);
    if (rootKeyIndex === -1) return null; // Invalid key

    // Determine scale intervals based on key quality
    const scaleIntervals = isMinor ? SCALES.minor.intervals : SCALES.major.intervals;

    // --- Parse Roman Numeral ---
    let roman = romanNumeral.trim();
    let prefix = ''; // For 'b' or '#' prefixes
    let qualitySuffix = ''; // For '7', 'maj7', 'm7', 'dim7', 'm7b5', etc.
    let degreeNum = -1;

    // 1. Extract prefix (b/#)
    if (roman.startsWith('b')) {
        prefix = 'b';
        roman = roman.substring(1);
    } else if (roman.startsWith('#')) {
        prefix = '#';
        roman = roman.substring(1);
    }

    // 2. Extract quality suffix
    // Match common suffixes greedily from the end
    const qualityRegex = /(maj7|m7b5|dim7|sus4|sus2|add9|madd9|maj9|min9|maj13|min13|7b9|7#9|7b5|7#5|alt|m7|dim|aug|m6|7|6|M7|M|m|ø|°)$/i;
    const qualityMatch = roman.match(qualityRegex);
    if (qualityMatch) {
        qualitySuffix = qualityMatch[0];
        roman = roman.substring(0, roman.length - qualitySuffix.length); // Remove suffix from roman part
    }

    // 3. Determine degree number (I to VII)
    const romanMap = { 'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7 };
    const upperRoman = roman.toUpperCase();
    if (romanMap[upperRoman] !== undefined) {
        degreeNum = romanMap[upperRoman];
    } else {
        console.warn(`Could not parse Roman numeral degree: ${roman}`);
        return null; // Invalid degree
    }

    // 4. Determine chord root note
    let degreeIndex = degreeNum - 1;
    let scaleNoteIndex = (rootKeyIndex + scaleIntervals[degreeIndex]) % 12;

    // Apply prefix alteration
    if (prefix === 'b') {
        scaleNoteIndex = (scaleNoteIndex - 1 + 12) % 12;
    } else if (prefix === '#') {
        scaleNoteIndex = (scaleNoteIndex + 1) % 12;
    }
    const chordRoot = NOTES[scaleNoteIndex];

    // 5. Determine chord quality (if not explicitly given)
    if (!qualitySuffix) {
        // Infer quality based on scale degree and case (Major key default)
        const thirdInterval = (scaleIntervals[(degreeIndex + 2) % 7] - scaleIntervals[degreeIndex] + 12) % 12;
        const isMajorTriad = thirdInterval === 4;
        const isDiminished = (scaleIntervals[(degreeIndex + 4) % 7] - scaleIntervals[degreeIndex] + 12) % 12 === 6;

        if (isMinor) { // Minor key defaults
             if (degreeNum === 1 || degreeNum === 4) qualitySuffix = 'm'; // i, iv
             else if (degreeNum === 3 || degreeNum === 6 || degreeNum === 7) qualitySuffix = 'maj'; // III, VI, VII
             else if (degreeNum === 2) qualitySuffix = 'dim'; // ii°
             else if (degreeNum === 5) qualitySuffix = 'm'; // v (natural minor), often becomes V7
             else qualitySuffix = 'm';
        } else { // Major key defaults
            if (degreeNum === 1 || degreeNum === 4 || degreeNum === 5) qualitySuffix = 'maj'; // I, IV, V
            else if (degreeNum === 2 || degreeNum === 3 || degreeNum === 6) qualitySuffix = 'm'; // ii, iii, vi
            else if (degreeNum === 7) qualitySuffix = 'dim'; // vii°
            else qualitySuffix = 'maj';
        }
         // If original roman was lowercase, force minor (unless diminished)
         if (roman === roman.toLowerCase() && qualitySuffix !== 'dim') {
             qualitySuffix = 'm';
         }
         // If original roman was uppercase, force major (unless diminished)
         if (roman === roman.toUpperCase() && qualitySuffix !== 'dim') {
             qualitySuffix = 'maj';
         }
         // Default to 7th chords for common jazz functions if no quality specified
         if (degreeNum === 5 && !qualitySuffix.match(/\d/)) qualitySuffix = '7'; // V7
         else if (degreeNum === 2 && !qualitySuffix.match(/\d/)) qualitySuffix = 'm7'; // iim7
         else if (degreeNum === 1 && !qualitySuffix.match(/\d/)) qualitySuffix = 'maj7'; // Imaj7
    }

    // 6. Format the final chord symbol
    let finalQuality = qualitySuffix;
    // Standardize common variations
    finalQuality = finalQuality.replace(/^maj$/i, ''); // Remove 'maj' for simple major triad
    finalQuality = finalQuality.replace(/^m$/i, 'm'); // Ensure lowercase 'm' for minor
    finalQuality = finalQuality.replace(/^M$/i, '');
    finalQuality = finalQuality.replace(/^M7$/i, 'maj7');
    finalQuality = finalQuality.replace(/^min7$/i, 'm7');
    finalQuality = finalQuality.replace(/^dom7$/i, '7');
    finalQuality = finalQuality.replace('ø', 'm7b5');
    finalQuality = finalQuality.replace('°', 'dim');

    return chordRoot + finalQuality;
}

function formatChordDisplay(chordSymbol) {
    if (!chordSymbol) return "?";
    return chordSymbol
        .replace('maj7', 'Δ7')
        .replace('min7', 'm7')
        .replace('m7b5', 'ø7')
        .replace('dim7', '°7')
        .replace('min', 'm') // Keep simple minor as 'm'
        .replace('maj', ''); // Remove 'maj' for simple major triad
}

// --- DOM Utilities ---
function createKeyOptions(selectedKey = 'C') {
    const standardizedSelected = standardizeNoteName(selectedKey);
    return NOTES.map(note =>
        `<option value="${note}"${note === standardizedSelected ? ' selected' : ''}>${note}</option>`
    ).join('');
}
function createAllKeyOptions(selectedKey = 'C') { // Includes minor keys
    const keys = [];
    NOTES.forEach(n => keys.push(n));
    NOTES.forEach(n => keys.push(`${n}m`));
    const standardizedSelected = selectedKey; // Assume selectedKey is already like 'C' or 'Cm'
    return keys.map(key =>
        `<option value="${key}"${key === standardizedSelected ? ' selected' : ''}>${key}</option>`
    ).join('');
}

function createQualityOptions(selectedQuality = 'maj7') {
    const internalSelected = getQualityValue(selectedQuality); // Ensure we match internal key
    return Object.entries(CHORD_QUALITIES).map(([key, value]) =>
        `<option value="${key}"${key === internalSelected ? ' selected' : ''}>${value.name}</option>`
    ).join('');
}

function createScaleOptions(selectedScale = 'major') {
    return Object.entries(SCALES).map(([key, value]) =>
        `<option value="${key}"${key === selectedScale ? ' selected' : ''}>${value.name}</option>`
    ).join('');
}

// --- Playback Functions ---

async function playNote(noteNameWithOctave, volume = 1.0, durationMs = 500) {
    const context = await AudioContextManager.ensureAudioContext();
    if (!context || !AudioContextManager.samplesLoaded || volume <= 0) return;

    // Parse note name and octave (e.g., "C#4")
    const match = noteNameWithOctave.match(/^([A-G][#b]?)([0-9])$/);
    if (!match) {
        console.warn(`Invalid note format for playback: ${noteNameWithOctave}`);
        return;
    }
    let note = standardizeNoteName(match[1]); // e.g., "C#"
    const octave = parseInt(match[2]);

    // Map to sample format (e.g., "cs")
    const sampleNote = SAMPLE_NOTE_MAP[note];
    if (!sampleNote) {
        console.warn(`Cannot map note to sample: ${note}`);
        return;
    }

    const sampleKey = `${sampleNote}${octave}`; // e.g., "cs4"
    const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

    if (!buffer) {
        // Try finding the note in an adjacent octave if available
        const lowerOctaveKey = `${sampleNote}${octave - 1}`;
        const higherOctaveKey = `${sampleNote}${octave + 1}`;
        let fallbackBuffer = null;
        let semitoneShift = 0;

        if (AudioContextManager.pianoSampleBuffers[lowerOctaveKey]) {
            fallbackBuffer = AudioContextManager.pianoSampleBuffers[lowerOctaveKey];
            semitoneShift = 12;
        } else if (AudioContextManager.pianoSampleBuffers[higherOctaveKey]) {
            fallbackBuffer = AudioContextManager.pianoSampleBuffers[higherOctaveKey];
            semitoneShift = -12;
        }

        if (fallbackBuffer) {
             log(`Using sample ${fallbackBuffer === lowerOctaveKey ? lowerOctaveKey : higherOctaveKey} for ${sampleKey} with shift ${semitoneShift}`);
             buffer = fallbackBuffer; // Use the fallback buffer
        } else {
            console.warn(`No sample or adjacent octave found for ${sampleKey}`);
            return; // No sample available
        }
    }

    try {
        const source = context.createBufferSource();
        source.buffer = buffer;

        // Apply pitch shift if using adjacent octave sample
        if (semitoneShift !== 0) {
            source.playbackRate.value = Math.pow(2, semitoneShift / 12);
        }

        const gainNode = context.createGain();
        // Apply a slight attack/release envelope to avoid clicks
        const now = context.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + 0.01); // Quick attack
        gainNode.gain.setValueAtTime(volume, now + (durationMs / 1000) - 0.05); // Hold
        gainNode.gain.linearRampToValueAtTime(0, now + (durationMs / 1000)); // Quick release

        source.connect(gainNode);

        // Optional: Add reverb
        if (AudioContextManager.reverbNode) {
            const reverbGain = context.createGain();
            reverbGain.gain.value = 0.15; // Adjust reverb amount
            gainNode.connect(reverbGain);
            reverbGain.connect(AudioContextManager.reverbNode);
        } else {
            gainNode.connect(context.destination); // Connect directly if no reverb
        }

        source.start(now);
        // No need for setTimeout to stop, envelope handles duration
    } catch (error) {
        console.error(`Error playing note ${noteNameWithOctave}:`, error);
    }
}

async function playChord(rootNote, qualityKey, startTime, durationSec) {
    const context = await AudioContextManager.ensureAudioContext();
     if (!context || !AudioContextManager.samplesLoaded || !AppState.chordsPlaybackEnabled) return;

    const qualityInfo = CHORD_QUALITIES[qualityKey];
    if (!qualityInfo || !qualityInfo.intervals) {
        console.warn(`Unknown chord quality: ${qualityKey}`);
        return;
    }

    const rootIndex = getNoteIndex(rootNote);
    if (rootIndex === -1) return;

    const chordNotes = qualityInfo.intervals.map(interval => NOTES[(rootIndex + interval) % 12]);

    // Simple voicing logic (adjust octaves)
    const baseOctave = 3;
    const voicedNotes = chordNotes.map((note, index) => {
        let octave = baseOctave;
        // Basic logic: push higher notes up an octave if they are "lower" than the root
        if (index > 0 && NOTES.indexOf(note) < rootIndex) {
            octave++;
        }
        // Push 7ths/9ths/13ths up potentially
        if (qualityInfo.intervals[index] >= 10) octave++;
        // Avoid excessively high notes
        if (octave > 5) octave = 5;
        return `${note}${octave}`;
    });

    const chordVolume = parseFloat(UI.elements.chordVolume.value);
    if (chordVolume <= 0) return;

    // Fade out previous chord if still playing
    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.cancelScheduledValues(context.currentTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.05);
    }

    // Create a master gain for this chord instance
    const masterGain = context.createGain();
    masterGain.connect(context.destination); // Connect to main output
    // Optional: Connect through reverb
    if (AudioContextManager.reverbNode) {
         const reverbGain = context.createGain();
         reverbGain.gain.value = 0.2; // Chord reverb amount
         masterGain.connect(reverbGain);
         reverbGain.connect(AudioContextManager.reverbNode);
    }

    // Apply envelope to the master gain
    const now = context.currentTime;
    const attackTime = 0.02;
    const releaseTime = 0.1;
    masterGain.gain.setValueAtTime(0, now);
    masterGain.gain.linearRampToValueAtTime(chordVolume, now + attackTime);
    // Schedule fade out at the end of the duration
    masterGain.gain.setValueAtTime(chordVolume, now + durationSec - releaseTime);
    masterGain.gain.linearRampToValueAtTime(0, now + durationSec);

    AudioContextManager.currentChordGain = masterGain; // Store reference to fade out later

    // Play each note through the master gain
    voicedNotes.forEach(noteOctave => {
        const sampleNote = SAMPLE_NOTE_MAP[noteOctave.slice(0, -1)];
        const octave = parseInt(noteOctave.slice(-1));
        const sampleKey = `${sampleNote}${octave}`;
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

        if (buffer) {
            try {
                const source = context.createBufferSource();
                source.buffer = buffer;
                source.connect(masterGain); // Connect note to chord's master gain
                source.start(now);
                // Stop source slightly after master gain fades out
                source.stop(now + durationSec + 0.1);
            } catch (e) {
                console.error(`Error playing chord note ${noteOctave}:`, e);
            }
        } else {
             console.warn(`Sample not found for chord note: ${noteOctave}`);
        }
    });
    // log(`Playing chord: ${rootNote}${qualityInfo.name} (${voicedNotes.join(', ')})`);
}


async function playMetronomeSound(beatVolume, beatIndex, timeSignature) {
    const context = await AudioContextManager.ensureAudioContext();
    if (!context || beatVolume <= 0) return;

    const metronomeVolume = parseFloat(UI.elements.metronomeVolume.value);
    const combinedVolume = beatVolume * metronomeVolume;
    if (combinedVolume <= 0) return;

    const soundType = UI.elements.soundType.value;
    const beatElement = UI.elements.beatsContainer.querySelector(`.beat[data-beat="${beatIndex}"]`);
    if (!beatElement) return;

    const soundsToPlay = beatElement.dataset.sound.split(','); // e.g., ['kick', 'hihat'] or ['click']
    const isAccent = parseFloat(beatElement.dataset.baseVolume) >= 1.0; // Check if it's marked as accented
    const accentBoost = parseFloat(UI.elements.accentIntensity.value);

    let finalVolume = combinedVolume;
    if (isAccent) {
        finalVolume = Math.min(combinedVolume * accentBoost, 1.0); // Apply boost, cap at 1
    }

    for (let soundKey of soundsToPlay) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;

        let buffer;
        let bufferType = soundKey; // 'kick', 'snare', 'hihat', 'click', 'woodblock'

        if (soundType === 'drums') {
            const currentSet = drumSoundSets[currentDrumSetIndex];
            // Construct buffer key like 'kick_Makaya' or 'snare_Drums'
            const drumBufferKey = `${soundKey}_${currentSet.name}`;
            buffer = AudioContextManager.soundBuffers[drumBufferKey];
            // Fallback to default drum sound if set-specific sound failed to load
            if (!buffer) {
                buffer = AudioContextManager.soundBuffers[soundKey];
                bufferType = soundKey; // Use the base type for synth fallback
            }
        } else {
            // Use click or woodblock
            buffer = AudioContextManager.soundBuffers[soundType];
            bufferType = soundType;
        }

        // If still no buffer, try creating synth fallback
        if (!buffer) {
            buffer = await AudioContextManager.createSynthSound(bufferType);
        }
        if (!buffer) continue; // Skip if no sound available

        try {
            const source = context.createBufferSource();
            source.buffer = buffer;

            const gainNode = context.createGain();
            // Adjust volume slightly based on drum type for better mix
            let volumeAdjustment = 1.0;
            if (soundType === 'drums') {
                if (soundKey === 'hihat' && soundsToPlay.length > 1) volumeAdjustment = 0.6; // Quieter hat in complex beats
                else if (soundKey === 'kick') volumeAdjustment = 1.1;
                else if (soundKey === 'snare') volumeAdjustment = 1.0;
            }
            gainNode.gain.value = Math.min(finalVolume * volumeAdjustment, 1.0); // Apply adjustment, cap at 1

            source.connect(gainNode);

            // Optional: Add reverb to drums
            if (soundType === 'drums' && AudioContextManager.reverbNode) {
                const reverbGain = context.createGain();
                reverbGain.gain.value = 0.1; // Subtle reverb
                gainNode.connect(reverbGain);
                reverbGain.connect(AudioContextManager.reverbNode);
            } else {
                 gainNode.connect(context.destination);
            }

            source.start(context.currentTime);
        } catch (error) {
            console.error(`Error playing metronome sound (${soundKey}):`, error);
        }
    }
}

// --- Fretboard Functions ---

function createFretboard(container, tuningNotes) {
    if (!(container instanceof HTMLElement)) {
        console.error('Invalid container element for fretboard');
        return;
    }
     if (!Array.isArray(tuningNotes) || tuningNotes.length !== 6) {
        console.error('Invalid tuning notes provided for fretboard');
        return;
    }
    container.innerHTML = ''; // Clear previous content
    const numFrets = 12;

    // Create fret lines and fret numbers
    for (let i = 0; i <= numFrets; i++) {
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`;
        container.appendChild(fretLine);

        if (i > 0) { // Add fret numbers for frets 1-12
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            // Position number between frets
            fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
            container.appendChild(fretNumber);
        }
    }

    // Create string lines
    const numStrings = tuningNotes.length;
    for (let i = 0; i < numStrings; i++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        stringLine.style.top = `${(i / (numStrings - 1)) * 100}%`;
        container.appendChild(stringLine);
    }

    // Add fret markers (dots)
    const markerPositions = [3, 5, 7, 9, 12]; // Frets with markers
    markerPositions.forEach(position => {
        if (position > numFrets) return; // Don't draw markers beyond fretboard length
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((position - 0.5) / numFrets) * 100}%`;

        if (position === 12) { // Double markers at the 12th fret
            const topMarker = marker.cloneNode(true);
            topMarker.style.top = '25%'; // Adjust vertical position for double dots
            container.appendChild(topMarker);
            const bottomMarker = marker.cloneNode(true);
            bottomMarker.style.top = '75%';
            container.appendChild(bottomMarker);
        } else { // Single marker
            marker.style.top = '50%';
            container.appendChild(marker);
        }
    });
    // log(`Fretboard structure created for tuning: ${tuningNotes.join(',')}`);
}

function updateFretboardNotes(container, rootNote, scaleKey, tuningNotes) {
    if (!(container instanceof HTMLElement)) return;
    if (!rootNote || !scaleKey || !tuningNotes) return;

    const scaleInfo = SCALES[scaleKey];
    if (!scaleInfo) { console.warn(`Invalid scale key: ${scaleKey}`); return; }

    // Clear existing notes
    container.querySelectorAll('.note').forEach(note => note.remove());

    // Update scale display text if applicable (for the main chord fretboard)
    if (container.id === 'chord-fretboard') {
        const measures = UI.elements.measures.children;
        if (measures.length > 0 && AppState.currentMeasure < measures.length) {
            const currentMeasureElement = measures[AppState.currentMeasure];
            const chordRoot = currentMeasureElement.querySelector('.root-note')?.value;
            const qualityKey = currentMeasureElement.querySelector('.chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.second-key')?.value; // This is the root for the scale display
            const scaleTypeKey = currentMeasureElement.querySelector('.scale-select')?.value; // This is the scale type

            if (chordRoot && qualityKey && scaleRoot && scaleTypeKey) {
                const qualityDisplay = CHORD_QUALITIES[qualityKey]?.name || qualityKey;
                const scaleDisplay = SCALES[scaleTypeKey]?.name || scaleTypeKey;
                UI.elements.scaleDisplay.textContent = `${scaleRoot} ${scaleDisplay} over ${chordRoot}${qualityDisplay}`;
            } else {
                 UI.elements.scaleDisplay.textContent = `${rootNote} ${scaleInfo.name}`; // Fallback display
            }
        } else {
             UI.elements.scaleDisplay.textContent = `${rootNote} ${scaleInfo.name}`; // Fallback display
        }
    } else {
        // For FretFlow fretboards, update their individual displays
        const scaleDisplayElement = container.previousElementSibling.previousElementSibling; // Find the .scale-display in FretFlow structure
        if (scaleDisplayElement && scaleDisplayElement.classList.contains('scale-display')) {
             scaleDisplayElement.textContent = `${rootNote} ${scaleInfo.name}`;
        }
    }


    const scaleNotesInKey = getScaleNotes(rootNote, scaleKey);
    const standardizedRoot = standardizeNoteName(rootNote);
    const numFrets = 12;
    const numStrings = tuningNotes.length;

    for (let string = 0; string < numStrings; string++) {
        const openStringNote = standardizeNoteName(tuningNotes[string]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);
        if (openStringNoteIndex === -1) continue; // Skip if tuning note is invalid

        for (let fret = 0; fret <= numFrets; fret++) {
            const noteIndex = (openStringNoteIndex + fret) % 12;
            const currentNote = NOTES[noteIndex];

            if (scaleNotesInKey.includes(currentNote)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNote; // Display note name (e.g., C#)

                // Calculate position
                const fretOffset = fret === 0 ? 2 : ((fret - 0.5) / numFrets) * 100; // Adjust open string position slightly
                noteElement.style.left = `${fretOffset}%`;
                noteElement.style.top = `${(string / (numStrings - 1)) * 100}%`;

                // Determine octave (simple estimation based on standard tuning)
                // E2 A2 D3 G3 B3 E4
                const baseOctaves = [2, 2, 3, 3, 3, 4]; // Approximate base octave for each string
                let octave = baseOctaves[string] + Math.floor((openStringNoteIndex + fret) / 12);
                if (octave < 2) octave = 2; // Ensure minimum octave
                if (octave > 5) octave = 5; // Cap at max octave
                const noteWithOctave = `${currentNote}${octave}`;
                noteElement.dataset.note = noteWithOctave; // Store full note name for playback

                // Style based on scale degree
                const degreeIndex = scaleInfo.intervals.findIndex(interval => (getNoteIndex(rootNote) + interval) % 12 === noteIndex);
                if (currentNote === standardizedRoot) {
                    noteElement.classList.add('root');
                } else if ([2, 4, 6].includes(degreeIndex)) { // Example: color 3rd, 5th, 7th differently
                    noteElement.classList.add('degree-2-4-6'); // Use specific class for styling
                }

                // Add click listener (use function defined elsewhere)
                attachSingleNoteClickHandler(noteElement, container.id);

                container.appendChild(noteElement);
            }
        }
    }
    // log(`Fretboard notes updated for ${rootNote} ${scaleKey}`);
}

function attachSingleNoteClickHandler(noteElement, fretboardId) {
     noteElement.addEventListener('click', async (e) => {
        e.stopPropagation(); // Prevent clicks bubbling up if needed
        const noteToPlay = noteElement.dataset.note; // e.g., "C#4"
        if (noteToPlay) {
            try {
                // Determine volume based on which fretboard was clicked
                let volume = 0.5; // Default volume
                if (fretboardId === 'chord-fretboard') {
                    volume = parseFloat(UI.elements.chordFretboardVolume.value);
                } else if (fretboardId.startsWith('fretflow-fretboard')) {
                    volume = parseFloat(UI.elements.fretboardVolume.value);
                }
                await playNote(noteToPlay, volume, 500); // Play for 500ms

                // Visual feedback
                noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                setTimeout(() => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 150);
            } catch (error) {
                console.error('Error playing note from fretboard:', error);
            }
        }
    });
     // Add hover effect listeners
    noteElement.addEventListener('mouseenter', () => {
        noteElement.style.transform = 'translate(-50%, -50%) scale(1.15)';
    });
    noteElement.addEventListener('mouseleave', () => {
        noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
    });
}


// --- Metronome Beat Functions ---

function createBeats() {
    const container = UI.elements.beatsContainer;
    if (!container) return;
    container.innerHTML = ''; // Clear existing beats

    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value;

    // Determine beats per measure based on time signature
    let beatsPerMeasure;
    let subdivision = 1; // 1 = quarter notes, 2 = eighth notes
    if ([2, 3, 4].includes(timeSignature)) {
        beatsPerMeasure = timeSignature;
        if (timeSignature === 4) subdivision = 2; // Use 8th notes for 4/4
    } else if (timeSignature === 6 || timeSignature === 12) {
        beatsPerMeasure = timeSignature / 3; // Compound meter (e.g., 6/8 has 2 main beats)
        subdivision = 3; // Triplets
    } else if (timeSignature === 7) {
        beatsPerMeasure = timeSignature; // Treat 7/8 as 7 beats for simplicity here
        subdivision = 1;
    } else {
        beatsPerMeasure = timeSignature; // Default
        subdivision = 1;
    }

    const totalDivisions = beatsPerMeasure * subdivision;

    // Define strong beats (adjust based on common feel)
    let strongBeats = [0]; // First beat is always strong
    if (timeSignature === 4) strongBeats = [0, beatsPerMeasure]; // 1 and 3 (using 8th note indices 0 and 4)
    if (timeSignature === 3) strongBeats = [0];
    if (timeSignature === 6) strongBeats = [0, 3]; // 1 and 4 (triplet indices)
    if (timeSignature === 12) strongBeats = [0, 6]; // 1 and 7 (triplet indices)
    if (timeSignature === 7) strongBeats = [0, 3, 5]; // Common 7/8 grouping (e.g., 3+2+2)

    for (let i = 0; i < totalDivisions; i++) {
        const beat = document.createElement('div');
        beat.className = 'beat';
        beat.dataset.beat = i; // Store 0-based index

        // --- Determine Label ---
        const mainBeatNumber = Math.floor(i / subdivision) + 1;
        const subBeatNumber = (i % subdivision);
        if (subdivision === 1) {
            beat.textContent = mainBeatNumber;
        } else if (subdivision === 2) { // 8th notes (e.g., 4/4)
            beat.textContent = `${mainBeatNumber}${subBeatNumber === 0 ? '' : '&'}`;
        } else if (subdivision === 3) { // Triplets (e.g., 6/8, 12/8)
             beat.textContent = `${mainBeatNumber}${subBeatNumber === 0 ? '' : (subBeatNumber === 1 ? 'la' : 'li')}`; // 1 la li 2 la li...
        }

        // --- Determine Default Sound and Volume ---
        const isStrong = strongBeats.includes(i);
        let defaultSound = 'silent';
        let defaultVolume = '0';
        let defaultColor = '#9E9E9E'; // Grey (silent)

        if (soundType === 'drums') {
            // Default drum pattern (can be customized by clicking)
            if (i % subdivision === 0) { // On the main beat
                defaultSound = isStrong ? 'kick,hihat' : 'snare,hihat'; // Kick on 1, Snare on others (basic)
                defaultVolume = isStrong ? '1.0' : '0.8'; // Stronger kick
                defaultColor = isStrong ? '#1F618D' : '#4CAF50'; // Blue / Green
            } else { // Off-beat subdivisions
                defaultSound = 'hihat';
                defaultVolume = '0.6';
                defaultColor = '#777777'; // Darker grey
            }
             // Specific overrides for common patterns
             if (timeSignature === 4) { // Standard 4/4 rock/pop beat
                 if (i === 0 || i === 4) { defaultSound = 'kick,hihat'; defaultVolume = '1.0'; defaultColor = '#1F618D'; }
                 else if (i === 2 || i === 6) { defaultSound = 'snare,hihat'; defaultVolume = '1.0'; defaultColor = '#4CAF50'; }
                 else { defaultSound = 'hihat'; defaultVolume = '0.6'; defaultColor = '#777777'; }
             }
        } else { // Click or Woodblock
            if (i % subdivision === 0) { // Only play on main beats
                defaultSound = soundType;
                defaultVolume = isStrong ? '1.0' : '0.5'; // Accent on strong beats
                defaultColor = isStrong ? '#1F618D' : '#4CAF50'; // Blue / Green
            }
        }

        beat.dataset.sound = defaultSound;
        beat.dataset.baseVolume = defaultVolume; // Store the default/base volume for accent check
        beat.dataset.volume = defaultVolume; // Current volume (can be toggled)
        beat.style.backgroundColor = defaultColor;

        beat.addEventListener('click', () => toggleBeatState(beat, soundType, subdivision));
        container.appendChild(beat);
    }
}

function toggleBeatState(beat, soundType, subdivision) {
    const currentVolume = parseFloat(beat.dataset.volume);
    const currentSound = beat.dataset.sound;
    const isMainBeat = parseInt(beat.dataset.beat) % subdivision === 0;

    let states = [];
    // Define possible states [ { volume, sound, color }, ... ]
    if (soundType === 'drums') {
        // Cycle through: Strong Kick -> Strong Snare -> Regular Hat -> Silent -> (back to start)
        states = [
            { volume: '1.0', sound: 'kick,hihat', color: '#1F618D' }, // Strong Kick
            { volume: '1.0', sound: 'snare,hihat', color: '#4CAF50' }, // Strong Snare
            { volume: '0.6', sound: 'hihat', color: '#777777' },      // Regular Hat
            { volume: '0', sound: 'silent', color: '#9E9E9E' }       // Silent
        ];
    } else { // Click or Woodblock
        // Cycle through: Accent -> Regular -> Silent -> (back to start)
        states = [
            { volume: '1.0', sound: soundType, color: '#1F618D' }, // Accent
            { volume: '0.5', sound: soundType, color: '#4CAF50' }, // Regular
            { volume: '0', sound: 'silent', color: '#9E9E9E' }    // Silent
        ];
        // Only allow sound on main beats for click/woodblock
        if (!isMainBeat) {
             states = [{ volume: '0', sound: 'silent', color: '#9E9E9E' }]; // Force silent if not main beat
        }
    }

    // Find current state index
    let currentIndex = states.findIndex(state =>
        state.sound === currentSound && parseFloat(state.volume) === currentVolume
    );
    if (currentIndex === -1) currentIndex = states.length - 1; // Default to silent if state not found

    // Get next state
    const nextState = states[(currentIndex + 1) % states.length];

    // Update beat element
    beat.dataset.volume = nextState.volume;
    beat.dataset.sound = nextState.sound;
    beat.dataset.baseVolume = nextState.volume; // Update base volume as well
    beat.style.backgroundColor = nextState.color;
}


// --- Main Playback Loop ---

async function playBeat() {
    if (!AppState.isPlaying) return; // Stop if playback was cancelled

    const beats = UI.elements.beatsContainer.querySelectorAll('.beat');
    const totalBeatsInLoop = beats.length;
    if (totalBeatsInLoop === 0) return; // No beats to play

    // --- Update Visuals ---
    // Deactivate previous beat
    const prevBeatIndex = (AppState.currentBeat - 1 + totalBeatsInLoop) % totalBeatsInLoop;
    const prevBeatElement = beats[prevBeatIndex];
    if (prevBeatElement) prevBeatElement.classList.remove('active');

    // Activate current beat
    const currentBeatElement = beats[AppState.currentBeat];
    if (currentBeatElement) currentBeatElement.classList.add('active');

    // --- Play Metronome Sound ---
    if (currentBeatElement) {
        const beatVolume = parseFloat(currentBeatElement.dataset.volume) || 0;
        const timeSignature = parseInt(UI.elements.timeSignature.value);
        await playMetronomeSound(beatVolume, AppState.currentBeat, timeSignature);
    }

    // --- Handle Chord Progression and Fretboard Update ---
    const measures = UI.elements.measures.children;
    const numMeasures = measures.length;
    const timeSignatureValue = parseInt(UI.elements.timeSignature.value);
    const isCompound = [6, 12].includes(timeSignatureValue);
    const beatsPerMeasure = isCompound ? timeSignatureValue / 3 : timeSignatureValue;
    const subdivision = totalBeatsInLoop / beatsPerMeasure; // 1 for simple, 2 for 4/4, 3 for compound

    // Check if it's the start of a new measure (beat index 0)
    if (AppState.currentBeat === 0 && numMeasures > 0) {
        // Deactivate previous measure
        const prevMeasureIndex = (AppState.currentMeasure - 1 + numMeasures) % numMeasures;
        if (measures[prevMeasureIndex]) measures[prevMeasureIndex].classList.remove('active');

        // Activate current measure
        const currentMeasureElement = measures[AppState.currentMeasure];
        if (currentMeasureElement) {
            currentMeasureElement.classList.add('active');

            // Get chord and scale info from the current measure
            const root = currentMeasureElement.querySelector('.root-note')?.value;
            const quality = currentMeasureElement.querySelector('.chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-select')?.value;
            const tuning = TUNINGS[UI.elements.chordTuning.value]?.notes;

            if (root && quality && scaleRoot && scaleType && tuning) {
                // Update the main fretboard display
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);

                // Play the chord for the measure
                if (AppState.chordsPlaybackEnabled) {
                    const beatDurationSec = 60 / AppState.tempo / subdivision;
                    const measureDurationSec = beatDurationSec * totalBeatsInLoop;
                    const now = AudioContextManager.context.currentTime;
                    await playChord(root, quality, now, measureDurationSec);
                }
            }
        }
    }

    // --- Advance Beat and Measure Counters ---
    AppState.currentBeat = (AppState.currentBeat + 1) % totalBeatsInLoop;
    if (AppState.currentBeat === 0 && numMeasures > 0) {
        AppState.currentMeasure = (AppState.currentMeasure + 1) % numMeasures;
    }

    // Update state (optional, for potential listeners)
    // AppState.updateState({ currentBeat: AppState.currentBeat, currentMeasure: AppState.currentMeasure });

    // --- Schedule Next Beat ---
    // Reschedule based on current tempo right before the next beat is due
    // This makes tempo changes more responsive
    if (AppState.isPlaying) {
         const intervalMs = (60 / AppState.tempo) * 1000 / subdivision;
         AppState.intervalId = setTimeout(playBeat, intervalMs);
    }
}


async function startPlayback() {
    try {
        await AudioContextManager.ensureAudioContext(); // Ensure audio is ready
        if (AppState.isPlaying) return; // Already playing

        const measures = UI.elements.measures.children;
        if (measures.length === 0) {
            alert('Please add at least one measure to the progression.');
            return;
        }

        log("Starting playback...");
        AppState.updateState({ isPlaying: true, currentBeat: 0, currentMeasure: 0 });
        UI.elements.startStopButton.textContent = 'Stop';
        UI.elements.startStopButton.style.backgroundColor = '#e74c3c'; // Red for stop

        // Clear any previous visual states
        document.querySelectorAll('.beat.active').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));

        // Immediately trigger the first beat
        await playBeat();

    } catch (error) {
        console.error('Failed to start playback:', error);
        alert('Could not start playback. Please ensure audio is enabled and try again.');
        stopPlayback(); // Reset state if start fails
    }
}

function stopPlayback() {
    log("Stopping playback...");
    clearTimeout(AppState.intervalId); // Use clearTimeout for setTimeout
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false }); // Keep currentBeat/Measure for visual reference? Resetting might be better.
    // AppState.updateState({ isPlaying: false, currentBeat: 0, currentMeasure: 0 });

    // Fade out any lingering chord sound
    if (AudioContextManager.context && AudioContextManager.currentChordGain) {
        const now = AudioContextManager.context.currentTime;
        AudioContextManager.currentChordGain.gain.cancelScheduledValues(now);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); // Quick fade
        AudioContextManager.currentChordGain = null;
    }

    // Reset UI elements
    UI.elements.startStopButton.textContent = 'Start';
    UI.elements.startStopButton.style.backgroundColor = ''; // Reset to default button color

    // Remove active classes after a short delay to let the last beat visual finish
    setTimeout(() => {
        document.querySelectorAll('.beat.active').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));
         // Optionally reset fretboard to first measure state
         // const firstMeasure = UI.elements.measures.firstElementChild;
         // if (firstMeasure) syncFretboardWithMeasure(firstMeasure);
    }, 100); // Adjust delay as needed
}


// --- Chord Progression Management ---

function loadProgression(progressionName, overrideKey = null) {
    if (!progressionName || !progressions[progressionName]) {
        // If empty value selected, just clear measures
        if (progressionName === "") {
            UI.elements.measures.innerHTML = '';
            addMeasure(); // Add one default measure
            log("Cleared progression, added default measure.");
        } else {
            console.error(`Invalid progression name: ${progressionName}`);
        }
        return;
    }

    const progressionData = progressions[progressionName];
    const selectedKey = overrideKey || progressionData.defaultKey || "C";
    UI.elements.keySelect.value = selectedKey; // Update key dropdown

    // Clear existing measures
    UI.elements.measures.innerHTML = '';
    log(`Loading progression "${progressionName}" in key: ${selectedKey}`);

    progressionData.progression.forEach((chordFunction, index) => {
        try {
            // Use the new getChordFromFunction
            const chordSymbol = getChordFromFunction(chordFunction, selectedKey);
            if (!chordSymbol) {
                console.warn(`Failed to parse chord function: ${chordFunction} in key ${selectedKey}`);
                addMeasure('C', 'maj7', 'C', 'major', index + 1); // Add default measure on error
                return;
            }

            // Parse the resulting chord symbol to get root and quality
            const rootMatch = chordSymbol.match(/^[A-G][#b]?/);
            const root = rootMatch ? rootMatch[0] : 'C';
            const qualityString = rootMatch ? chordSymbol.substring(rootMatch[0].length) : 'maj7';
            const qualityValue = getQualityValue(qualityString || 'maj'); // Ensure qualityValue is valid internal key
            const suggestedScale = suggestScaleForQuality(qualityValue);

            // Add the measure with parsed/suggested values
            addMeasure(root, qualityValue, root, suggestedScale, index + 1, chordFunction);

        } catch (error) {
            console.error(`Error processing chord ${chordFunction} at index ${index}:`, error);
            addMeasure('C', 'maj7', 'C', 'major', index + 1); // Add default on error
        }
    });

    // Ensure at least one measure exists
    if (UI.elements.measures.children.length === 0) {
        addMeasure();
    }

    updateMeasureNumbers(); // Renumber measures
    syncFretboardWithMeasure(UI.elements.measures.firstElementChild); // Update fretboard for the first measure
}

function updateProgressionKey(newKey) {
    log(`Updating progression to key: ${newKey}`);
    Array.from(UI.elements.measures.children).forEach((measure) => {
        const chordFunc = measure.dataset.chordFunction; // Get stored function if available
        let root, qualityValue, suggestedScale;

        if (chordFunc) {
            // Recalculate chord based on original function and new key
            const chordSymbol = getChordFromFunction(chordFunc, newKey);
            if (chordSymbol) {
                const rootMatch = chordSymbol.match(/^[A-G][#b]?/);
                root = rootMatch ? rootMatch[0] : 'C';
                const qualityString = rootMatch ? chordSymbol.substring(rootMatch[0].length) : 'maj7';
                qualityValue = getQualityValue(qualityString || 'maj');
                suggestedScale = suggestScaleForQuality(qualityValue);
            } else {
                // Fallback if function parsing fails with new key
                root = measure.querySelector('.root-note').value; // Keep existing root?
                qualityValue = measure.querySelector('.chord-quality').value;
                suggestedScale = measure.querySelector('.scale-select').value;
            }
        } else {
            // If no original function stored, just update the root? Or try to transpose?
            // Simplest: just update the root note selector's options, maybe not the value itself?
            // For now, let's assume we *always* have chordFunc after loadProgression
            // If measures were added manually, they won't transpose automatically.
             root = measure.querySelector('.root-note').value;
             qualityValue = measure.querySelector('.chord-quality').value;
             suggestedScale = suggestScaleForQuality(qualityValue); // Resuggest scale
        }

        // Update measure controls
        const rootSelect = measure.querySelector('.root-note');
        const qualitySelect = measure.querySelector('.chord-quality');
        const secondKeySelect = measure.querySelector('.second-key');
        const scaleSelect = measure.querySelector('.scale-select');

        if (rootSelect) rootSelect.value = standardizeNoteName(root);
        if (qualitySelect) qualitySelect.value = qualityValue;
        if (secondKeySelect) secondKeySelect.value = standardizeNoteName(root); // Sync scale root
        if (scaleSelect) scaleSelect.value = suggestedScale; // Update scale suggestion
    });

    // Update fretboard based on the (potentially changed) first measure
    syncFretboardWithMeasure(UI.elements.measures.firstElementChild);
}

function addMeasure(root = 'C', quality = 'maj7', scaleRoot = 'C', scaleType = 'major', measureNum = null, chordFunction = null) {
    const measure = document.createElement('div');
    measure.className = 'measure';
    measure.draggable = true;
    const currentMeasureCount = UI.elements.measures.children.length;
    const number = measureNum !== null ? measureNum : currentMeasureCount + 1;

    // Store original function if provided (for key changes)
    if (chordFunction) {
        measure.dataset.chordFunction = chordFunction;
    }

    measure.innerHTML = `
        <span class="measure-number">${number}</span>
        <div class="chord-controls">
            <select class="root-note" aria-label="Chord Root">${createKeyOptions(root)}</select>
            <select class="chord-quality" aria-label="Chord Quality">${createQualityOptions(quality)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key" aria-label="Scale Root">${createKeyOptions(scaleRoot)}</select>
            <select class="scale-select" aria-label="Scale Type">${createScaleOptions(scaleType)}</select>
        </div>
    `;

    UI.elements.measures.appendChild(measure);

    // Add event listeners for drag/drop
    measure.addEventListener('dragstart', dragStart);
    measure.addEventListener('dragover', dragOver);
    measure.addEventListener('drop', drop);
    measure.addEventListener('dragend', dragEnd);

    // Add change listeners for controls within this measure
    measure.querySelectorAll('select').forEach(select => {
        select.addEventListener('change', () => updateMeasureState(measure));
    });

    if (measureNum === null) { // Only log if added manually
         log(`Added measure ${number}`);
         updateMeasureNumbers(); // Renumber if added manually at the end
    }
}

function removeMeasure() {
    const measures = UI.elements.measures.children;
    if (measures.length > 1) { // Keep at least one measure
        measures[measures.length - 1].remove();
        updateMeasureNumbers();
        log(`Removed last measure`);
        // Sync fretboard if the first measure was removed (though we remove last here)
        syncFretboardWithMeasure(UI.elements.measures.firstElementChild);
    } else {
        alert("Cannot remove the last measure.");
    }
}

function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const numberElement = measure.querySelector('.measure-number');
        if (numberElement) numberElement.textContent = index + 1;
    });
}

// Helper function to sync fretboard with a specific measure's scale settings
function syncFretboardWithMeasure(measure) {
    if (!measure) {
        // Default display if no measure
        UI.elements.scaleDisplay.textContent = "---";
        const defaultTuning = TUNINGS[UI.elements.chordTuning.value]?.notes || TUNINGS.standard.notes;
        updateFretboardNotes(UI.elements.chordFretboard, 'C', 'major', defaultTuning);
        return;
    }

    const scaleRoot = measure.querySelector('.second-key')?.value;
    const scaleType = measure.querySelector('.scale-select')?.value;
    const tuning = TUNINGS[UI.elements.chordTuning.value]?.notes;

    if (scaleRoot && scaleType && tuning) {
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }
}

// Helper function called when controls within a measure change
function updateMeasureState(measure) {
    const rootNote = measure.querySelector('.root-note').value;
    const quality = measure.querySelector('.chord-quality').value;
    const scaleRoot = measure.querySelector('.second-key').value;
    const scaleType = measure.querySelector('.scale-select').value;

    // Auto-sync scale root to chord root? Optional behavior.
    // measure.querySelector('.second-key').value = rootNote;

    // Auto-suggest scale based on new quality?
    // measure.querySelector('.scale-select').value = suggestScaleForQuality(quality);

    // Update fretboard if this is the currently active measure OR the first measure
    const measureIndex = Array.from(UI.elements.measures.children).indexOf(measure);
    if (measureIndex === AppState.currentMeasure || measureIndex === 0) {
        syncFretboardWithMeasure(measure);
    }
    log(`Measure ${measureIndex + 1} updated: ${rootNote}${CHORD_QUALITIES[quality]?.name || quality}, Scale: ${scaleRoot} ${SCALES[scaleType]?.name || scaleType}`);
}


// --- Drag and Drop Handlers ---
let draggedElement = null;

function dragStart(e) {
    draggedElement = e.target; // The measure being dragged
    const index = Array.from(UI.elements.measures.children).indexOf(draggedElement);
    e.dataTransfer.setData('text/plain', index); // Store index
    e.dataTransfer.effectAllowed = 'move';
    // Add visual indication
    setTimeout(() => draggedElement.classList.add('dragging'), 0);
    log(`Dragging measure ${index + 1}`);
}

function dragOver(e) {
    e.preventDefault(); // Necessary to allow dropping
    e.dataTransfer.dropEffect = 'move';
    const targetElement = e.target.closest('.measure');
    if (targetElement && targetElement !== draggedElement) {
        // Optional: Add visual feedback for drop target
        // targetElement.style.borderTop = '2px solid blue';
    }
}

function drop(e) {
    e.preventDefault();
    const targetElement = e.target.closest('.measure');
    // Clear visual feedback
    // if (targetElement) targetElement.style.borderTop = '';

    if (!targetElement || targetElement === draggedElement) {
        log("Drop cancelled or dropped on self.");
        return; // Don't drop on itself or outside a measure
    }

    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
    const targetIndex = Array.from(UI.elements.measures.children).indexOf(targetElement);

    log(`Dropping measure from index ${draggedIndex} to index ${targetIndex}`);

    // Perform the move in the DOM
    if (draggedIndex < targetIndex) {
        // Insert after the target element
        targetElement.parentNode.insertBefore(draggedElement, targetElement.nextSibling);
    } else {
        // Insert before the target element
        targetElement.parentNode.insertBefore(draggedElement, targetElement);
    }

    updateMeasureNumbers(); // Renumber all measures
    syncFretboardWithMeasure(UI.elements.measures.firstElementChild); // Resync fretboard
}

function dragEnd(e) {
    // Clear visual indication
    if (draggedElement) {
         draggedElement.classList.remove('dragging');
         log(`Finished dragging measure.`);
    }
    draggedElement = null;
    // Clear any lingering drop target styles
    // Array.from(UI.elements.measures.children).forEach(m => m.style.borderTop = '');
}

// --- FretFlow (Multiple Fretboards) ---

function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) return;
    fretboardsGrid.innerHTML = ''; // Clear existing content
    log("Initializing FretFlow section...");

    // Create 4 independent fretboard sections
    for (let i = 0; i < 4; i++) {
        const fretboardSection = document.createElement('div');
        fretboardSection.className = 'fretboard-section'; // Use this class for styling

        // Create controls for this specific fretboard
        fretboardSection.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group">
                    <label for="fretflow-key-${i}">Key:</label>
                    <select id="fretflow-key-${i}" class="fretflow-key" aria-label="Select key">
                        ${createKeyOptions(NOTES[i * 3])} <!-- Default to C, D#, F#, A -->
                    </select>
                </div>
                <div class="control-group">
                    <label for="fretflow-scale-${i}">Scale:</label>
                    <select id="fretflow-scale-${i}" class="fretflow-scale" aria-label="Select scale type">
                        ${createScaleOptions(Object.keys(SCALES)[i])} <!-- Default to first few scales -->
                    </select>
                </div>
                <div class="control-group">
                    <label for="fretflow-tuning-${i}">Tuning:</label>
                    <select id="fretflow-tuning-${i}" class="tuning-select" aria-label="Select guitar tuning">
                         ${Object.entries(TUNINGS).map(([key, value]) => `<option value="${key}" ${key === 'standard' ? 'selected' : ''}>${value.name}</option>`).join('')}
                    </select>
                </div>
            </div>
            <div class="scale-display"></div> <!-- Display for this fretboard -->
            <div id="fretflow-fretboard-${i}" class="fretboard"></div>
        `;

        fretboardsGrid.appendChild(fretboardSection);

        // Get references to this fretboard's elements
        const fretboardContainer = fretboardSection.querySelector(`#fretflow-fretboard-${i}`);
        const keySelect = fretboardSection.querySelector(`#fretflow-key-${i}`);
        const scaleSelect = fretboardSection.querySelector(`#fretflow-scale-${i}`);
        const tuningSelect = fretboardSection.querySelector(`#fretflow-tuning-${i}`);

        // Function to update this specific fretboard
        const updateThisFretboard = () => {
            try {
                const selectedKey = keySelect.value;
                const selectedScale = scaleSelect.value;
                const selectedTuningKey = tuningSelect.value;
                const selectedTuningNotes = TUNINGS[selectedTuningKey]?.notes;

                if (!selectedTuningNotes) {
                    console.error(`Invalid tuning selected: ${selectedTuningKey}`);
                    return;
                }

                // Create/Update the fretboard structure and notes
                createFretboard(fretboardContainer, selectedTuningNotes);
                updateFretboardNotes(fretboardContainer, selectedKey, selectedScale, selectedTuningNotes);

            } catch (error) {
                console.error(`Error updating FretFlow fretboard ${i}:`, error);
            }
        };

        // Add event listeners for controls
        keySelect.addEventListener('change', updateThisFretboard);
        scaleSelect.addEventListener('change', updateThisFretboard);
        tuningSelect.addEventListener('change', updateThisFretboard);

        // Initial render for this fretboard
        updateThisFretboard();
    }
     log("FretFlow initialized with 4 independent fretboards.");
}


// --- Event Listeners Setup ---
function setupEventListeners() {
    log("Setting up event listeners...");

    // Ensure audio is initialized on first user interaction
    const initializeAudioInteraction = async () => {
        try {
            await AudioContextManager.ensureAudioContext();
            // Remove the listener after successful initialization
            document.body.removeEventListener('click', initializeAudioInteraction);
            document.body.removeEventListener('touchstart', initializeAudioInteraction);
            log("Audio interaction listener removed.");
        } catch (error) {
            console.error('Failed to initialize audio on interaction:', error);
            // Keep the listener active if initialization fails
        }
    };
    document.body.addEventListener('click', initializeAudioInteraction, { once: false });
    document.body.addEventListener('touchstart', initializeAudioInteraction, { once: false });


    // Start/Stop button
    UI.elements.startStopButton.addEventListener('click', () => {
        if (AppState.isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    });

    // Drum set toggle button
    UI.elements.drumSetToggleBtn.addEventListener('click', () => {
        currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
        UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
        log(`Switched to drum set: ${drumSoundSets[currentDrumSetIndex].name}`);
        // No need to recreate beats, sound selection happens during playback
    });

    // Metronome sound type select
    UI.elements.soundType.addEventListener('change', (e) => {
        const isDrums = e.target.value === 'drums';
        UI.elements.drumSetToggleBtn.style.display = isDrums ? 'inline-block' : 'none';
        // Update drum button text if switching to drums
        if (isDrums) {
             UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
        }
        createBeats(); // Recreate beats with new default sounds
        log(`Metronome sound type changed to: ${e.target.value}`);
    });

    // Dark mode toggle
    UI.elements.darkModeToggle.addEventListener('click', () => {
        AppState.darkMode = (AppState.darkMode + 1) % 4; // Cycle through 0, 1, 2, 3
        document.body.classList.remove('dark-mode', 'dark-mode-2', 'dark-mode-3');
        UI.elements.darkModeToggle.classList.remove('active', 'active-2', 'active-3');
        UI.elements.darkModeToggle.textContent = "Theme"; // Reset text

        switch(AppState.darkMode) {
            case 1:
                document.body.classList.add('dark-mode');
                UI.elements.darkModeToggle.classList.add('active');
                UI.elements.darkModeToggle.textContent = "Theme 1";
                log('Dark mode 1 enabled');
                break;
            case 2:
                document.body.classList.add('dark-mode-2');
                UI.elements.darkModeToggle.classList.add('active-2');
                 UI.elements.darkModeToggle.textContent = "Theme 2";
                log('Dark mode 2 enabled');
                break;
            case 3:
                document.body.classList.add('dark-mode-3');
                UI.elements.darkModeToggle.classList.add('active-3');
                 UI.elements.darkModeToggle.textContent = "Theme 3";
                log('Dark mode 3 enabled');
                break;
            default: // Case 0
                 UI.elements.darkModeToggle.textContent = "Light Mode";
                log('Light mode enabled');
                break;
        }
    });

    // Chords playback toggle
    UI.elements.chordsEnabled.addEventListener('click', () => {
        AppState.chordsPlaybackEnabled = !AppState.chordsPlaybackEnabled;
        UI.elements.chordsEnabled.textContent = AppState.chordsPlaybackEnabled ? 'Chords Enabled' : 'Chords Disabled';
        UI.elements.chordsEnabled.classList.toggle('active', AppState.chordsPlaybackEnabled);
        log(`Chords playback ${AppState.chordsPlaybackEnabled ? 'enabled' : 'disabled'}`);
    });

    // Tempo slider
    const tempoUpdateDebounced = debounce(() => {
         if (AppState.isPlaying) {
            // No need to stop/start, playBeat loop adjusts timing automatically
            log("Tempo changed while playing, loop will adjust.");
         }
    }, 200); // Debounce tempo changes slightly

    UI.elements.tempo.addEventListener('input', () => {
        AppState.tempo = parseInt(UI.elements.tempo.value);
        UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        tempoUpdateDebounced();
    });

    // Tap Tempo
    let tapTimestamps = [];
    UI.elements.tapTempo.addEventListener('click', () => {
        const now = performance.now(); // Use performance.now for higher precision
        tapTimestamps.push(now);

        // Keep only recent taps (e.g., last 4 taps within 5 seconds)
        tapTimestamps = tapTimestamps.filter(ts => now - ts < 5000);
        if (tapTimestamps.length > 4) {
            tapTimestamps.shift(); // Remove oldest tap
        }

        if (tapTimestamps.length >= 2) {
            // Calculate average interval
            let totalInterval = 0;
            for (let i = 1; i < tapTimestamps.length; i++) {
                totalInterval += tapTimestamps[i] - tapTimestamps[i - 1];
            }
            const avgInterval = totalInterval / (tapTimestamps.length - 1);

            if (avgInterval > 0) {
                const bpm = Math.round(60000 / avgInterval);
                AppState.tempo = Math.max(40, Math.min(240, bpm)); // Clamp tempo
                UI.elements.tempo.value = AppState.tempo;
                UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                log(`Tap tempo calculated: ${AppState.tempo} BPM`);
                tempoUpdateDebounced(); // Apply change (debounced)
            }
        }
        // Visual feedback for tap
        UI.elements.tapTempo.style.transform = 'scale(1.1)';
        setTimeout(() => UI.elements.tapTempo.style.transform = 'scale(1)', 100);
    });


    // Time signature change
    UI.elements.timeSignature.addEventListener('change', () => {
        log(`Time signature changed to: ${UI.elements.timeSignature.options[UI.elements.timeSignature.selectedIndex].text}`);
        createBeats(); // Recreate beats display
        if (AppState.isPlaying) {
            stopPlayback(); // Stop and restart playback with new timing
            startPlayback();
        }
    });

    // Volume controls (just log changes for now)
    UI.elements.metronomeVolume.addEventListener('input', () => log(`Metronome volume: ${UI.elements.metronomeVolume.value}`));
    UI.elements.chordFretboardVolume.addEventListener('input', () => log(`Chord fretboard volume: ${UI.elements.chordFretboardVolume.value}`));
    UI.elements.chordVolume.addEventListener('input', () => log(`Chord volume: ${UI.elements.chordVolume.value}`));
    UI.elements.fretboardVolume.addEventListener('input', () => log(`FretFlow volume: ${UI.elements.fretboardVolume.value}`));
    UI.elements.accentIntensity.addEventListener('input', () => log(`Accent intensity: ${UI.elements.accentIntensity.value}`));


    // Progression select change
    UI.elements.progressionSelect.addEventListener('change', () => {
        loadProgression(UI.elements.progressionSelect.value);
    });

    // Key select change
    UI.elements.keySelect.addEventListener('change', () => {
        updateProgressionKey(UI.elements.keySelect.value);
        // Optionally update FretFlow keys too? For now, they are independent.
        // initializeFretFlow(); // Re-init FretFlow if keys should sync
    });

    // Main fretboard tuning change
    UI.elements.chordTuning.addEventListener('change', () => {
        log(`Main fretboard tuning changed to: ${UI.elements.chordTuning.value}`);
        syncFretboardWithMeasure(UI.elements.measures.firstElementChild); // Update main fretboard
    });

    // Event delegation for measure control changes (more efficient than individual listeners)
    UI.elements.measures.addEventListener('change', (e) => {
        if (e.target.tagName === 'SELECT') {
            const measureElement = e.target.closest('.measure');
            if (measureElement) {
                updateMeasureState(measureElement);
            }
        }
    });

    log("Event listeners set up complete.");
}

// --- Initialization ---
async function initializeApp() {
    log("Initializing Bebop Blueprint...");
    updateLoadingStatus("Initializing UI...", true);
    UI.init(); // Cache UI elements

    // Populate dropdowns that need dynamic options
    UI.elements.keySelect.innerHTML = createAllKeyOptions('C'); // Populate key select with C, Cm, C#, C#m etc.
    // Scale/Quality dropdowns are populated when measures are created/loaded

    updateLoadingStatus("Creating initial UI components...");
    createBeats(); // Create initial metronome beats based on default 4/4
    const initialTuning = TUNINGS[UI.elements.chordTuning.value]?.notes || TUNINGS.standard.notes;
    createFretboard(UI.elements.chordFretboard, initialTuning); // Create main fretboard structure

    updateLoadingStatus("Loading default progression...");
    loadProgression(UI.elements.progressionSelect.value || "2_5_1"); // Load default or II-V-I

    updateLoadingStatus("Initializing FretFlow...");
    initializeFretFlow(); // Initialize the 4 FretFlow fretboards

    updateLoadingStatus("Setting up interactions...");
    setupEventListeners(); // Setup all event listeners

    // Initial check for drum button visibility
    UI.elements.drumSetToggleBtn.style.display = UI.elements.soundType.value === 'drums' ? 'inline-block' : 'none';
    if (UI.elements.soundType.value === 'drums') {
         UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
    }

    // Hide loading indicator after a short delay
    // Audio loading happens on first interaction, so main init is fast
    setTimeout(() => {
        updateLoadingStatus("Ready!", false);
        log("Application initialized successfully.");
    }, 200);
}

// --- Run Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Application Initialization Failed:", error);
        updateLoadingStatus("Initialization Error!", true);
        alert("Error initializing the application. Please check the console for details and try refreshing.");
    });
});


    </script>
</body>
</html>
