<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1f618d;
        }
        .app-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .fretboards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .fretboard-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .scale-display {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .controls-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: bold;
        }
        
        .control-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .fretboard {
            position: relative;
            height: 200px;
            background-color: #FFCF79;
            border-radius: 5px;
            margin-bottom: 30px;
            border: 2px solid #4B1C2E;
            overflow: visible;
        }
        .fret-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #c0c0c0;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        .string-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background: silver;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 0;
        }
        .fret-number {
            position: absolute;
            bottom: -40px;
            font-size: 16px;
            color: #1f618d;
            transform: translateX(-50%);
            font-weight: bold;
            z-index: 2;
            width: 20px;
            text-align: center;
        }
        .fret-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .note {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            z-index: 3;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
        }
        .note:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        .beat {
            width: 40px;
            height: 80px;
            background: #9E9E9E;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 14px;
            margin: 0 2px;
        }
        .beats-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            flex-wrap: nowrap;
        }
        .beat.active {
            transform: translateY(-10px);
        }
        #measures {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }
        .measure {
            position: relative;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            transition: opacity 0.2s ease;
        }
        .measure.dragging {
            opacity: 0.5;
        }
        .measure.active {
            background-color: #c3e6cb;
            border: 2px solid #28a745;
        }
        .measure-number {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #333;
        }
        .chord-controls, .scale-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .chord-controls select, .scale-controls select {
            flex: 1;
        }

      /* Define CSS variables for each dark mode */
:root {
    /* Dark Mode 1 */
    --dm1-bg: #283618;
    --dm1-bg-alt: #606c38;
    --dm1-text: #fefae0;
    --dm1-accent: #dda15e;
    --dm1-accent-hover: #bc6c25;
    --dm1-border: #4b4b4b;

    /* Dark Mode 2 */
    --dm2-bg: #0a1128;
    --dm2-bg-alt: #034078;
    --dm2-text: #fefcfb;
    --dm2-accent: #1282a2;
    --dm2-accent-hover: #0a6b8b;
    --dm2-border: #1282a2;

    /* Dark Mode 3 */
    --dm3-bg: #6b705c;
    --dm3-bg-alt: #a5a58d;
    --dm3-text: #fefae0; /* Changed from #ffe8d6 for better contrast */
    --dm3-accent: #cb997e;
    --dm3-accent-hover: #b58368;
    --dm3-border: #6b705c;
}

/* Base fretboard-section styles */
.fretboard-section {
    border: 1px solid #ccc;
    padding: 15px;
    border-radius: 8px;
    background-color: #f9f9f9;
}

/* Dark Mode 1 */
body.dark-mode {
    background-color: var(--dm1-bg);
    color: var(--dm1-text);
    transition: background-color 0.3s ease, color 0.3s ease;
}

body.dark-mode .fretboard-section {
    background-color: var(--dm1-bg);
    border-color: var(--dm1-border);
    color: var(--dm1-text);
}

body.dark-mode .app-section,
body.dark-mode #fretflow-section {
    background: linear-gradient(145deg, var(--dm1-bg), var(--dm1-bg-alt));
    color: var(--dm1-text);
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

body.dark-mode .fretboard-container {
    background-color: var(--dm1-bg-alt);
    border: 1px solid var(--dm1-accent);
    border-radius: 10px;
}

body.dark-mode .fretboard {
    background-color: var(--dm1-accent);
    border: 2px solid var(--dm1-border);
    border-radius: 5px;
}

body.dark-mode .note {
    background-color: var(--dm1-accent);
    color: var(--dm1-bg);
}

body.dark-mode .note:hover {
    transform: scale(1.2);
    background-color: var(--dm1-accent-hover);
}

body.dark-mode .scale-display,
body.dark-mode .control-group label,
body.dark-mode #tempo-display,
body.dark-mode .volume-control {
    color: var(--dm1-text);
}

body.dark-mode button,
body.dark-mode .control-button,
body.dark-mode .toggle-button {
    background-color: var(--dm1-accent);
    color: var(--dm1-bg);
    border: 1px solid var(--dm1-accent-hover);
}

body.dark-mode button:hover,
body.dark-mode .control-button:hover,
body.dark-mode .toggle-button:hover {
    background-color: var(--dm1-accent-hover);
}

body.dark-mode select {
    background-color: var(--dm1-accent);
    color: var(--dm1-bg);
    border: 1px solid var(--dm1-accent-hover);
}

body.dark-mode .measure {
    background-color: var(--dm1-bg-alt);
    color: var(--dm1-text);
    border: 1px solid var(--dm1-accent);
}

body.dark-mode .measure.active {
    background-color: var(--dm1-accent);
    border-color: var(--dm1-accent-hover);
}

body.dark-mode .beat {
    background-color: var(--dm1-accent);
    color: var(--dm1-bg);
}

body.dark-mode .beat.active {
    background-color: var(--dm1-accent-hover);
    transform: translateY(-5px);
}

body.dark-mode #dark-mode-toggle.active,
body.dark-mode .toggle-button.active {
    background-color: var(--dm1-bg);
    color: var(--dm1-text);
    border: 1px solid var(--dm1-accent);
}

/* Dark Mode 2 */
body.dark-mode-2 {
    background-color: var(--dm2-bg);
    color: var(--dm2-text);
    transition: background-color 0.3s ease, color 0.3s ease;
}

body.dark-mode-2 .fretboard-section {
    background-color: var(--dm2-bg);
    border-color: var(--dm2-border);
    color: var(--dm2-text);
}

body.dark-mode-2 .app-section,
body.dark-mode-2 #fretflow-section {
    background: linear-gradient(145deg, var(--dm2-bg), var(--dm2-bg-alt));
    color: var(--dm2-text);
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

body.dark-mode-2 .fretboard-container {
    background-color: var(--dm2-bg-alt);
    border: 1px solid var(--dm2-accent);
    border-radius: 10px;
}

body.dark-mode-2 .fretboard {
    background-color: var(--dm2-bg);
    border: 2px solid var(--dm2-border);
    border-radius: 5px;
}

body.dark-mode-2 .note {
    background-color: var(--dm2-accent);
    color: var(--dm2-text);
}

body.dark-mode-2 .scale-display,
body.dark-mode-2 .control-group label,
body.dark-mode-2 #tempo-display,
body.dark-mode-2 .volume-control {
    color: var(--dm2-text);
}

body.dark-mode-2 button,
body.dark-mode-2 .control-button,
body.dark-mode-2 .toggle-button {
    background-color: var(--dm2-accent);
    color: var(--dm2-text);
    border: 1px solid var(--dm2-bg-alt);
}

body.dark-mode-2 select {
    background-color: var(--dm2-bg-alt);
    color: var(--dm2-text);
    border: 1px solid var(--dm2-accent);
}

body.dark-mode-2 .measure {
    background-color: var(--dm2-bg-alt);
    color: var(--dm2-text);
    border: 1px solid var(--dm2-accent);
}

body.dark-mode-2 .measure.active {
    background-color: var(--dm2-accent);
    border-color: var(--dm2-text);
}

body.dark-mode-2 .beat {
    background-color: var(--dm2-accent);
    color: var(--dm2-text);
}

body.dark-mode-2 .beat.active {
    background-color: var(--dm2-bg-alt);
    transform: translateY(-5px);
}

body.dark-mode-2 #dark-mode-toggle.active-2 {
    background-color: var(--dm2-accent);
    color: var(--dm2-text);
    border: 1px solid var(--dm2-bg-alt);
}

/* Dark Mode 3 */
body.dark-mode-3 {
    background-color: var(--dm3-bg);
    color: var(--dm3-text);
    transition: background-color 0.3s ease, color 0.3s ease;
}

body.dark-mode-3 .fretboard-section {
    background-color: var(--dm3-bg);
    border-color: var(--dm3-border);
    color: var(--dm3-text);
}

body.dark-mode-3 .app-section,
body.dark-mode-3 #fretflow-section {
    background: linear-gradient(145deg, var(--dm3-bg), var(--dm3-bg-alt));
    color: var(--dm3-text);
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

body.dark-mode-3 .fretboard-container {
    background-color: var(--dm3-bg-alt);
    border: 1px solid var(--dm3-accent);
    border-radius: 10px;
}

body.dark-mode-3 .fretboard {
    background-color: var(--dm3-accent);
    border: 2px solid var(--dm3-border);
    border-radius: 5px;
}

body.dark-mode-3 .note {
    background-color: var(--dm3-bg-alt);
    color: var(--dm3-border);
}

body.dark-mode-3 .scale-display,
body.dark-mode-3 .control-group label,
body.dark-mode-3 #tempo-display,
body.dark-mode-3 .volume-control {
    color: var(--dm3-text);
}

body.dark-mode-3 button,
body.dark-mode-3 .control-button,
body.dark-mode-3 .toggle-button {
    background-color: var(--dm3-accent);
    color: var(--dm3-text);
    border: 1px solid var(--dm3-border);
}

body.dark-mode-3 select {
    background-color: var(--dm3-bg-alt);
    color: var(--dm3-border);
    border: 1px solid var(--dm3-accent);
}

body.dark-mode-3 .measure {
    background-color: var(--dm3-bg-alt);
    color: var(--dm3-text);
    border: 1px solid var(--dm3-accent);
}

body.dark-mode-3 .measure.active {
    background-color: var(--dm3-accent);
    border-color: var(--dm3-border);
}

body.dark-mode-3 .beat {
    background-color: var(--dm3-bg-alt);
    color: var(--dm3-border);
}

body.dark-mode-3 .beat.active {
    background-color: var(--dm3-accent);
    transform: translateY(-5px);
}

body.dark-mode-3 #dark-mode-toggle.active-3 {
    background-color: var(--dm3-accent);
    color: var(--dm3-text);
    border: 1px solid var(--dm3-border);
}

/* Range input styling (cross-browser) */
body.dark-mode .volume-control input[type="range"],
body.dark-mode-2 .volume-control input[type="range"],
body.dark-mode-3 .volume-control input[type="range"] {
    background: transparent;
    -webkit-appearance: none;
    appearance: none;
}

body.dark-mode .volume-control input[type="range"]::-webkit-slider-runnable-track,
body.dark-mode-2 .volume-control input[type="range"]::-webkit-slider-runnable-track,
body.dark-mode-3 .volume-control input[type="range"]::-webkit-slider-runnable-track {
    background: var(--dm1-bg-alt, --dm2-bg-alt, --dm3-bg-alt);
    height: 8px;
    border-radius: 4px;
}

body.dark-mode .volume-control input[type="range"]::-webkit-slider-thumb,
body.dark-mode-2 .volume-control input[type="range"]::-webkit-slider-thumb,
body.dark-mode-3 .volume-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--dm1-accent, --dm2-accent, --dm3-accent);
    border: 1px solid var(--dm1-accent-hover, --dm2-accent-hover, --dm3-accent-hover);
    margin-top: -4px;
}

body.dark-mode .volume-control input[type="range"]::-moz-range-track,
body.dark-mode-2 .volume-control input[type="range"]::-moz-range-track,
body.dark-mode-3 .volume-control input[type="range"]::-moz-range-track {
    background: var(--dm1-bg-alt, --dm2-bg-alt, --dm3-bg-alt);
    height: 8px;
    border-radius: 4px;
}

body.dark-mode .volume-control input[type="range"]::-moz-range-thumb,
body.dark-mode-2 .volume-control input[type="range"]::-moz-range-thumb,
body.dark-mode-3 .volume-control input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--dm1-accent, --dm2-accent, --dm3-accent);
    border: 1px solid var(--dm1-accent-hover, --dm2-accent-hover, --dm3-accent-hover);
}
        
    </style>
</head>
<body>
    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <div class="scale-display" id="scale-display"></div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls">
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option>
                <option value="3">3/4</option>
                <option value="4" selected>4/4</option>
                <option value="6">6/8</option>
                <option value="7">7/8</option>
                <option value="8">8/8</option>
                <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option>
                <option value="woodblock">Woodblock</option>
                <option value="drums">Drums</option>
            </select>
            <button id="drumSetToggleBtn" class="control-button">Drums</button>
            <div class="volume-control">
                <span>Metronome Volume:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>
        <div class="beats-container"></div>
    </div>

    <div class="volume-control">
        <label for="accent-intensity">Accent Intensity:</label>
        <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
    </div>
    
    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
        <label for="progression-select">Select Progression:</label>
       <select id="progression-select" aria-label="Select chord progression">
            <option value="i-v7">I-V7</option>
            <option value="jazz-blues">Jazz Blues</option>
            <option value="minor-blues">Minor Blues</option>
            <option value="rhythm-changes">Rhythm Changes</option>
            <option value="ii-v-i">II-V-I</option>
            <option value="vi-ii-v-i">VI-II-V-I</option>
            <option value="minor-ii-v-i">Minor iim-V7-im</option>
            <option value="dark-eyes">Dark Eyes</option>
            <option value="ill-see-you-in-my-dreams">I'll See You In My Dreams</option>
            <option value="rose-room">Rose Room</option>
            <option value="black-orpheus">Black Orpheus</option>
            <option value="all-the-things-you-are">All The Things You Are</option>
            <option value="all-of-me">All of Me</option>
            <option value="stella-by-starlight">Stella By Starlight</option>
            <option value="autumn-leaves">Autumn Leaves</option>
            <option value="summertime">Summertime</option>
            <option value="girl-from-ipanema">Girl From Ipanema</option>
            <option value="coltrane-changes">Coltrane Changes</option>
            <option value="bird-blues">Bird Blues</option>
            <option value="just-friends">Just Friends</option>
            <option value="blue-bossa">Blue Bossa</option>
            <option value="on-green-dolphin-street">On Green Dolphin Street</option>
            <option value="solar">Solar</option>
            <option value="misty">Misty</option>
            <option value="days-of-wine-and-roses">Days of Wine and Roses</option>
            <option value="cherokee">Cherokee</option>
            <option value="caravan">Caravan</option>
            <option value="nows-the-time">Now's The Time</option>
            <option value="tenor-madness">Tenor Madness</option>
        </select>
        <label for="keySelect">Select Key:</label>
        <select id="keySelect" aria-label="Select key">
            <option value="C">C</option>
            <option value="Db">Db</option>
            <option value="D">D</option>
            <option value="Eb">Eb</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="Gb">Gb</option>
            <option value="G">G</option>
            <option value="Ab">Ab</option>
            <option value="A">A</option>
            <option value="Bb">Bb</option>
            <option value="B">B</option>
        </select>
        <div id="measures">
            <!-- Measures will be populated dynamically -->
        </div>
        <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
        <button onclick="removeMeasure()" aria-label="Remove measure">Remove Measure</button>
        <div class="checkbox-wrapper">
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.75" aria-label="Chord volume">
        </div>
        <div class="control-group">
              <label for="reverb-dial">Reverb</label>
              <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
              <span id="reverb-dial-value">20</span>%
         </div>
        <!-- Add progress bar to the body -->
<div id="audio-loading-progress" style="display: none; position: fixed; top: 10px; left: 50%; transform: translateX(-50%); width: 300px; background: #f0f0f0; border-radius: 5px; padding: 10px; text-align: center; z-index: 1001;">
    <span>Loading Audio Samples...</span>
    <div style="width: 100%; height: 20px; background: #ddd; border-radius: 3px; overflow: hidden;">
        <div id="progress-bar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s ease;"></div>
    </div>
    <span id="progress-text">0%</span>
</div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <!-- controls-container and volume-control removed -->
    <div class="fretboards-grid"></div>
</div>

    <script>
        
// Utility Functions
function log(message) {
    console.log(`[FretFlow Debug] ${message}`);
}

function updateLoadingStatus(message) {
    let indicator = document.getElementById('loading-indicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'loading-indicator';
        document.body.appendChild(indicator);
    }
    indicator.textContent = message;
}

function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
        function standardizeNoteName(note) {
            const sharpToFlat = {
                'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
            };
            return sharpToFlat[note] || note;
        }
        
const ALL_NOTES = [
  'a', 'as', 'b', 'c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs'
];
const OCTAVES = [2, 3, 4, 5];
const FILE_FORMAT = 'wav';

function getSampleFileName(note, octave) {
  return `${note}${octave}.${FILE_FORMAT}`;
}
        
const allSampleFiles = [];
for (const note of ALL_NOTES) {
  for (const octave of OCTAVES) {
    allSampleFiles.push(getSampleFileName(note, octave));
  }
}
        
      
const ENHARMONIC_MAP = {
    'C#': 'Db', 'Db': 'Db',
    'D#': 'Eb', 'Eb': 'Eb',
    'F#': 'Gb', 'Gb': 'Gb',
    'G#': 'Ab', 'Ab': 'Ab',
    'A#': 'Bb', 'Bb': 'Bb'
};
const SAMPLE_NOTE_MAP = {
    'C': 'c',
    'C#': 'cs',
    'Db': 'cs',
    'D': 'd',
    'D#': 'ds',
    'Eb': 'ds',
    'E': 'e',
    'F': 'f',
    'F#': 'fs',
    'Gb': 'fs',
    'G': 'g',
    'G#': 'gs',
    'Ab': 'gs',
    'A': 'a',
    'A#': 'as',
    'Bb': 'as',
    'B': 'b'
};        
const PIANO_NOTES = {
    'A2': 110.00, 'As2': 116.54, 'B2': 123.47,
    'C3': 130.81, 'Cs3': 138.59, 'D3': 146.83, 'Ds3': 155.56, 'E3': 164.81, 'F3': 174.61,
    'Fs3': 185.00, 'G3': 196.00, 'Gs3': 207.65, 'A3': 220.00, 'As3': 233.08, 'B3': 246.94,
    'C4': 261.63, 'Cs4': 277.18, 'D4': 293.66, 'Ds4': 311.13, 'E4': 329.63
};
        
function standardizeNoteName(note) {
    if (!note) return '';
    
    // Convert to uppercase and handle basic formatting
    note = note.toUpperCase().trim();
    
    // Replace ♭ with b and ♯ with #
    note = note.replace('♭', 'b').replace('♯', '#');
    
    // Convert sharps to flats
    const sharpToFlat = {
        'C#': 'Db',
        'D#': 'Eb',
        'F#': 'Gb',
        'G#': 'Ab',
        'A#': 'Bb'
    };
    
    if (note.includes('#')) {
        return sharpToFlat[note] || note;
    }
    
    return note;
}
        
const FRETBOARD_FREQUENCIES = {
    'string6': [82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81],
    'string5': [110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00],
    'string4': [146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66],
    'string3': [196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00],
    'string2': [246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88],
    'string1': [329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88, 523.25, 554.37, 587.33, 622.25, 659.25]
};

const SCALES = {
    // Basic Scales
    major: [0, 2, 4, 5, 7, 9, 11],
    minor: [0, 2, 3, 5, 7, 8, 10],
    harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
    melodicMinor: [0, 2, 3, 5, 7, 9, 11],
    
    // Modes
    dorian: [0, 2, 3, 5, 7, 9, 10],
    phrygian: [0, 1, 3, 5, 7, 8, 10],
    lydian: [0, 2, 4, 6, 7, 9, 11],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    locrian: [0, 1, 3, 5, 6, 8, 10],
    
    // Jazz Scales
    bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11],
    bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11],
    bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10],
    bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10], // Added Bebop Phrygian
    altered: [0, 1, 3, 4, 6, 8, 10],      // Super Locrian
    lydianDominant: [0, 2, 4, 6, 7, 9, 10],
    
    // Symmetric Scales
    diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11],  // Diminished (Whole-Half)
    diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10],  // Diminished (Half-Whole)
    wholeHalf: [0, 2, 4, 6, 8, 10],           // Whole Tone
    
    // Pentatonic Scales
    pentatonicMajor: [0, 2, 4, 7, 9],
    pentatonicMinor: [0, 3, 5, 7, 10],
    
    // Blues Scales
    blues: [0, 3, 5, 6, 7, 10],
    majorBlues: [0, 2, 3, 4, 7, 9],
    
    // Additional Modern Jazz Scales
    altered: [0, 1, 3, 4, 6, 8, 10],
    halfWhole: [0, 1, 3, 4, 6, 7, 9, 10],
    harmonicMajor: [0, 2, 4, 5, 7, 8, 11],
    doubleHarmonic: [0, 1, 4, 5, 7, 8, 11],

    'enigmatic': [0, 1, 4, 6, 8, 10, 11],
    'persian': [0, 1, 4, 5, 6, 8, 11],
    'arabic': [0, 2, 4, 5, 6, 8, 10],
    'japanese': [0, 2, 5, 7, 8],
    'egyptian': [0, 2, 5, 7, 10]
    
};

const TUNINGS = {
    standard: ['E', 'B', 'G', 'D', 'A', 'E'],  // Note the order change
    dropD: ['E', 'B', 'G', 'D', 'A', 'D'],
    openG: ['D', 'B', 'G', 'D', 'G', 'D'],
    DADGAD: ['D', 'A', 'G', 'D', 'A', 'D'],
    openE: ['E', 'B', 'E', 'Ab', 'B', 'E']
};

        
const DRUM_PATTERNS = {
    '2': { kick: [1, 0], snare: [0, 1], hihat: [1, 1] },
    '3': { kick: [1, 0, 0], snare: [0, 1, 0], hihat: [1, 1, 1] },
    '4': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '6': { kick: [1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1] },
    '7': { kick: [1, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1] },
    '8': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '12': { kick: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }
};
    let currentDrumSetIndex = 0;
    const drumSoundSets = [
    {
        name: "Drums",
        snare: "Snare.wav",
        hihat: "HiHat.wav",
        kick: "Kick.wav"
    },
    {
        name: "Makaya",
        snare: "Snare2.wav",
        hihat: "HiHat2.wav",
        kick: "Kick2.wav"
    },
    {
        name: "PhillyJoe",
        kick: 'jazzkick.wav',
        snare: 'jazzsnare.wav',
        hihat: 'jazzhat.wav'
    }
];

const progressions = {
    "i-v7": {
        displayName: "I-V7 Progression",
        defaultKey: "C",
        progression: ["Imaj7", "V7"],
        description: "A simple I-V7 progression, common in jazz standards."
    },
    "jazz-blues": {
        displayName: "Jazz Blues",
        defaultKey: "Bb",
        progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "IIm7", "V7", "I7", "V7"],
        description: "A standard 12-bar jazz blues progression."
    },
    "minor-blues": {
        displayName: "Minor Blues",
        defaultKey: "Am",
        progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"],
        description: "A 12-bar minor blues progression."
    },
    "rhythm-changes": {
        displayName: "Rhythm Changes",
        defaultKey: "Bb",
        progression: ["I6", "vim7", "iim7", "V7", "I6", "vim7", "iim7", "V7", "I6", "IV7", "I6", "I6", "iim7", "V7", "I6", "V7"],
        description: "Based on Gershwin's 'I Got Rhythm', a common jazz form."
    },
    "ii-v-i": {
        displayName: "ii-V-I Progression",
        defaultKey: "C",
        progression: ["iim7", "V7", "Imaj7", "Imaj7"],
        description: "A fundamental jazz progression."
    },
    "vi-ii-v-i": {
        displayName: "vi-ii-V-I Progression",
        defaultKey: "C",
        progression: ["vim7", "iim7", "V7", "Imaj7", "Imaj7"],
        description: "An extended ii-V-I with a vi minor start."
    },
    "minor-ii-v-i": {
        displayName: "Minor ii-V-I",
        defaultKey: "Am",
        progression: ["iim7b5", "V7b9", "im7", "im7"],
        description: "A minor key ii-V-I progression."
    },
    "dark-eyes": {
        displayName: "Dark Eyes",
        defaultKey: "Dm",
        progression: ["V7", "V7", "im7", "im7", "V7", "V7", "VI6", "VI6", "ivm6", "ivm6", "im7", "im7", "V7", "V7", "im7", "im7"],
        description: "A gypsy jazz progression from the folk song."
    },
    "ill-see-you-in-my-dreams": {
        displayName: "I'll See You in My Dreams",
        defaultKey: "F",
        progression: ["IV6", "IV6", "ivm6", "ivm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "iim7", "V7", "Imaj7"],
        description: "Progression from the jazz standard."
    },
    "rose-room": {
        displayName: "Rose Room",
        defaultKey: "Ab",
        progression: ["II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"],
        description: "Progression from the classic jazz tune."
    },
    "black-orpheus": {
        displayName: "Black Orpheus",
        defaultKey: "Am",
        progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"],
        description: "Bossa nova progression from the film."
    },
    "all-the-things-you-are": {
        displayName: "All the Things You Are",
        defaultKey: "Ab",
        progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"],
        description: "Complex progression from the jazz standard."
    },
    "all-of-me": {
        displayName: "All of Me",
        defaultKey: "C",
        progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IVmaj7", "ivm7", "Imaj7", "V7"],
        description: "Progression from the popular standard."
    },
    "stella-by-starlight": {
        displayName: "Stella by Starlight",
        defaultKey: "Bb",
        progression: ["iim7b5", "V7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "biiim7b5", "VI7b9", "iim7", "V7", "im7", "IV7", "IVmaj7", "V7"],
        description: "Complex progression from the jazz standard."
    },
    "autumn-leaves": {
        displayName: "Autumn Leaves",
        defaultKey: "Em",
        progression: ["ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "im7"],
        description: "Classic jazz standard progression."
    },
    "summertime": {
        displayName: "Summertime",
        defaultKey: "Am",
        progression: ["im7", "V7", "im7", "V7", "im7", "V7", "im7", "V7", "iv7", "im7", "V7", "im7", "iv7", "im7", "V7", "im7"],
        description: "Progression from Gershwin's opera."
    },
    "girl-from-ipanema": {
        displayName: "The Girl from Ipanema",
        defaultKey: "F",
        progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "#IVmaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7"],
        description: "Bossa nova classic."
    },
    "coltrane-changes": {
        displayName: "Coltrane Changes",
        defaultKey: "C",
        progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"],
        description: "John Coltrane's harmonic cycle."
    },
    "bird-blues": {
        displayName: "Bird Blues",
        defaultKey: "F",
        progression: ["I7", "IV7", "I7", "vim7", "iim7", "V7", "IV7", "ivm7", "I7", "vim7", "iim7", "V7"],
        description: "Charlie Parker's blues variation."
    },
    "just-friends": {
        displayName: "Just Friends",
        defaultKey: "G",
        progression: ["Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7"],
        description: "Upbeat jazz standard."
    },
    "blue-bossa": {
        displayName: "Blue Bossa",
        defaultKey: "Cm",
        progression: ["im7", "im7", "bVII7", "bVII7", "im7", "im7", "ivm7", "bVII7", "im7", "V7", "im7", "im7"],
        description: "Bossa nova with a minor feel."
    },
    "on-green-dolphin-street": {
        displayName: "On Green Dolphin Street",
        defaultKey: "C",
        progression: ["Imaj7", "bIII7", "bVImaj7", "iim7", "V7", "Imaj7", "bIII7", "bVImaj7", "iim7", "V7", "Imaj7"],
        description: "Jazz standard with modal shifts."
    },
    "solar": {
        displayName: "Solar",
        defaultKey: "C",
        progression: ["im7", "im7", "bIIImaj7", "bIIImaj7", "bVImaj7", "bVImaj7", "bII7", "bII7", "im7", "im7"],
        description: "Miles Davis' moody standard."
    },
    "misty": {
        displayName: "Misty",
        defaultKey: "Eb",
        progression: ["Imaj7", "I7", "IVmaj7", "ivm7", "Imaj7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7"],
        description: "Erroll Garner's romantic ballad."
    },
    "days-of-wine-and-roses": {
        displayName: "Days of Wine and Roses",
        defaultKey: "F",
        progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7"],
        description: "Henry Mancini's jazz standard."
    },
    "cherokee": {
        displayName: "Cherokee",
        defaultKey: "Bb",
        progression: ["Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7", "bVI7", "bVI7", "V7", "V7", "Imaj7", "Imaj7", "iim7", "V7"],
        description: "Fast-paced Ray Noble standard."
    },
    "caravan": {
        displayName: "Caravan",
        defaultKey: "Eb",
        progression: ["im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "bVII7", "bVII7", "Imaj7", "Imaj7", "V7", "V7", "im7", "im7"],
        description: "Exotic Duke Ellington tune."
    },
    "nows-the-time": {
        displayName: "Now's the Time",
        defaultKey: "F",
        progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "V7", "IV7", "I7", "I7"],
        description: "Charlie Parker's blues."
    },
    "tenor-madness": {
        displayName: "Tenor Madness",
        defaultKey: "Bb",
        progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "iim7", "V7", "I7", "I7"],
        description: "Sonny Rollins' bluesy standard."
    }
};
        
const scaleDegrees = {
    major: {
        // Basic triads (uppercase = major, lowercase = minor)
        'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11,
        'i': 0, 'ii': 2, 'iii': 4, 'iv': 5, 'v': 7, 'vi': 9, 'vii': 11,
        
        // Seventh chords
        'I7': 0, 'II7': 2, 'III7': 4, 'IV7': 5, 'V7': 7, 'VI7': 9, 'VII7': 11,
        'i7': 0, 'ii7': 2, 'iii7': 4, 'iv7': 5, 'v7': 7, 'vi7': 9, 'vii7': 11,
        'Im7': 0, 'IIm7': 2, 'IIIm7': 4, 'IVm7': 5, 'Vm7': 7, 'VIm7': 9, 'VIIm7': 11,
        'Imaj7': 0, 'IImaj7': 2, 'IIImaj7': 4, 'IVmaj7': 5, 'Vmaj7': 7, 'VImaj7': 9, 'VIImaj7': 11,
        
        // Extended and altered chords
        'I9': 0, 'II9': 2, 'III9': 4, 'IV9': 5, 'V9': 7, 'VI9': 9, 'VII9': 11,
        'I13': 0, 'II13': 2, 'III13': 4, 'IV13': 5, 'V13': 7, 'VI13': 9, 'VII13': 11,
        'V7b9': 7, 'V7#9': 7, 'V7b13': 7, 'V7#11': 7,
        
        // Diminished and half-diminished
        'vii°': 11, 'ii°': 2, 'iii°': 4,
        'vii∅7': 11, 'ii∅7': 2, 'iii∅7': 4,
        
        // Flat/borrowed chords
        'bII': 1, 'bIII': 3, 'bV': 6, 'bVI': 8, 'bVII': 10,
        'bII7': 1, 'bIII7': 3, 'bV7': 6, 'bVI7': 8, 'bVII7': 10,
        'bIImaj7': 1, 'bIIImaj7': 3, 'bVmaj7': 6, 'bVImaj7': 8, 'bVIImaj7': 10
    },
    minor: {
        // Basic triads
        'i': 0, 'ii': 2, 'III': 3, 'iv': 5, 'v': 7, 'VI': 8, 'VII': 10,
        'i°': 0, 'ii°': 2, 'III+': 3, 'iv°': 5, 'v°': 7, 'VI+': 8, 'vii°': 11,
        
        // Seventh chords
        'i7': 0, 'ii7': 2, 'III7': 3, 'iv7': 5, 'v7': 7, 'VI7': 8, 'VII7': 10,
        'im7': 0, 'iim7': 2, 'IIIm7': 3, 'ivm7': 5, 'vm7': 7, 'VIm7': 8, 'VIIm7': 10,
        'imaj7': 0, 'iimaj7': 2, 'IIImaj7': 3, 'ivmaj7': 5, 'vmaj7': 7, 'VImaj7': 8, 'VIImaj7': 10,
        
        // Half-diminished and diminished sevenths
        'iø7': 0, 'iiø7': 2, 'IIIø7': 3, 'ivø7': 5, 'vø7': 7, 'VIø7': 8, 'VIIø7': 10,
        'i°7': 0, 'ii°7': 2, 'III°7': 3, 'iv°7': 5, 'v°7': 7, 'VI°7': 8, 'VII°7': 10,
        'iim7b5': 2, 'iiim7b5': 4, 'vim7b5': 9,
        
        // Extended and altered chords
        'i9': 0, 'ii9': 2, 'III9': 3, 'iv9': 5, 'v9': 7, 'VI9': 8, 'VII9': 10,
        'i13': 0, 'ii13': 2, 'III13': 3, 'iv13': 5, 'v13': 7, 'VI13': 8, 'VII13': 10,
        'V7b9': 7, 'V7#9': 7, 'V7b13': 7, 'V7#11': 7,
        
        // Borrowed/modal interchange chords
        'bII': 1, 'bIII': 3, 'bIV': 4, 'bV': 6, 'bVI': 8, 'bVII': 10,
        'bII7': 1, 'bIII7': 3, 'bIV7': 4, 'bV7': 6, 'bVI7': 8, 'bVII7': 10,
        'bIImaj7': 1, 'bIIImaj7': 3, 'bIVmaj7': 4, 'bVmaj7': 6, 'bVImaj7': 8, 'bVIImaj7': 10,
        
        // Common secondary dominants
        'V7/III': 7, 'V7/iv': 7, 'V7/v': 7, 'V7/VI': 7, 'V7/VII': 7,
        'V7/bIII': 7, 'V7/bVI': 7, 'V7/bVII': 7
    }
};   
// State Management
const AppState = {
            isPlaying: false,
            currentBeat: 0,
            currentMeasure: 0,
            tempo: 120,
            audioInitialized: false,
            darkMode: false,
            chordsEnabled: true,
            listeners: [],
            updateState(newState) {
                Object.assign(this, newState);
                this.notifyListeners();
            },
            addListener(callback) {
                this.listeners.push(callback);
            },
            notifyListeners() {
                this.listeners.forEach(callback => callback(this));
            }
        };

        // UI Management
        const UI = {
            elements: {
                chordFretboard: document.getElementById('chord-fretboard'),
                measures: document.getElementById('measures'),
                tempoDisplay: document.getElementById('tempo-display'),
                startStopButton: document.getElementById('start-stop'),
                progressionSelect: document.getElementById('progression-select'),
                keySelect: document.getElementById('keySelect'),
                scaleDisplay: document.getElementById('scale-display'),
                chordTuning: document.getElementById('chord-tuning'),
                timeSignature: document.getElementById('time-signature'),
                soundType: document.getElementById('sound-type'),
                metronomeVolume: document.getElementById('metronome-volume'),
                tempo: document.getElementById('tempo'),
                tapTempo: document.getElementById('tap-tempo'),
                chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
                chordVolume: document.getElementById('chord-volume'),
                chordsEnabled: document.getElementById('chordsEnabled'),
                fretboardsGrid: document.querySelector('.fretboards-grid'),
                darkModeToggle: document.getElementById('dark-mode-toggle'),
                accentIntensity: document.getElementById('accent-intensity'),
                drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
                reverbDial: document.getElementById('reverb-dial'),
                reverbDialValue: document.getElementById('reverb-dial-value'),
                addMeasureButton: document.querySelector('button[aria-label="Add measure"]'),
                removeMeasureButton: document.querySelector('button[aria-label="Remove measure"]')
            },
            init() {
                Object.entries(this.elements).forEach(([key, el]) => {
                    if (!el) console.warn(`Missing DOM element: ${key}`);
                });
                // Populate progression select
                Object.entries(progressions).forEach(([id, { displayName }]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = displayName;
                    this.elements.progressionSelect.appendChild(option);
                });
            }
        };
        
function initializeScaleSelects() {
    // Get all scale options
    const scaleOptions = Object.keys(SCALES).map(scale => {
        const displayName = scale
            .replace(/([A-Z])/g, ' $1') // Add space before capital letters
            .toLowerCase()
            .replace(/\b\w/g, c => c.toUpperCase()); // Capitalize first letter of each word
        return `<option value="${scale}">${displayName}</option>`;
    }).join('');

    // Update FretFlow scale select
    const fretflowScale = document.getElementById('fretflow-scale');
    if (fretflowScale) {
        fretflowScale.innerHTML = scaleOptions;
    }

    // Update all measure scale selects
    const measureScaleSelects = document.querySelectorAll('.scale-select');
    measureScaleSelects.forEach(select => {
        select.innerHTML = scaleOptions;
    });
}
        
// Audio Management
// Modified AudioContextManager
const AudioContextManager = {
    context: null,
    soundBuffers: {},
    pianoSampleBuffers: {},
    reverbNode: null,
    samplesLoaded: false,
    reverbAmount: 0.2,
    currentChordGain: null,

    initialize: async function() {
        if (!this.context) {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            await this.loadSounds();
            await this.loadPianoSamples();
            await this.setupReverb();
        }
        if (this.context.state === 'suspended') {
            await this.context.resume();
        }
        AppState.updateState({ audioInitialized: true });
        return this.context;
    },

    ensureAudioContext: async function() {
        return await this.initialize();
    },
    
    loadSounds: async function() {
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const progressContainer = document.getElementById('audio-loading-progress');
        progressContainer.style.display = 'block';

        const sounds = [
            'click.wav', 'woodblock.wav', 'Kick.wav', 'Snare.wav', 'HiHat.wav',
            'Kick2.wav', 'Snare2.wav', 'HiHat2.wav', 'jazzkick.wav', 'jazzsnare.wav', 'jazzhat.wav'
        ];
        const batchSize = 3;
        let loaded = 0;

        for (let i = 0; i < sounds.length; i += batchSize) {
            const batch = sounds.slice(i, i + batchSize);
            await Promise.all(batch.map(async sound => {
                const response = await fetch(`${sound}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[sound] = await this.context.decodeAudioData(arrayBuffer);
                loaded++;
                const progress = Math.round((loaded / sounds.length) * 100);
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;
            }));
        }

        progressContainer.style.display = 'none';
        this.samplesLoaded = true;
    },
    
    createDrumSound: async function(type) {
        const sampleRate = this.context.sampleRate;
        const duration = type === 'hihat' ? 0.05 : 0.2;
        const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
        const data = buffer.getChannelData(0);
        switch (type) {
            case 'click':
                for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
                break;
            case 'hihat':
                for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
                break;
            case 'kick':
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 100 * t) * Math.exp(-t * 10) * 2;
                }
                break;
            case 'snare':
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * t)) * Math.exp(-t * 10) * 2;
                }
                break;
            case 'woodblock':
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 20);
                }
                break;
        }
        return buffer;
    },
    
    loadPianoSamples: async function() {
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const progressContainer = document.getElementById('audio-loading-progress');
        progressContainer.style.display = 'block';

        const batchSize = 10;
        let loaded = 0;

        for (let i = 0; i < allSampleFiles.length; i += batchSize) {
            const batch = allSampleFiles.slice(i, i + batchSize);
            await Promise.all(batch.map(async file => {
                try {
                    const response = await fetch(`/${file}`);
                    const arrayBuffer = await response.arrayBuffer();
                    this.pianoSampleBuffers[file] = await this.context.decodeAudioData(arrayBuffer);
                    loaded++;
                    const progress = Math.round((loaded / allSampleFiles.length) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `${progress}%`;
                } catch (error) {
                    console.error(`Failed to load sample ${file}:`, error);
                }
            }));
        }

        progressContainer.style.display = 'none';
    },
    
    setupReverb: async function() {
        if (!this.reverbNode) {
            this.reverbNode = this.context.createConvolver();
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 2.5;
            const impulse = this.context.createBuffer(2, length, sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }
            }
            this.reverbNode.buffer = impulse;
            this.reverbNode.connect(this.context.destination);
        }
    }
};
async function ensureAudioInitialized() {
    try {
        if (!AudioContextManager.context || AudioContextManager.context.state === 'suspended') {
            await AudioContextManager.initialize();
            if (AudioContextManager.context.state === 'suspended') {
                await AudioContextManager.context.resume();
            }
        }
    } catch (error) {
        console.error('Audio initialization failed:', error);
        alert('Audio playback requires user interaction. Please click anywhere on the page to enable audio.');
        throw error;
    }
}

function getNoteFromScaleDegree(scaleDegree, key, scale = SCALES.major) {
    const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F',
                            'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // Normalize key (e.g., 'Db' -> 'C#')
    const ENHARMONIC_EQUIVALENTS = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' };
    key = ENHARMONIC_EQUIVALENTS[key] || key;

    const keyIndex = chromaticScale.indexOf(key);
    if (keyIndex === -1) return null;

    const offset = scaleDegree >= 0 ? scale[scaleDegree % scale.length] : 0;
    const noteIndex = (keyIndex + offset) % 12;
    return chromaticScale[noteIndex];
}


function standardizeNoteNameForSamples(note) {
    note = note.toLowerCase().replace('♯', '#').replace('♭', 'b');
    if (note.length === 2 && note[1] === 'b') {
        const flatToSharp = {
            'cb': 'b',
            'db': 'cs',
            'eb': 'ds',
            'fb': 'e',
            'gb': 'fs',
            'ab': 'gs',
            'bb': 'as'
        };
        return flatToSharp[note] || note[0];
    }
    if (note.length === 2 && note[1] === '#') {
        return note[0] + 's';
    }
    return note[0];
}
        
function parseChord(chord) {
    // Handle null or undefined input
    if (!chord) {
        console.error('Invalid chord input:', chord);
        return null;
    }

    // If chord is already an object with root and quality, return it
    if (typeof chord === 'object' && chord !== null && chord.root && chord.quality) {
        return chord;
    }

    // Ensure chord is a string
    if (typeof chord !== 'string') {
        console.error('Invalid chord input:', chord);
        return null;
    }

    // Rest of your existing parseChord function...
    chord = chord.trim();

    // Handle Roman numeral functional notation
    if (/^[IiVv]+/.test(chord)) {
        return parseRomanNumeralChord(chord);
    }

    // Regular expression for parsing chord symbols
    const chordRegex = /^([A-G][#b]?)([mM]|min|maj|dim|aug|sus[24]|[Mm]aj7|\+|-|[Mm]7|7|6|9|11|13)?$/;
    const match = chord.match(chordRegex);

    if (!match) {
        console.warn('Could not parse chord:', chord);
        return null;
    }

    const root = match[1];
    const quality = match[2] || '';

    return {
        root: root,
        quality: quality
    };
}

function parseRomanNumeralChord(chord) {
    // Roman numeral to scale degree mapping
    const romanToNumber = {
        'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7,
        'i': 1, 'ii': 2, 'iii': 3, 'iv': 4, 'v': 5, 'vi': 6, 'vii': 7
    };

    // Parse the Roman numeral part
   const romanRegex = /^(b?[IViv]+)(maj7|m7|m9|m13|m|maj|min|dim|aug|7|6|9|11|13|b9|#9|b13|#11)?$/;

    const match = chord.match(romanRegex);

    if (!match) {
        console.warn('Could not parse Roman numeral chord:', chord);
        return null;
    }

    let roman = match[1];
    const quality = match[2] || '';
    const isMinor = roman.toLowerCase() === roman;

    const hasFlatted = roman.startsWith('b');
    let scaleDegree = romanToNumber[hasFlatted ? roman.slice(1) : roman];

    if (hasFlatted) {
        scaleDegree = (scaleDegree - 1 + 7) % 7 + 1; // Flatten the scale degree
    }

    // Convert scale degree to root note based on current key
      const currentKey = typeof getCurrentKey === 'function' ? getCurrentKey() : 'C';
    const rootNote = getNoteFromScaleDegree(scaleDegree, currentKey);

    return {
        root: rootNote,
        quality: quality || (isMinor ? 'm' : '')
    };
}

// Helper function to get the current key
function getCurrentKey() {
    const keySelect = document.getElementById('keySelect');
    return keySelect ? keySelect.value : 'C';
}

function getChordFromFunction(roman, key = "C") {
    const romanMap = {
        "I": 0, "II": 2, "III": 4, "IV": 5, "V": 7, "VI": 9, "VII": 11,
        "i": 0, "ii": 2, "iii": 4, "iv": 5, "v": 7, "vi": 9, "vii": 11
    };
    const match = roman.match(/^([b#]?)([IViv]+)(.*)$/);
    if (!match) return null;
    let [, accidental, numeral, suffix] = match;
    let semitone = romanMap[numeral];
    if (accidental === "b") semitone -= 1;
    if (accidental === "#") semitone += 1;

    const keyNotes = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
    let keyIndex = keyNotes.indexOf(key);
    if (keyIndex === -1) keyIndex = 0;
    let rootIndex = (keyIndex + semitone + 12) % 12;
    let root = keyNotes[rootIndex];

    let isMinor = numeral === numeral.toLowerCase();
    let chordQuality;
    if (suffix.includes('maj7')) {
        chordQuality = 'maj7';
    } else if (suffix.includes('m7') || suffix.includes('min7')) {
        chordQuality = 'min7';
    } else if (suffix.includes('7')) {
        if (isMinor) {
            chordQuality = 'min7';
        } else {
            chordQuality = 'dom7';
        }
    } else if (suffix.includes('6')) {
        chordQuality = '6';
    } else {
        chordQuality = isMinor ? 'min' : 'maj';
    }

    return { root, quality: chordQuality };
}
        
// Helper function for flat notes
function flattenNote(note) {
    const sharpToFlat = {
        'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
    };
    return sharpToFlat[note] || note;
}

function getQualityValue(quality) {
    const qualityMap = {
        '': 'maj7',           // Default to maj7
        'maj': 'maj7',        // Major triad becomes maj7
        'maj7': 'maj7',       // Keep maj7
        '7': 'dom7',         // Dominant 7
        'dom7': 'dom7',      // Dominant 7
        'm': 'min7',         // Minor triad becomes min7
        'min': 'min7',       // Minor triad becomes min7
        'm7': 'min7',        // Minor 7
        'min7': 'min7',      // Minor 7
        'dim': 'min7b5',     // Diminished becomes half-diminished
        'min7b5': 'min7b5',  // Half-diminished
        '6': '6',            // Major 6
        'm6': 'm6'          // Minor 6
    };
    return qualityMap[quality] || 'maj7';  // Default to maj7 if not found
}
        
function suggestScaleForQuality(quality) {
    const scaleMap = {
        'maj7': 'major',      // Ionian
        'maj': 'major',       // Ionian
        '7': 'mixolydian',    // Mixolydian
        'dom7': 'mixolydian', // Mixolydian
        'min7': 'dorian',     // Dorian
        'm7': 'dorian',       // Dorian
        'min7b5': 'locrian',  // Locrian
        'min': 'minor',       // Natural minor
        'm': 'minor',         // Natural minor
        '6': 'major',         // Major
        'm6': 'minor',        // Minor
    };
    return scaleMap[quality] || 'major';
}

function getCompatibleScales(chord, quality) {
    return Object.keys(SCALES);
}

// DOM Utilities
function createKeyOptions(selected = 'C') {
    return NOTES.map(note =>
        `<option value="${note}"${note === selected ? ' selected' : ''}>${note}</option>`
    ).join('');
}

function createQualityOptions(selectedQuality) {
    const qualities = [
        { value: 'major', label: 'Major' },
        { value: 'minor', label: 'Minor' },
        { value: 'dom7', label: 'Dominant 7' },
        { value: 'min7', label: 'Minor 7' },
        { value: 'maj7', label: 'Major 7' },
        { value: 'min7b5', label: 'Minor 7b5' }
    ];
    return qualities
        .map(quality => 
            `<option value="${quality.value}" ${quality.value === selectedQuality ? 'selected' : ''}>${quality.label}</option>`
        )
        .join('');
}

function suggestScaleForQuality(quality) {
    const scaleMap = {
        major: 'major',
        minor: 'minor',
        dom7: 'mixolydian',
        min7: 'dorian',
        maj7: 'major',
        min7b5: 'locrian'
    };
    return scaleMap[quality] || 'major';
}

function updateChordProgression(measure) {
    const root = measure.querySelector('.root-note').value;
    const quality = measure.querySelector('.chord-quality').value;
    const secondKeySelect = measure.querySelector('.second-key');
    const scaleSelect = measure.querySelector('.scale-select');
    secondKeySelect.value = root;
    scaleSelect.value = suggestScaleForQuality(quality);
    log(`Updated chord progression for measure: ${root} ${quality}`);
}
function createScaleOptions(selected = 'major') {
    return Object.keys(SCALES).map(scale =>
        `<option value="${scale}"${scale === selected ? ' selected' : ''}>${scale.charAt(0).toUpperCase() + scale.slice(1)}</option>`
    ).join('');
}
       
// Audio Playback
function playNote(noteName, volume = 1.0, duration = 1000) {
    if (!AudioContextManager.context || !noteName) return;

    // Extract the pitch class and octave from the note name
    const match = noteName.match(/^([A-G][b#]?)(\d)$/i);
    if (!match) {
        console.warn(`Invalid note format: ${noteName}`);
        return;
    }

    let [, rawNote, octaveStr] = match;
    const baseNote = standardizeNoteName(rawNote).replace('m', '');
    const mappedNote = SAMPLE_NOTE_MAP[baseNote] || baseNote.toLowerCase();
    const octave = Math.max(2, Math.min(5, parseInt(octaveStr)));

    const sampleName = `${mappedNote}${octave}`;
    const buffer = AudioContextManager.pianoSampleBuffers[sampleName];

    if (!buffer) {
        console.warn(`No piano sample found for ${sampleName}`);
        return;
    }

    try {
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;

        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.value = volume;

        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);

        source.start(0);
        setTimeout(() => {
            try {
                source.stop();
            } catch (e) {
                // No-op on already stopped source
            }
        }, duration);
        log(`Played note: ${sampleName} at volume ${volume}`);
    } catch (error) {
        console.error('Error playing note:', error);
    }
}


async function playChord(root, quality, startTime = AudioContextManager.context.currentTime, duration = 2, isContinuation = false) {
    console.log("Playing chord:", root, quality); // Add this debug line
    await ensureAudioInitialized();

    const chordNotes = getChordNotes(root, quality);
    const chordVolume = parseFloat(UI.elements.chordVolume.value) * 0.7;
    if (chordVolume <= 0) return;

    // Create gain node for this chord
    const gainNode = AudioContextManager.context.createGain();
    gainNode.gain.value = chordVolume;
    gainNode.connect(AudioContextManager.context.destination);

    // Handle previous chord fadeout
    if (!isContinuation && AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(
            AudioContextManager.currentChordGain.gain.value, 
            startTime
        );
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(
            0.001, 
            startTime + 0.05
        );
    }

    AudioContextManager.currentChordGain = gainNode;

    // Generate random inversion (0 to length-1)
    const inversion = Math.floor(Math.random() * chordNotes.length);
    
    // Create voicing with random inversion
    let voicing = [...chordNotes];
    for (let i = 0; i < inversion; i++) {
        const note = voicing.shift();
        voicing.push(note);
    }

    // Additional voice leading for continuation
    if (isContinuation) {
        const rootNote = voicing.shift();
        voicing.push(rootNote);
    }

    // Play each note with slight timing and velocity variations
    voicing.forEach((note, index) => {
        // Determine octave based on position and inversion
        let octave;
        if (isContinuation) {
            octave = index === voicing.length - 1 ? 4 : 3;
        } else {
            // Adjust octave based on position in the chord and inversion
            const positionInChord = (index + inversion) % voicing.length;
            octave = positionInChord === 0 ? 3 : (positionInChord < 3 ? 3 : 4);
        }

        const sampleNote = standardizeNoteNameForSamples(note);
        const sampleKey = `${sampleNote}${octave}`;
        
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
        if (!buffer) {
            console.warn(`No sample found for ${sampleKey}`);
            return;
        }

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        
        // Create individual gain node for note velocity variation
        const noteGain = AudioContextManager.context.createGain();
        const velocityVariation = 0.85 + (Math.random() * 0.3); // Velocity varies between 85% and 115%
        noteGain.gain.value = velocityVariation;
        
        source.connect(noteGain);
        noteGain.connect(gainNode);

        // Add reverb
        const reverbGain = AudioContextManager.context.createGain();
        reverbGain.gain.value = AudioContextManager.reverbAmount;
        source.connect(reverbGain);
        reverbGain.connect(AudioContextManager.reverbNode);

        // Humanize timing with slightly larger variation range
        const timeVariation = Math.random() * 0.03; // Increased from 0.02 to 0.03
        source.start(startTime + timeVariation);
        source.stop(startTime + duration);
    });
} 
function getChordNotes(root, quality) {
    console.log("Getting notes for chord:", root, quality);
    // Enhanced chord intervals with more voicings
    const CHORD_INTERVALS = {
        'maj': [0, 4, 7],
        'min': [0, 3, 7],
        'dim': [0, 3, 6],
        'aug': [0, 4, 8],
        'sus4': [0, 5, 7],
        'sus2': [0, 2, 7],
        'maj7': [0, 4, 7, 11],
        'dom7': [0, 4, 7, 10],  // This should be used for C7
        'min7': [0, 3, 7, 10],
        'dim7': [0, 3, 6, 9],
        'm7b5': [0, 3, 6, 10],
        'aug7': [0, 4, 8, 10],
        'maj9': [0, 4, 7, 11, 14],
        'dom9': [0, 4, 7, 10, 14],
        'min9': [0, 3, 7, 10, 14],
        'maj7#11': [0, 4, 7, 11, 18],
        'dom7b9': [0, 4, 7, 10, 13],
        'dom7#9': [0, 4, 7, 10, 15],
        'dom7b13': [0, 4, 7, 10, 20],
        'min11': [0, 3, 7, 10, 14, 17]
    };

    // Get base intervals
    let intervals = CHORD_INTERVALS[quality] || CHORD_INTERVALS['maj'];
    console.log("Using intervals:", intervals);

    // Generate notes
    const rootIndex = NOTES.indexOf(standardizeNoteName(root));
    console.log("Root index:", rootIndex);
    
    if (rootIndex === -1) {
        console.error(`Invalid root note: ${root}`);
        return [root];
    }

    // Generate voicings with proper voice leading
    const voicing = intervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        const note = NOTES[noteIndex];
        console.log(`Interval ${interval} -> Note ${note}`);
        return note;
    });

    console.log("Final voicing:", voicing);
    return voicing;
}
        
async function playMetronomeSound(baseVolume) {
    if (!AudioContextManager.context) return;

    // Get the metronome volume slider value and combine it with base volume
    const metronomeVolumeControl = document.getElementById('metronome-volume');
    const metronomeVolume = parseFloat(metronomeVolumeControl.value);
    const combinedVolume = baseVolume * metronomeVolume;

    if (combinedVolume <= 0) return;

    const soundType = UI.elements.soundType.value;
    const beatElement = document.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);

    if (!beatElement) return;

    const drumSounds = beatElement.dataset.sound.split(',');
    const baseVolumeValue = parseFloat(beatElement.dataset.baseVolume) || 0;
    const isAccent = baseVolumeValue >= 1 && ['kick', 'snare'].includes(drumSounds[0]);
    const accentBoost = parseFloat(UI.elements.accentIntensity?.value || 1);

    // Apply accent boost if applicable
    let adjustedVolume = combinedVolume;
    if (isAccent) {
        adjustedVolume = Math.min(combinedVolume * accentBoost, 1); // cap at 1.0
    }

    // Process each sound in the drum pattern
    for (let soundKey of drumSounds) {
        soundKey = soundKey.trim();

        // Skip if it's a silent beat
        if (soundKey === 'silent') continue;

        // Get the current drum set if using drums
        const currentSet = drumSoundSets[currentDrumSetIndex];

        // Determine which sound buffer to use
        let buffer;
        if (soundType === 'drums' && soundKey !== 'default') {
            // Map drum sounds to current set's samples
            let sampleFile;
            switch(soundKey) {
                case 'kick': sampleFile = currentSet.kick; break;
                case 'snare': sampleFile = currentSet.snare; break;
                case 'hihat': sampleFile = currentSet.hihat; break;
                default: sampleFile = null;
            }

            if (sampleFile) {
                try {
                    // Try to load the current set's sample
                    const response = await fetch(`./${sampleFile}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    buffer = await AudioContextManager.context.decodeAudioData(arrayBuffer);
                } catch (error) {
                    console.error(`Failed to load drum sample: ${sampleFile}`, error);
                    // Fall back to default drum sounds if loading fails
                    buffer = AudioContextManager.soundBuffers[soundKey];
                }
            }
        } else {
            // Use click or woodblock sounds
            buffer = AudioContextManager.soundBuffers[soundType] || AudioContextManager.soundBuffers['click'];
        }

        if (!buffer) continue;

        // Create and configure audio nodes
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;

        const gainNode = AudioContextManager.context.createGain();

        // Adjust volume based on sound type and context
        let finalVolume = adjustedVolume;
        if (soundType === 'drums') {
            // Reduce hi-hat volume when playing with other sounds
            if (soundKey === 'hihat' && drumSounds.length > 1) {
                finalVolume *= 0.5;
            }
            // Adjust kick and snare volumes
            else if (soundKey === 'kick') {
                finalVolume *= 1.2; // Slightly boost kick
            }
            else if (soundKey === 'snare') {
                finalVolume *= 1.1; // Slightly boost snare
            }
        }

        // Ensure volume doesn't exceed 1.0
        finalVolume = Math.min(finalVolume, 1.0);
        gainNode.gain.value = finalVolume;

        // Connect the audio nodes
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);

        // Add slight reverb for drums
        if (soundType === 'drums' && AudioContextManager.reverbNode) {
            const reverbGain = AudioContextManager.context.createGain();
            reverbGain.gain.value = 0.1; // Subtle reverb
            source.connect(reverbGain);
            reverbGain.connect(AudioContextManager.reverbNode);
        }

        // Start the sound
        try {
            source.start(0);
        } catch (error) {
            console.error('Error playing metronome sound:', error);
        }
    }
}
function onMetronomeInstrumentChange(selectedInstrument) {
  if (selectedInstrument === "drums") {
    document.getElementById("drumSetToggleBtn").style.display = "inline-block";
  } else {
    document.getElementById("drumSetToggleBtn").style.display = "none";
  }
}

async function playDrumSample(type) {
    if (!AudioContextManager.context) return;
    
    const set = drumSoundSets[currentDrumSetIndex];
    let sampleFile;
    
    // Map the type to the current set's sample file
    switch(type) {
    case 'snare': sampleFile = set.snare; break;
    case 'hihat': sampleFile = set.hihat; break;
    case 'kick': sampleFile = set.kick; break;
    default: sampleFile = null;
    }
    
    try {
        let buffer;
        // Try to load the current set's sample
        const response = await fetch(`./${sampleFile}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        buffer = await AudioContextManager.context.decodeAudioData(arrayBuffer);
        
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        
        const gainNode = AudioContextManager.context.createGain();
        // Get the metronome volume
        const metronomeVolume = parseFloat(UI.elements.metronomeVolume.value);
        
        // Apply sound-specific volume adjustments
        let finalVolume = metronomeVolume;
        if (type === 'kick') {
            finalVolume *= 1.2; // Slightly boost kick
        } else if (type === 'snare') {
            finalVolume *= 1.1; // Slightly boost snare
        } else if (type === 'hihat') {
            finalVolume *= 0.8; // Slightly reduce hihat
        }
        
        // Ensure volume doesn't exceed 1.0
        finalVolume = Math.min(finalVolume, 1.0);
        gainNode.gain.value = finalVolume;
        
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);
        
        // Add slight reverb for more depth
        if (AudioContextManager.reverbNode) {
            const reverbGain = AudioContextManager.context.createGain();
            reverbGain.gain.value = 0.1; // Subtle reverb
            source.connect(reverbGain);
            reverbGain.connect(AudioContextManager.reverbNode);
        }
        
        source.start(0);
    } catch (error) {
        console.error(`Failed to play drum sample: ${type}`, error);
        try {
            // Fall back to default drum sounds if loading fails
            const fallbackBuffer = AudioContextManager.soundBuffers[type] || 
                await AudioContextManager.createDrumSound(type);
            const source = AudioContextManager.context.createBufferSource();
            source.buffer = fallbackBuffer;
            
            const gainNode = AudioContextManager.context.createGain();
            gainNode.gain.value = parseFloat(UI.elements.metronomeVolume.value);
            
            source.connect(gainNode);
            gainNode.connect(AudioContextManager.context.destination);
            
            source.start(0);
        } catch (fallbackError) {
            console.error('Failed to play fallback sound:', fallbackError);
        }
    }
}
        
function createFretboard(container, tuning) {
    container.innerHTML = '';

    // Create fret lines and fret numbers
    for (let i = 0; i <= 12; i++) {
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / 12) * 100}%`;
        container.appendChild(fretLine);

        if (i > 0) { // Add fret numbers for frets 1-12
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            fretNumber.style.left = `${((i - 0.5) / 12) * 100}%`;
            container.appendChild(fretNumber);
        }
    }

    // Create string lines
    for (let i = 0; i < 6; i++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        stringLine.style.top = `${(i / 5) * 100}%`;
        container.appendChild(stringLine);
    }

    // Add fret markers (dots)
    const markerPositions = [3, 5, 7, 9, 12]; // Frets with markers
    markerPositions.forEach(position => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((position - 0.5) / 12) * 100}%`;

        if (position === 12) {
            // Double markers at the 12th fret
            const topMarker = marker.cloneNode(true);
            topMarker.style.top = '25%';
            container.appendChild(topMarker);

            const bottomMarker = marker.cloneNode(true);
            bottomMarker.style.top = '75%';
            container.appendChild(bottomMarker);
        } else {
            // Single marker
            marker.style.top = '50%';
            container.appendChild(marker);
        }
    });
}
        
function updateFretboardNotes(container, rootNote, scale, tuning) {
    if (!(container instanceof HTMLElement)) {
        console.error('Invalid container element');
        return;
    }
    if (!NOTES.includes(standardizeNoteName(rootNote))) {
        console.error(`Invalid root note: ${rootNote}`);
        return;
    }
    if (!SCALES[scale]) {
        console.error(`Invalid scale: ${scale}`);
        return;
    }
    if (!Array.isArray(tuning) || tuning.length !== 6) {
        console.error('Invalid tuning');
        return;
    }
    container.querySelectorAll('.note').forEach(note => note.remove());
    if (container.id === 'chord-fretboard') {
        const measures = UI.elements.measures.children;
        if (measures.length > 0 && AppState.currentMeasure < measures.length) {
            const currentMeasureElement = measures[AppState.currentMeasure];
            const chordRoot = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const chordQuality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            if (chordRoot && chordQuality && scaleRoot && scaleType) {
                let displayQuality = chordQuality;
                switch (chordQuality) {
                    case 'dom7': displayQuality = '7'; break;
                    case 'maj7': displayQuality = 'Maj7'; break;
                    case 'min7': displayQuality = 'm7'; break;
                    case 'min7b5': displayQuality = 'm7b5'; break;
                    case 'minor': displayQuality = 'm'; break;
                }
                let displayScale = scaleType.charAt(0).toUpperCase() + scaleType.slice(1);
                displayScale = displayScale.replace(/([A-Z])/g, ' $1').trim();
                UI.elements.scaleDisplay.textContent = `${scaleRoot} ${displayScale} over ${chordRoot} ${displayQuality}`;
            }
        }
    }
    const scaleIntervals = SCALES[scale];
    const standardizedRoot = standardizeNoteName(rootNote);
    const rootIndex = NOTES.indexOf(standardizedRoot);
    const scaleNotes = scaleIntervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        return NOTES[noteIndex];
    });
    console.log(`[updateFretboardNotes] scaleNotes for ${rootNote} ${scale}: ${scaleNotes.join(',')}`);
    for (let string = 0; string < 6; string++) {
        const openNote = tuning[string];
        const openNoteIndex = NOTES.indexOf(openNote);
        for (let fret = 0; fret <= 12; fret++) {
            const noteIndex = (openNoteIndex + fret) % 12;
            const currentNote = NOTES[noteIndex];
            if (scaleNotes.includes(currentNote)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNote;
                const fretOffset = fret === 0 ? 0 : ((fret - 0.5) / 12) * 100;
                noteElement.style.left = `${fretOffset}%`;
                noteElement.style.top = `${(string / 5) * 100}%`;
                const degree = scaleNotes.indexOf(currentNote);
                if (currentNote === standardizedRoot) {
                    noteElement.style.backgroundColor = '#BD2031';
                } else if ([2, 4, 6].includes(degree)) {
                    noteElement.style.backgroundColor = '#006400';
                } else {
                    noteElement.style.backgroundColor = '#4CAF50';
                }
                noteElement.dataset.note = `${currentNote}${fret === 0 ? 3 : 4}`; // Bb3, C4, etc.
                noteElement.addEventListener('click', async () => {
                    try {
                        await AudioContextManager.ensureAudioContext();
                        const noteName = noteElement.dataset.note;
                        playNote(noteName, 0.7, 500);
                        noteElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                        setTimeout(() => {
                            noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                        }, 100);
                    } catch (error) {
                        console.error('Error playing note:', error);
                    }
                });
                noteElement.addEventListener('mouseenter', () => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.1)';
                });
                noteElement.addEventListener('mouseleave', () => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                });
                container.appendChild(noteElement);
            }
        }
    }
    log(`Fretboard updated with ${rootNote} ${scale} scale`);
}
        
function createBeats() {
    const container = document.querySelector('.beats-container');
    container.innerHTML = '';

    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value;

    let totalBeats = timeSignature === 4 ? 8 : timeSignature; // 8 beats for 4/4 time (eighth notes)

    const beatConfigs = {
        4: { 
            strongBeats: [0, 4], 
            drumSounds: { 
                0: { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D' },
                2: { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50' },
                4: { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D' },
                6: { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50' }
            }
        },
        3: { strongBeats: [0, 3, 6] },
        6: { strongBeats: [0, 3] },
        7: { strongBeats: [0, 4] },
        8: { strongBeats: [0, 4] },
        12: {
            strongBeats: [0, 4, 6, 10],
            drumSounds: { 0: 'kick', 4: 'snare', 6: 'kick', 10: 'snare' }
        }
    };

    const config = beatConfigs[timeSignature] || { strongBeats: [0] };

    for (let i = 0; i < totalBeats; i++) {
        const beat = document.createElement('div');
        beat.className = 'beat';
        beat.dataset.beat = i;

        if (timeSignature === 4) {
            const isQuarterNote = i % 2 === 0;
            beat.textContent = `${Math.floor(i / 2 + 1)}${isQuarterNote ? '' : '&'}`;

            if (soundType === 'drums') {
                // Set default hi-hat for all beats
                let volume = '0.7';
                let sound = 'hihat';
                let color = '#9E9E9E';

                // Check if this beat should also have kick or snare
                const drumConfig = config.drumSounds[i];
                if (drumConfig) {
                    sound = drumConfig.sound;  // This will be an array ['kick', 'hihat'] or ['snare', 'hihat']
                    volume = drumConfig.volume;
                    color = drumConfig.color;
                }

                beat.dataset.baseVolume = volume;
                beat.dataset.volume = volume;
                beat.dataset.sound = Array.isArray(sound) ? sound.join(',') : sound;
                beat.style.backgroundColor = color;
            } else {
                // For click and woodblock, only play on quarter notes
                if (isQuarterNote) {
                    beat.dataset.sound = soundType;
                    beat.dataset.baseVolume = i === 0 ? '1' : '0.3';
                    beat.dataset.volume = i === 0 ? '1' : '0.3';
                    beat.style.backgroundColor = i === 0 ? '#1F618D' : '#4CAF50';
                } else {
                    beat.dataset.sound = 'silent';
                    beat.dataset.baseVolume = '0';
                    beat.dataset.volume = '0';
                    beat.style.backgroundColor = '#9E9E9E';
                }
            }
        } else {
            beat.textContent = i + 1;
            const isStrong = config.strongBeats.includes(i);

            if (soundType === 'drums') {
                beat.dataset.sound = isStrong ? 'kick' : 'hihat';
                beat.dataset.baseVolume = '1';
                beat.dataset.volume = '1';
                beat.style.backgroundColor = isStrong ? '#1F618D' : '#9E9E9E';
            } else {
                beat.dataset.sound = soundType;
                beat.dataset.baseVolume = isStrong ? '1' : '0.3';
                beat.dataset.volume = isStrong ? '1' : '0.3';
                beat.style.backgroundColor = isStrong ? '#1F618D' : '#4CAF50';
            }
        }

        beat.addEventListener('click', () => toggleBeatState(beat, timeSignature, soundType));
        container.appendChild(beat);
    }
}
        
function toggleBeatState(beat, timeSignature, soundType) {
    const isEighth = timeSignature === 4 && parseInt(beat.dataset.beat) % 2 === 1;
    const states = soundType === 'drums' && timeSignature === 4 ? (
        isEighth ? [
            { volume: '1', sound: 'hihat', color: '#9E9E9E' },
            { volume: '1', sound: 'kick', color: '#1F618D' },
            { volume: '1', sound: 'snare', color: '#4CAF50' },
            { volume: '0', sound: 'silent', color: '#6666' }
        ] : [
            { volume: '1', sound: 'kick', color: '#1F618D' },
            { volume: '1', sound: 'snare', color: '#4CAF50' },
            { volume: '1', sound: 'hihat', color: '#9E9E9E' },
            { volume: '0', sound: 'silent', color: '#6666' }
        ]
    ) : [
        { volume: '1', sound: 'default', color: '#1F618D' },
        { volume: '0.3', sound: 'default', color: '#4CAF50' },
        { volume: '0', sound: 'default', color: '#9E9E9E' }
    ];
    const currentIndex = states.findIndex(state =>
        state.volume === beat.dataset.volume && state.sound === beat.dataset.sound
    );
    const nextState = states[(currentIndex + 1) % states.length];
    beat.dataset.volume = nextState.volume;
    beat.dataset.sound = nextState.sound;
    beat.style.backgroundColor = nextState.color;
}

async function playBeat() {
            const beats = document.querySelectorAll('.beat');
            const currentBeatElement = beats[AppState.currentBeat];
            if (currentBeatElement) {
                currentBeatElement.classList.add('active');
                const volume = parseFloat(currentBeatElement.dataset.volume) || 0;
                await playMetronomeSound(volume);
            }
            const measures = UI.elements.measures.children;
            const timeSignature = parseInt(UI.elements.timeSignature.value);
            if (measures.length > 0) {
                const currentMeasureElement = measures[AppState.currentMeasure];
                if (currentMeasureElement) {
                    const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
                    const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
                    const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
                    const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
                    if (root && quality && scaleRoot && scaleType) {
                        const chordTuning = TUNINGS[UI.elements.chordTuning.value];
                        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);
                        const beatDuration = 60 / AppState.tempo;
                        if (AppState.chordsEnabled) { // Check chordsEnabled
                            if (timeSignature === 4) {
                                if (AppState.currentBeat === 0) {
                                    playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 2, false);
                                } else if (AppState.currentBeat === 4) {
                                    playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 2, true);
                                }
                            } else if (AppState.currentBeat === 0) {
                                playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 4, false);
                            }
                        }
                    }
                }
            }
            if (measures.length > 0) {
                Array.from(measures).forEach((measure, index) => {
                    measure.classList.toggle('active', index === AppState.currentMeasure);
                });
            }
            const totalBeats = timeSignature === 4 ? 8 : timeSignature;
            AppState.currentBeat = (AppState.currentBeat + 1) % totalBeats;
            if (AppState.currentBeat === 0 && measures.length > 0) {
                AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
            }
            AppState.updateState({ currentBeat: AppState.currentBeat, currentMeasure: AppState.currentMeasure });
        }

async function startPlayback() {
    try {
        await ensureAudioInitialized();
        
        if (AppState.isPlaying) return;
        
        const timeSignature = parseInt(UI.elements.timeSignature.value);
        const measures = UI.elements.measures.children;
        
        if (measures.length === 0) {
            console.warn('No measures defined. Please add at least one measure.');
            return;
        }
        
        let interval = (60 / AppState.tempo) * 1000;
        if (timeSignature === 4) {
            interval = interval / 2;
        }
        
        AppState.updateState({ currentBeat: 0, currentMeasure: 0 });
        clearInterval(AppState.intervalId);
        
        const currentMeasureElement = measures[AppState.currentMeasure];
        if (currentMeasureElement) {
            const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            
            if (root && quality && scaleRoot && scaleType) {
                const chordTuning = TUNINGS[UI.elements.chordTuning.value];
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);
                
                try {
                    await playChord(root, quality);
                } catch (error) {
                    console.error('Failed to play initial chord:', error);
                }
            }
        }
        
        AppState.intervalId = setInterval(playBeat, interval);
        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started");
        
    } catch (error) {
        console.error('Failed to start playback:', error);
        alert('Please try clicking the start button again');
        stopPlayback(); // Ensure everything is reset if playback fails
        UI.elements.startStopButton.textContent = 'Start';
    }
}

function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false, currentBeat: 0, currentMeasure: 0 });
    const beats = document.querySelectorAll('.beat');
    beats.forEach(beat => beat.classList.remove('active'));
    const measures = UI.elements.measures.children;
    Array.from(measures).forEach(measure => measure.classList.remove('active'));
    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, AudioContextManager.context.currentTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, AudioContextManager.context.currentTime + 0.1);
        AudioContextManager.currentChordGain = null;
    }
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped");
}

        // Helper Functions for Chord and Scale Controls
        function createKeyOptions(selectedNote) {
            return NOTES.map(note => 
                `<option value="${note}" ${note === selectedNote ? 'selected' : ''}>${note}</option>`
            ).join('');
        }


        // Load Progression
        function loadProgression(progressionName, overrideKey = null) {
            if (!progressionName || !progressions[progressionName]) {
                console.error(`Invalid progression name: ${progressionName}`);
                return;
            }

            try {
                const progression = progressions[progressionName];
                const selectedKey = overrideKey || progression.defaultKey || "C";

                // Update UI key selection
                if (UI.elements.keySelect) {
                    UI.elements.keySelect.value = selectedKey;
                } else {
                    console.warn('keySelect element not found');
                }

                // Clear existing measures
                if (UI.elements.measures) {
                    UI.elements.measures.innerHTML = '';
                } else {
                    console.warn('measures element not found');
                }

                let firstChord = null;
                progression.progression.forEach((chordFunction, index) => {
                    // Get chord using getChordFromFunction
                    const chord = getChordFromFunction(chordFunction, selectedKey);
                    if (!chord) {
                        console.warn(`Failed to parse chord: ${chordFunction} in key ${selectedKey}`);
                        return;
                    }

                    // Store first chord for fretboard update
                    if (index === 0) {
                        firstChord = chord;
                    }

                    // Create measure
                    const measure = document.createElement('div');
                    measure.className = 'measure';

                    // Chord controls
                    const chordControls = document.createElement('div');
                    chordControls.className = 'chord-controls';

                    const rootSelect = document.createElement('select');
                    rootSelect.className = 'root-note';
                    rootSelect.innerHTML = createKeyOptions(chord.root);

                    const qualitySelect = document.createElement('select');
                    qualitySelect.className = 'chord-quality';
                    qualitySelect.innerHTML = createQualityOptions(chord.quality);

                    chordControls.appendChild(rootSelect);
                    chordControls.appendChild(qualitySelect);
                    measure.appendChild(chordControls);

                    // Scale controls
                    const scaleControls = document.createElement('div');
                    scaleControls.className = 'scale-controls';

                    const scaleRootSelect = document.createElement('select');
                    scaleRootSelect.className = 'second-key';
                    scaleRootSelect.innerHTML = createKeyOptions(chord.root);

                    const scaleSelect = document.createElement('select');
                    scaleSelect.className = 'scale-select';
                    const suggestedScale = suggestScaleForQuality(chord.quality);
                    scaleSelect.innerHTML = createScaleOptions(suggestedScale);

                    scaleControls.appendChild(scaleRootSelect);
                    scaleControls.appendChild(scaleSelect);
                    measure.appendChild(scaleControls);

                    UI.elements.measures.appendChild(measure);
                });

                // Update fretboard with first chord
                if (UI.elements.chordFretboard && firstChord) {
                    const tuning = TUNINGS[UI.elements.chordTuning?.value || 'standard'];
                    const scaleType = suggestScaleForQuality(firstChord.quality);
                    updateFretboardNotes(UI.elements.chordFretboard, firstChord.root, scaleType, tuning);
                } else if (!UI.elements.chordFretboard) {
                    console.warn('chordFretboard element not found');
                }

                log(`Loaded progression ${progression.displayName || progressionName} in key ${selectedKey}`);
            } catch (error) {
                console.error(`Error loading progression ${progressionName}:`, error);
            }
        }
        
// Add this new helper function to parse chord functions
function parseChordFunction(chordFunction, key) {
    // Remove any whitespace
    chordFunction = chordFunction.trim();
    
    // Initialize variables for root note and quality
    let root = key;
    let quality = 'maj7';

    // Parse the chord function
    if (chordFunction.includes('7')) {
        if (chordFunction.startsWith('I')) quality = 'dom7';
        else if (chordFunction.startsWith('V')) quality = 'dom7';
        else if (chordFunction.startsWith('IV')) quality = 'dom7';
        else if (chordFunction.toLowerCase().includes('m7b5')) quality = 'min7b5';
        else if (chordFunction.toLowerCase().includes('m7')) quality = 'min7';
        else quality = 'dom7';
    }

    // Calculate the root note based on the function
    const degree = getRomanNumeralDegree(chordFunction);
    if (degree !== null) {
        root = calculateRootFromDegree(key, degree);
    }

    return { root, quality };
}

// Add these helper functions
function getRomanNumeralDegree(chordFunction) {
    const romanNumerals = {
        'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11,
        'i': 0, 'ii': 2, 'iii': 4, 'iv': 5, 'v': 7, 'vi': 9, 'vii': 11
    };
    
    // Extract the roman numeral part
    const match = chordFunction.match(/^(b?)([IViv]+)/);
    if (!match) return null;
    
    const [, flat, numeral] = match;
    let degree = romanNumerals[numeral];
    
    if (flat === 'b') {
        degree = (degree - 1 + 12) % 12;
    }
    
    return degree;
}

function calculateRootFromDegree(key, degree) {
    const chromaticScale = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const keyIndex = chromaticScale.indexOf(standardizeNoteName(key));
    const rootIndex = (keyIndex + degree) % 12;
    return chromaticScale[rootIndex];
}

// Helper function to add a measure with a chord
function addMeasureWithChord(parsedChord, index) {
    const root = parsedChord.root;
    const quality = parsedChord.quality;
    const qualityValue = getQualityValue(quality);
    const suggestedScale = suggestScaleForQuality(quality);

    const measure = document.createElement('div');
    measure.className = 'measure';
    measure.draggable = true;
    measure.innerHTML = `
        <span class="measure-number">${index + 1}</span>
        <div class="chord-controls">
            <select class="root-note">${createKeyOptions(root)}</select>
            <select class="chord-quality">${createQualityOptions(qualityValue)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key">${createKeyOptions(root)}</select>
            <select class="scale-select">${createScaleOptions(suggestedScale)}</select>
        </div>
    `;

    UI.elements.measures.appendChild(measure);
    setupMeasureEventListeners(measure);
}
function updateProgressionKey(newKey) {
    const selectedProgression = UI.elements.progressionSelect.value;
    if (!selectedProgression) return;
    const progression = progressions[selectedProgression];
    if (!progression) return;
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const chordFunc = progression.progression[index];
        if (!chordFunc) return;
        const chord = getChordFromFunction(chordFunc, newKey);
        const {root, quality} = chord;
        const rootSelect = measure.querySelector('.root-note');
        const qualitySelect = measure.querySelector('.chord-quality');
        const secondKeySelect = measure.querySelector('.second-key');
        const scaleSelect = measure.querySelector('.scale-select');
        if (rootSelect) rootSelect.value = standardizeNoteName(root);
        if (qualitySelect) qualitySelect.value = getQualityValue(quality);
        if (secondKeySelect) secondKeySelect.value = standardizeNoteName(root);
        if (scaleSelect) scaleSelect.value = suggestScaleForQuality(getQualityValue(quality));
    });
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key').value;
        const scaleType = firstMeasure.querySelector('.scale-select').value;
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }
    log(`Progression updated to key: ${newKey}`);
}

function addMeasure(chord = 'C', quality = 'major', scaleRoot = 'C', scaleType = 'major') {
    const measure = document.createElement('div');
    measure.className = 'measure';
    measure.draggable = true;
    const measureCount = UI.elements.measures.children.length + 1;
    
    // Create scale options from all available scales
    const scaleOptionsHtml = Object.keys(SCALES).map(scale => {
        const selected = scale === scaleType ? 'selected' : '';
        return `<option value="${scale}" ${selected}>${scale}</option>`;
    }).join('');

    measure.innerHTML = `
        <span class="measure-number">${measureCount}</span>
        <div class="chord-controls">
            <select class="root-note">${createKeyOptions(chord)}</select>
            <select class="chord-quality">${createQualityOptions(quality)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key">${createKeyOptions(scaleRoot)}</select>
            <select class="scale-select">${scaleOptionsHtml}</select>
        </div>
    `;
    
    UI.elements.measures.appendChild(measure);
    
    // Add event listeners
    measure.addEventListener('dragstart', dragStart);
    measure.addEventListener('dragover', dragOver);
    measure.addEventListener('drop', drop);
    measure.addEventListener('dragend', dragEnd);
    
    // Add change listeners for controls
    const controls = measure.querySelectorAll('select');
    controls.forEach(control => {
        control.addEventListener('change', () => updateChordProgression(measure));
    });
    
    updateMeasureNumbers();
    log(`Added measure ${measureCount}`);
}
function removeMeasure() {
    const measures = UI.elements.measures.children;
    if (measures.length > 0) {
        measures[measures.length - 1].remove();
        updateMeasureNumbers();
        log(`Removed last measure`);
    }
}
        
function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const number = measure.querySelector('.measure-number');
        if (number) {
            number.textContent = index + 1;
        } else {
            console.warn(`Measure number element not found in measure ${index}`);
        }
    });
}

// Drag and Drop Handlers
function dragStart(e) {
    e.dataTransfer.setData('text/plain', Array.from(UI.elements.measures.children).indexOf(e.target));
    setTimeout(() => e.target.classList.add('dragging'), 0);
}

function dragOver(e) {
    e.preventDefault();
}

function drop(e) {
    e.preventDefault();
    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
    const targetIndex = Array.from(UI.elements.measures.children).indexOf(e.target.closest('.measure'));
    if (draggedIndex === targetIndex || isNaN(draggedIndex) || isNaN(targetIndex)) return;
    const measures = Array.from(UI.elements.measures.children);
    const draggedMeasure = measures[draggedIndex];
    UI.elements.measures.insertBefore(draggedMeasure, targetIndex < draggedIndex ? measures[targetIndex] : measures[targetIndex + 1]);
    updateMeasureNumbers();
    log(`Moved measure from index ${draggedIndex} to ${targetIndex}`);
}

function dragEnd(e) {
    e.target.classList.remove('dragging');
}

function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    fretboardsGrid.innerHTML = ''; // Clear existing content
    
    // Add CSS to make it a 2x2 grid
    fretboardsGrid.style.display = 'grid';
    fretboardsGrid.style.gridTemplateColumns = 'repeat(2, 1fr)';
    fretboardsGrid.style.gap = '20px';
    
    // Create 4 independent fretboard sections
    for (let i = 0; i < 4; i++) {
        const fretboardSection = document.createElement('div');
        fretboardSection.className = 'fretboard-section';
        
        // Generate scale options from SCALES constant
        const scaleOptions = Object.entries(SCALES)
            .map(([scaleName, intervals]) => {
                // Capitalize first letter and format the scale name
                const displayName = scaleName
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                    .join(' ');
                return `<option value="${scaleName}">${displayName}</option>`;
            })
            .join('');
        
        // Create the HTML structure for each section
        fretboardSection.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group">
                    <label for="fretflow-key-${i}">Key:</label>
                    <select id="fretflow-key-${i}" class="fretflow-key" aria-label="Select key">
                        <option value="C">C</option>
                        <option value="C#">C#</option>
                        <option value="D">D</option>
                        <option value="D#">D#</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                        <option value="F#">F#</option>
                        <option value="G">G</option>
                        <option value="G#">G#</option>
                        <option value="A">A</option>
                        <option value="A#">A#</option>
                        <option value="B">B</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="fretflow-scale-${i}">Scale:</label>
                    <select id="fretflow-scale-${i}" class="fretflow-scale" aria-label="Select scale type">
                        ${scaleOptions}
                    </select>
                </div>
                <div class="control-group">
                    <label for="fretflow-tuning-${i}">Tuning:</label>
                    <select id="fretflow-tuning-${i}" class="tuning-select" aria-label="Select guitar tuning">
                        <option value="standard">Standard (EADGBE)</option>
                        <option value="dropD">Drop D (DADGBE)</option>
                        <option value="openG">Open G (DGDGBD)</option>
                        <option value="DADGAD">DADGAD</option>
                        <option value="openE">Open E (EBEG#BE)</option>
                    </select>
                </div>
            </div>
            <div class="scale-display"></div>
            <div id="fretflow-fretboard-${i}" class="fretboard"></div>
        `;
        
        fretboardsGrid.appendChild(fretboardSection);
        
        // Initialize this fretboard
        const fretboard = fretboardSection.querySelector(`#fretflow-fretboard-${i}`);
        const keySelect = fretboardSection.querySelector(`#fretflow-key-${i}`);
        const scaleSelect = fretboardSection.querySelector(`#fretflow-scale-${i}`);
        const tuningSelect = fretboardSection.querySelector(`#fretflow-tuning-${i}`);
        const scaleDisplay = fretboardSection.querySelector('.scale-display');
        
        function updateFretboardDisplay() {
            try {
                const selectedKey = keySelect.value;
                const selectedScale = scaleSelect.value;
                const selectedTuning = TUNINGS[tuningSelect.value];
                
                if (!selectedTuning) {
                    console.error(`Invalid tuning selected: ${tuningSelect.value}`);
                    return;
                }
                
                // Format the scale name for display
                const displayScaleName = selectedScale
                    .split('_')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                    .join(' ');
                
                // Update the scale display
                scaleDisplay.textContent = `${selectedKey} ${displayScaleName}`;
                
                // Update the fretboard
                createFretboard(fretboard, selectedTuning);
                updateFretboardNotes(fretboard, selectedKey, selectedScale, selectedTuning);
                
                // Attach note click handlers
                attachNoteClickHandlers(fretboard);
                
            } catch (error) {
                console.error('Error updating fretboard display:', error);
                log(`Error updating fretboard: ${error.message}`);
            }
        }
        
        // Add event listeners for all controls
        keySelect.addEventListener('change', updateFretboardDisplay);
        scaleSelect.addEventListener('change', updateFretboardDisplay);
        tuningSelect.addEventListener('change', updateFretboardDisplay);
        
        // Initial render
        updateFretboardDisplay();
    }
}
        
function setupMeasureEventListeners() {
    // TODO: Implement measure event listeners if needed
}
function updateDisplay() {
    // TODO: Implement display update logic if needed
}        
function attachNoteClickHandlers(fretboard) {
    if (!fretboard) {
        console.error('Invalid fretboard element provided');
        return;
    }

    // Remove existing event listeners to prevent duplicates
    const oldNotes = fretboard.getElementsByClassName('note');
    Array.from(oldNotes).forEach(note => {
        const clone = note.cloneNode(true);
        note.parentNode.replaceChild(clone, note);
    });

    // Attach new event listeners
    const notes = fretboard.getElementsByClassName('note');
    Array.from(notes).forEach(note => {
        note.addEventListener('click', function(e) {
            e.stopPropagation();
            const noteName = this.dataset.note;
            if (noteName) {
                try {
                    const fretboardVolume = parseFloat(UI.elements.chordFretboardVolume.value) || 1.0;
                    playNote(noteName, fretboardVolume, 500);
                    log(`Playing note: ${noteName}`);
                } catch (error) {
                    console.error('Error playing note:', error);
                    log(`Error playing note ${noteName}: ${error.message}`);
                }
            }
        });
    });
}

// Log initialization
log("FretFlow initialized with 4 independent fretboards");

        
    function addFirstChordListener() {
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key');
        const scaleType = firstMeasure.querySelector('.scale-select');
        const updateFretboard = () => {
            const tuning = TUNINGS[UI.elements.chordTuning.value];
            updateFretboardNotes(UI.elements.chordFretboard, scaleRoot.value, scaleType.value, tuning);
        };
        scaleRoot.addEventListener('change', updateFretboard);
        scaleType.addEventListener('change', updateFretboard);
    }
}

/**
 * Sets up event listeners for all UI interactions in the Bebop Blueprint application.
 * Consolidated all listeners to prevent duplicates and added input validation.
 */
function setupEventListeners() {
    // Validate UI.elements existence
    if (!UI.elements) {
        console.error('UI.elements is undefined');
        return;
    }

    // Audio initialization
    document.addEventListener('click', async () => {
        try {
            await AudioContextManager.initialize();
        } catch (error) {
            console.error('Failed to initialize audio on click:', error);
        }
    }, { once: true });

    // Start/Stop button
    if (UI.elements.startStopButton) {
        UI.elements.startStopButton.addEventListener('click', () => {
            if (AppState.isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        });
    } else {
        console.warn('startStopButton not found');
    }

    // Progression selection
    if (UI.elements.progressionSelect) {
        UI.elements.progressionSelect.addEventListener('change', (e) => {
            loadProgression(e.target.value);
        });
    } else {
        console.warn('progressionSelect not found');
    }

    // Key selection (consolidated progression loading, key update, and fretboard init)
    if (UI.elements.keySelect) {
        UI.elements.keySelect.addEventListener('change', (e) => {
            const progressionSelect = UI.elements.progressionSelect;
            if (progressionSelect?.value) {
                loadProgression(progressionSelect.value, e.target.value);
                updateProgressionKey(e.target.value);
                initializeFretFlow();
            }
        });
    } else {
        console.warn('keySelect not found');
    }

    // Tempo controls
    if (UI.elements.tempo && UI.elements.tempoDisplay) {
        UI.elements.tempo.addEventListener('input', () => {
            const tempo = parseInt(UI.elements.tempo.value) || 120;
            AppState.tempo = Math.max(40, Math.min(220, tempo));
            UI.elements.tempo.value = AppState.tempo;
            UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            if (AppState.isPlaying) {
                stopPlayback();
                startPlayback();
            }
            log(`Tempo set to ${AppState.tempo} BPM`);
        });
    } else {
        console.warn('tempo or tempoDisplay not found');
    }

    // Tap tempo
    if (UI.elements.tapTempo) {
        UI.elements.tapTempo.addEventListener('click', () => {
            const now = Date.now();
            if (!AppState.lastTap) AppState.lastTap = now;
            const interval = now - AppState.lastTap;
            if (interval < 2000) {
                const bpm = Math.round(60000 / interval);
                AppState.tempo = Math.max(40, Math.min(220, bpm));
                UI.elements.tempo.value = AppState.tempo;
                UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                if (AppState.isPlaying) {
                    stopPlayback();
                    startPlayback();
                }
            }
            AppState.lastTap = now;
            log(`Tap tempo calculated: ${AppState.tempo} BPM`);
        });
    } else {
        console.warn('tapTempo not found');
    }

    // Time signature
    if (UI.elements.timeSignature) {
        UI.elements.timeSignature.addEventListener('change', () => {
            createBeats();
            if (AppState.isPlaying) {
                stopPlayback();
                startPlayback();
            }
            log(`Time signature changed to ${UI.elements.timeSignature.value}`);
        });
    } else {
        console.warn('timeSignature not found');
    }

    // Sound type (with initial visibility setup)
    if (UI.elements.soundType && UI.elements.drumSetToggleBtn) {
        UI.elements.soundType.addEventListener('change', (e) => {
            UI.elements.drumSetToggleBtn.style.display = e.target.value === 'drums' ? 'inline-block' : 'none';
            createBeats();
            onMetronomeInstrumentChange(e.target.value);
            log(`Sound type changed to ${e.target.value}`);
        });
        // Initial visibility
        UI.elements.drumSetToggleBtn.style.display = UI.elements.soundType.value === 'drums' ? 'inline-block' : 'none';
    } else {
        console.warn('soundType or drumSetToggleBtn not found');
    }

    // Drum set toggle
    if (UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.addEventListener('click', () => {
            if (!drumSoundSets || !Array.isArray(drumSoundSets)) {
                console.error('drumSoundSets is undefined or invalid');
                return;
            }
            currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
            UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
            log(`Switched to drum set ${drumSoundSets[currentDrumSetIndex].name}`);
        });
    } else {
        console.warn('drumSetToggleBtn not found');
    }

    // Volume controls
    if (UI.elements.metronomeVolume) {
        UI.elements.metronomeVolume.addEventListener('input', () => {
            const volume = parseFloat(UI.elements.metronomeVolume.value) || 0;
            log(`Metronome volume set to ${Math.min(Math.max(volume, 0), 1)}`);
        });
    } else {
        console.warn('metronomeVolume not found');
    }

    if (UI.elements.chordFretboardVolume) {
        UI.elements.chordFretboardVolume.addEventListener('input', () => {
            const volume = parseFloat(UI.elements.chordFretboardVolume.value) || 0;
            log(`Chord fretboard volume set to ${Math.min(Math.max(volume, 0), 1)}`);
        });
    } else {
        console.warn('chordFretboardVolume not found');
    }

    if (UI.elements.chordVolume) {
        UI.elements.chordVolume.addEventListener('input', () => {
            const volume = parseFloat(UI.elements.chordVolume.value) || 0;
            log(`Chord volume set to ${Math.min(Math.max(volume, 0), 1)}`);
        });
    } else {
        console.warn('chordVolume not found');
    }

    // Reverb dial
    if (UI.elements.reverbDial && UI.elements.reverbDialValue) {
        UI.elements.reverbDial.addEventListener('input', (e) => {
            const value = parseInt(e.target.value, 10) || 0;
            AudioContextManager.reverbAmount = Math.min(Math.max(value / 100, 0), 1);
            UI.elements.reverbDialValue.textContent = value;
            log(`Reverb set to ${value}%`);
        });
    } else {
        console.warn('reverbDial or reverbDialValue not found');
    }

    // Dark mode toggle
    if (UI.elements.darkModeToggle) {
        let colorMode = 0;
        UI.elements.darkModeToggle.addEventListener('click', () => {
            colorMode = (colorMode + 1) % 4;
            document.body.classList.remove('dark-mode', 'dark-mode-2', 'dark-mode-3');
            UI.elements.darkModeToggle.classList.remove('active', 'active-2', 'active-3');
            switch (colorMode) {
                case 1:
                    document.body.classList.add('dark-mode');
                    UI.elements.darkModeToggle.classList.add('active');
                    log('Dark mode 1 enabled');
                    break;
                case 2:
                    document.body.classList.add('dark-mode-2');
                    UI.elements.darkModeToggle.classList.add('active-2');
                    log('Dark mode 2 enabled');
                    break;
                case 3:
                    document.body.classList.add('dark-mode-3');
                    UI.elements.darkModeToggle.classList.add('active-3');
                    log('Dark mode 3 enabled');
                    break;
                default:
                    log('Light mode enabled');
                    break;
            }
        });
    } else {
        console.warn('darkModeToggle not found');
    }

    // Chords enabled toggle
    if (UI.elements.chordsEnabled) {
        UI.elements.chordsEnabled.addEventListener('click', () => {
            AppState.chordsEnabled = !AppState.chordsEnabled;
            UI.elements.chordsEnabled.textContent = AppState.chordsEnabled ? 'Chords Enabled' : 'Chords Disabled';
            UI.elements.chordsEnabled.classList.toggle('active', AppState.chordsEnabled);
            log(`Chords ${AppState.chordsEnabled ? 'enabled' : 'disabled'}`);
        });
    } else {
        console.warn('chordsEnabled not found');
    }

    // Tuning controls
    if (UI.elements.chordTuning && UI.elements.measures) {
        UI.elements.chordTuning.addEventListener('change', () => {
            const tuning = TUNINGS[UI.elements.chordTuning.value];
            if (!tuning) {
                console.error(`Invalid tuning: ${UI.elements.chordTuning.value}`);
                return;
            }
            const firstMeasure = UI.elements.measures.firstElementChild;
            if (firstMeasure) {
                const scaleRoot = firstMeasure.querySelector('.second-key')?.value;
                const scaleType = firstMeasure.querySelector('.scale-select')?.value;
                if (scaleRoot && scaleType) {
                    updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
                }
            }
            initializeFretFlow();
            log(`Tuning changed to ${UI.elements.chordTuning.value}`);
        });
    } else {
        console.warn('chordTuning or measures not found');
    }

    // Accent intensity
    if (UI.elements.accentIntensity) {
        UI.elements.accentIntensity.addEventListener('input', () => {
            const intensity = parseFloat(UI.elements.accentIntensity.value) || 0;
            log(`Accent intensity set to ${Math.min(Math.max(intensity, 0), 1)}`);
        });
    } else {
        console.warn('accentIntensity not found');
    }

    // Measure controls (using event delegation)
    if (UI.elements.measures) {
        UI.elements.measures.addEventListener('change', (e) => {
            const select = e.target;
            if (select.classList.contains('root-note') || select.classList.contains('chord-quality')) {
                const measure = select.closest('.measure');
                if (!measure) return;
                const root = measure.querySelector('.root-note')?.value;
                const quality = measure.querySelector('.chord-quality')?.value;
                const secondKeySelect = measure.querySelector('.second-key');
                const scaleSelect = measure.querySelector('.scale-select');
                if (root && quality && secondKeySelect && scaleSelect) {
                    secondKeySelect.value = root;
                    scaleSelect.value = suggestScaleForQuality(quality);
                    if (measure === UI.elements.measures.firstElementChild) {
                        const tuning = TUNINGS[UI.elements.chordTuning.value];
                        if (tuning) {
                            updateFretboardNotes(UI.elements.chordFretboard, root, scaleSelect.value, tuning);
                        }
                    }
                    log(`Updated chord in measure to ${root} ${quality}`);
                }
            }
        });
    } else {
        console.warn('measures not found');
    }

    // Add measure button
    if (UI.elements.addMeasureButton) {
        UI.elements.addMeasureButton.addEventListener('click', () => {
            addMeasure();
            log('Added new measure');
        });
    } else {
        console.warn('addMeasureButton not found');
    }

    // Remove measure button
    if (UI.elements.removeMeasureButton) {
        UI.elements.removeMeasureButton.addEventListener('click', () => {
            removeMeasure();
            log('Removed last measure');
        });
    } else {
        console.warn('removeMeasureButton not found');
    }

    log("Event listeners set up");
}

/**
 * Initializes the Bebop Blueprint application.
 * Requires: UI.init, createBeats, createFretboard, loadProgression, initializeFretFlow,
 *           updateLoadingStatus, log, TUNINGS, UI.elements
 */
async function initializeApp() {
    UI.init();
    createBeats();
    createFretboard(UI.elements.chordFretboard, TUNINGS.standard);
    loadProgression(UI.elements.progressionSelect.value);
    initializeFretFlow();
    setupEventListeners();
    UI.elements.reverbDialValue.textContent = UI.elements.reverbDial.value; // Initialize reverb dial value
    updateLoadingStatus("Application initialized");
    setTimeout(() => {
        const indicator = document.getElementById('loading-indicator');
        if (indicator) indicator.remove();
    }, 1000);
    log("Application initialized");
}

/**
 * Runs initializeApp on DOM content loaded.
 * Requires: initializeScaleSelects, updateLoadingStatus
 */
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Initialization failed:", error);
        updateLoadingStatus("Initialization failed");
        initializeScaleSelects();
    });
});
    </script>
        </body>
        </html>
