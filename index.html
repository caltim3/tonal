<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="tele4.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1f618d;
        }
        .app-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .fretboards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .fretboard-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .scale-display {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .controls select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            flex: 1;
        }
        
        .fretboard {
            position: relative;
            height: 200px;
            background-color: #FFCF79;
            border-radius: 5px;
            margin-bottom: 30px;
            border: 2px solid #4B1C2E;
            overflow: visible;
        }
        .fret-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #c0c0c0;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        .string-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background: silver;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 0;
        }
        .fret-number {
            position: absolute;
            bottom: -40px;
            font-size: 16px;
            color: #1f618d;
            transform: translateX(-50%);
            font-weight: bold;
            z-index: 2;
            width: 20px;
            text-align: center;
        }
        .fret-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .note {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            z-index: 3;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
        }
        .note:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        .beat {
            width: 40px;
            height: 80px;
            background: #9E9E9E;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 14px;
            margin: 0 2px;
        }
        .beats-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            flex-wrap: nowrap;
        }
        .beat.active {
            transform: translateY(-10px);
        }
        #measures {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }
        .measure {
            position: relative;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            transition: opacity 0.2s ease;
        }
        .measure.active {
            background-color: #c3e6cb;
            border: 2px solid #28a745;
        }
        .measure-number {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #333;
        }
        .chord-controls, .scale-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .chord-controls select, .scale-controls select {
            flex: 1;
        }
        @media (max-width: 1200px) {
            #measures {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 600px) {
            #measures {
                grid-template-columns: 1fr;
            }
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        select {
            padding: 5px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        #tempo-display {
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 10px;
        }
        #loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 5px;
            z-index: 1000;
        }

        .checkbox-wrapper {
            margin-top: 20px;  /* Add space above the button */
            margin-left: 20px; /* Move button to the left */
            display: flex;
            align-items: center;
        }

        .control-button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            background: #45a049;
        }
        
        /* Optional: adjust the button itself for better alignment */
        #chordsEnabled {
            margin-bottom: 10px;  /* Add some space below the button */
            padding: 8px 16px;    /* Slightly adjust padding if needed */
        }

        body.dark-mode {
            background-color: #283618;
            color: #fefae0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark-mode .app-section {
            background: linear-gradient(145deg, #283618, #606c38);
            color: #fefae0;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .fretboard-container {
            background-color: #606c38;
            border: 1px solid #dda15e;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .dark-mode .fretboard {
            background-color: #dda15e;
            border: 2px solid #4b4b4b;
            border-radius: 5px;
        }
        .dark-mode .note {
            background-color: #dda15e;
            color: #283618;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .note:hover {
            transform: scale(1.2);
            background-color: #bc6c25;
        }
        .dark-mode .scale-display {
            color: #fefae0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .dark-mode button {
            background-color: #dda15e;
            color: #283618;
            border: 1px solid #bc6c25;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode button:hover {
            background-color: #bc6c25;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        .dark-mode select {
            background-color: #dda15e;
            color: #283618;
            border: 1px solid #bc6c25;
        }
        .dark-mode select:hover {
            background-color: #bc6c25;
        }
        .dark-mode .measure {
            background-color: #606c38;
            color: #fefae0;
            border: 1px solid #dda15e;
        }
        .dark-mode .measure.active {
            background-color: #dda15e;
            border-color: #bc6c25;
        }
        .dark-mode .beat {
            background-color: #dda15e;
            color: #283618;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .beat.active {
            background-color: #bc6c25;
            transform: translateY(-5px);
        }
        .dark-mode .volume-control {
            color: #fefae0;
        }
        .dark-mode .volume-control input[type="range"] {
            background: #606c38;
        }
        .dark-mode .volume-control input[type="range"]::-webkit-slider-thumb {
            background: #dda15e;
            border: 1px solid #bc6c25;
        }
        #dark-mode-toggle.active {
            background-color: #283618;
            color: #fefae0;
            border: 1px solid #dda15e;
        }

        .dark-mode-2 {
            background-color: #0a1128;
            color: #fefcfb;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .dark-mode-2 .app-section {
            background: linear-gradient(145deg, #001f54, #034078);
            color: #fefcfb;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 .fretboard-container {
            background-color: #034078;
            border: 1px solid #1282a2;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .dark-mode-2 .fretboard {
            background-color: #001f54;
            border: 2px solid #1282a2;
            border-radius: 5px;
        }
        
        .dark-mode-2 .note {
            background-color: #1282a2;
            color: #fefcfb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 .scale-display {
            color: #fefcfb;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .dark-mode-2 button {
            background-color: #1282a2;
            color: #fefcfb;
            border: 1px solid #034078;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 select {
            background-color: #034078;
            color: #fefcfb;
            border: 1px solid #1282a2;
        }
        
        .dark-mode-2 .measure {
            background-color: #034078;
            color: #fefcfb;
            border: 1px solid #1282a2;
        }
        
        .dark-mode-2 .measure.active {
            background-color: #1282a2;
            border-color: #fefcfb;
        }
        
        .dark-mode-2 .beat {
            background-color: #1282a2;
            color: #fefcfb;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 .beat.active {
            background-color: #034078;
            transform: translateY(-5px);
        }
                .toggle-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-button.active {
            background: #4CAF50;
        }
        
        .toggle-button:not(.active) {
            background: #9E9E9E;
        }
        
        #dark-mode-toggle.active-2 {
            background-color: #1282a2;
            color: #fefcfb;
            border: 1px solid #034078;
        }
        
        .dark-mode-3 {
            background-color: #6b705c;
            color: #ffe8d6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .dark-mode-3 .app-section {
            background: linear-gradient(145deg, #6b705c, #a5a58d);
            color: #ffe8d6;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 .fretboard-container {
            background-color: #606c38;
            border: 1px solid #cb997e;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .dark-mode-3 .fretboard {
            background-color: #825b46;
            border: 2px solid #6b705c;
            border-radius: 5px;
        }
        
        .dark-mode-3 .note {
            background-color: #b7b7a4;
            color: #6b705c;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 .scale-display {
            color: #ffe8d6;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .dark-mode-3 button {
            background-color: #cb997e;
            color: #ffe8d6;
            border: 1px solid #6b705c;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 select {
            background-color: #ddbea9;
            color: #6b705c;
            border: 1px solid #cb997e;
        }
        
        .dark-mode-3 .measure {
            background-color: #a5a58d;
            color: #ffe8d6;
            border: 1px solid #cb997e;
        }
        
        .dark-mode-3 .measure.active {
            background-color: #ddbea9;
            border-color: #cb997e;
        }
        
        .dark-mode-3 .beat {
            background-color: #ddbea9;
            color: #6b705c;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 .beat.active {
            background-color: #cb997e;
            transform: translateY(-5px);
        }
        
        .dark-mode-3 .volume-control {
            color: #ffe8d6;
        }
        
        #dark-mode-toggle.active-3 {
            background-color: #cb997e;
            color: #ffe8d6;
            border: 1px solid #6b705c;
        }
        
    </style>
</head>
<body>

    <main>
        <!-- Loading Indicator -->
        <div id="loading-indicator" aria-live="polite">Loading...</div>

        <!-- Chord Fretboard Section -->
        <section class="app-section" id="chord-fretboard-section">
            <h1>Bebop Blueprint</h1>
            <h2>FretFlow - Dynamic Fretboard with Scales that Move with the Chord Progression</h2>
            <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
            <div class="volume-control">
                <label for="fretboard-volume">Fretboard Volume:</label>
                <input type="range" id="fretboard-volume" min="0" max="1" step="0.1" value="0.7" aria-label="Fretboard note volume">
            </div>
            <div class="fretboard-container">
                <div class="scale-display" id="scale-display" aria-live="polite"></div>
                <div class="controls">
                    <label for="chord-tuning">Guitar Tuning:</label>
                    <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                        <option value="standard">Standard (EADGBE)</option>
                        <option value="dropD">Drop D (DADGBE)</option>
                        <option value="openG">Open G (DGDGBD)</option>
                        <option value="DADGAD">DADGAD</option>
                        <option value="openE">Open E (EBEG#BE)</option>
                    </select>
                </div>
                <div id="chord-fretboard" class="fretboard" aria-label="Chord fretboard"></div>
            </div>
        </section>

        <!-- Metronome Section -->
        <section class="app-section" id="metronome-section">
            <h2>BeatForge Metronome</h2>
            <h3>Click to accent strong beats</h3>
            <div class="controls">
                <label for="time-signature">Time Signature:</label>
                <select id="time-signature" aria-label="Select time signature">
                    <option value="2">2/4</option>
                    <option value="3">3/4</option>
                    <option value="4" selected>4/4</option>
                    <option value="6">6/8</option>
                    <option value="7">7/8</option>
                    <option value="8">8/8</option>
                    <option value="12">12/8</option>
                </select>
                <label for="sound-type">Metronome Sound:</label>
                <select id="sound-type" aria-label="Select metronome sound">
                    <option value="click">Click</option>
                    <option value="woodblock">Woodblock</option>
                    <option value="drums">Drums</option>
                </select>
                <button id="drumsettogglebtn" class="control-button" aria-label="Toggle drum set sounds" style="display: none;">Toggle Drum Set</button>
                <div class="volume-control">
                    <label for="metronome-volume">Metronome Volume:</label>
                    <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.7" aria-label="Metronome volume">
                </div>
                <label for="tempo">Tempo:</label>
                <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Metronome tempo">
                <span id="tempo-display" aria-live="polite">120 BPM</span>
                <button id="tap-tempo" aria-label="Tap to set tempo">Tap Tempo</button>
                <button id="start-stop" aria-label="Start metronome">Start</button>
            </div>
            <!-- Swing Control -->
            <div class="control-group">
                <label for="swing-control">Swing Amount:</label>
                <input type="range" id="swing-control" min="0" max="20" value="0" step="1" aria-label="Swing amount">
                <span id="swing-value" aria-live="polite">0%</span>
            </div>
            <div class="beats-container" aria-live="polite"></div>
        </section>

        <!-- Chord Progression Section -->
        <section class="app-section" id="chord-progression-section">
            <h2>Chord Progression Practice</h2>
            <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
            <div class="control-group">
                <label for="progression-select">Chord Progression:</label>
                <select id="progression-select" aria-label="Select chord progression">
                    <option value="I V7">I-V7</option>
                    <option value="jazz_blues">Jazz Blues</option>
                    <option value="minor_blues">Minor Blues</option>
                    <option value="rhythm_changes">Rhythm Changes</option>
                    <option value="2_5_1">II-V-I</option>
                    <option value="6_2_5_1">VI-II-V-I</option>
                    <option value="minor 2_5_1">Minor iim-V7-im</option>
                    <option value="dark_eyes">Dark Eyes</option>
                    <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams</option>
                    <option value="rose_room">Rose Room</option>
                    <option value="black_orpheus">Black Orpheus</option>
                    <option value="all_the_things_you_are">All The Things You Are</option>
                    <option value="all_of_me">All of Me</option>
                    <option value="stella_by_starlight">Stella By Starlight</option>
                    <option value="autumn_leaves">Autumn Leaves</option>
                    <option value="summertime">Summertime</option>
                    <option value="girl_from_ipanema">Girl From Ipanema</option>
                    <option value="coltrane_changes">Coltrane Changes</option>
                    <option value="bird_blues">Bird Blues</option>
                    <option value="just_friends">Just Friends</option>
                    <option value="blue_bossa">Blue Bossa</option>
                    <option value="on_green_dolphin_street">On Green Dolphin Street</option>
                    <option value="solar">Solar</option>
                    <option value="misty">Misty</option>
                    <option value="days_of_wine_and_roses">Days of Wine and Roses</option>
                    <option value="cherokee">Cherokee</option>
                    <option value="caravan">Caravan</option>
                    <option value="nows_the_time">Now's The Time</option>
                    <option value="tenor_madness">Tenor Madness</option>
                </select>
            </div>
            <div class="control-group">
                <label for="key-select">Key:</label>
                <select id="key-select" aria-label="Select key">
                    <option value="C">C</option>
                    <option value="Cm">Cm</option>
                    <option value="Db">Db</option>
                    <option value="Dbm">Dbm</option>
                    <option value="D">D</option>
                    <option value="Dm">Dm</option>
                    <option value="Eb">Eb</option>
                    <option value="Ebm">Ebm</option>
                    <option value="E">E</option>
                    <option value="Em">Em</option>
                    <option value="F">F</option>
                    <option value="Fm">Fm</option>
                    <option value="Gb">Gb</option>
                    <option value="Gbm">Gbm</option>
                    <option value="G">G</option>
                    <option value="Gm">Gm</option>
                    <option value="Ab">Ab</option>
                    <option value="Abm">Abm</option>
                    <option value="A">A</option>
                    <option value="Am">Am</option>
                    <option value="Bb">Bb</option>
                    <option value="Bbm">Bbm</option>
                    <option value="B">B</option>
                    <option value="Bm">Bm</option>
                </select>
            </div>
            <div id="measures" aria-live="polite">
                <!-- Measures will be populated dynamically -->
            </div>
            <button onclick="addMeasure()" aria-label="Add a new measure">Add Measure</button>
            <button onclick="removeMeasure()" aria-label="Remove the last measure">Remove Measure</button>
            <div class="control-group">
                <button id="chords-enabled" class="toggle-button active" role="switch" aria-checked="true" aria-label="Toggle chord playback">Chords Enabled</button>
            </div>
            <div class="volume-control">
                <label for="chord-volume">Chord Volume:</label>
                <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.7" aria-label="Chord playback volume">
            </div>
        </section>

        <!-- FretFlow Section -->
        <section class="app-section" id="fretflow-section">
            <h2>FretFlow</h2>
            <h3>Multiple scale workout</h3>
            <div class="volume-control">
                <label for="accent-intensity">Accent Intensity:</label>
                <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1" aria-label="Accent intensity for strong beats">
            </div>
            <div class="fretboards-grid" aria-live="polite">
                <!-- Fretboards will be generated dynamically -->
            </div>
        </section>
    </main>

    <script>
const log = console.log.bind(console);        
// Utility Functions
function noteNameToSampleName(note) {
  // Converts "F#" to "Fs", "D#" to "Ds", etc.
  return note.replace('#', 's');
}
// Musical Constants
// Define chromatic notes using 's' notation for consistency
const NOTES = ['C', 'Cs', 'D', 'Ds', 'E', 'F', 'Fs', 'G', 'Gs', 'A', 'As', 'B'];

// Define sampled notes for AudioContextManager (matches loadPianoSamples)
const SAMPLED_NOTES = NOTES; // Same as NOTES, used for sample lookup

// Add near NOTES constant
const SAMPLE_NOTE_MAP = {
  'Cs': 'Db', 'Ds': 'Eb', 'Fs': 'Gb', 
  'Gs': 'Ab', 'As': 'Bb'
};
        
const PIANO_OCTAVES = {
  'C': [3,4], 'Cs': [3,4], 'D': [3,4], 'Ds': [3,4], 
  'E': [3,4], 'F': [3,4], 'Fs': [3,4], 'G': [3,4], 
  'Gs': [3,4], 'A': [3,4], 'As': [3,4], 'B': [3,4]
};
// Add this near NOTES constant
const ENHARMONIC_MAP = {
  'Db': 'Cs', 'Eb': 'Ds', 'Gb': 'Fs', 'Ab': 'Gs', 'Bb': 'As',
  'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
};
// Note frequency mappings (for pitch calculations, if needed)
const NOTE_FREQUENCIES = {
    'A2': 110.00, 'As2': 116.54, 'B2': 123.47,
    'C3': 130.81, 'Cs3': 138.59, 'D3': 146.83, 'Ds3': 155.56, 'E3': 164.81, 'F3': 174.61,
    'Fs3': 185.00, 'G3': 196.00, 'Gs3': 207.65, 'A3': 220.00, 'As3': 233.08, 'B3': 246.94,
    'C4': 261.63, 'Cs4': 277.18, 'D4': 293.66, 'Ds4': 311.13, 'E4': 329.63
};

// Convert note names to sample format (e.g., A# → As, Bb → As, C3 → C3)
function toSampleNoteName(note) {
    if (!note) {
        console.warn('toSampleNoteName: Empty note provided');
        return '';
    }

    // Handle notes with octave (e.g., C3, A#3)
    let noteBase = note;
    let octave = '';
    const octaveMatch = note.match(/([A-G][b#s]?)(\d)/);
    if (octaveMatch) {
        noteBase = octaveMatch[1]; // e.g., C, A#, Bb
        octave = octaveMatch[2]; // e.g., 3
    }

    // Conversion map for sharps and flats to 's' notation
    const noteMap = {
        'C#': 'Cs', 'Db': 'Cs', 'Cb': 'B',
        'D#': 'Ds', 'Eb': 'Ds',
        'E#': 'F', 'Fb': 'E',
        'F#': 'Fs', 'Gb': 'Fs',
        'G#': 'Gs', 'Ab': 'Gs',
        'A#': 'As', 'Bb': 'As', 'B#': 'C'
    };

    // Convert note to sample format
    let convertedNote = noteMap[noteBase] || noteBase;
    if (noteBase.includes('#') && !noteMap[noteBase]) {
        convertedNote = noteBase.replace('#', 's');
    }

    // Reattach octave if present
    const result = octave ? `${convertedNote}${octave}` : convertedNote;
    if (!NOTES.includes(convertedNote)) {
        console.warn(`toSampleNoteName: Invalid note ${note}, converted to ${result}`);
    }
    return result;
}

const SCALES = {
    // Basic Scales
    major: [0, 2, 4, 5, 7, 9, 11],
    minor: [0, 2, 3, 5, 7, 8, 10],
    harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
    melodicMinor: [0, 2, 3, 5, 7, 9, 11],
    
    // Modes
    dorian: [0, 2, 3, 5, 7, 9, 10],
    phrygian: [0, 1, 3, 5, 7, 8, 10],
    lydian: [0, 2, 4, 6, 7, 9, 11],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    locrian: [0, 1, 3, 5, 6, 8, 10],
    
    // Jazz Scales
    bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11],
    bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11],
    bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10],
    bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10], // Added Bebop Phrygian
    altered: [0, 1, 3, 4, 6, 8, 10],      // Super Locrian
    lydianDominant: [0, 2, 4, 6, 7, 9, 10],
    
    // Symmetric Scales
    diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11],  // Diminished (Whole-Half)
    diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10],  // Diminished (Half-Whole)
    wholeHalf: [0, 2, 4, 6, 8, 10],           // Whole Tone
    
    // Pentatonic Scales
    pentatonicMajor: [0, 2, 4, 7, 9],
    pentatonicMinor: [0, 3, 5, 7, 10],
    
    // Blues Scales
    blues: [0, 3, 5, 6, 7, 10],
    majorBlues: [0, 2, 3, 4, 7, 9],
    
    // Additional Modern Jazz Scales
    altered: [0, 1, 3, 4, 6, 8, 10],
    halfWhole: [0, 1, 3, 4, 6, 7, 9, 10],
    harmonicMajor: [0, 2, 4, 5, 7, 8, 11],
    doubleHarmonic: [0, 1, 4, 5, 7, 8, 11],

    'enigmatic': [0, 1, 4, 6, 8, 10, 11],
    'persian': [0, 1, 4, 5, 6, 8, 11],
    'arabic': [0, 2, 4, 5, 6, 8, 10],
    'japanese': [0, 2, 5, 7, 8],
    'egyptian': [0, 2, 5, 7, 10]
    
};

const TUNINGS = {
    standard: ['E', 'B', 'G', 'D', 'A', 'E'],  // Note the order change
    dropD: ['E', 'B', 'G', 'D', 'A', 'D'],
    openG: ['D', 'B', 'G', 'D', 'G', 'D'],
    DADGAD: ['D', 'A', 'G', 'D', 'A', 'D'],
    openE: ['E', 'B', 'E', 'Ab', 'B', 'E']
};

        
const DRUM_PATTERNS = {
    '2': { kick: [1, 0], snare: [0, 1], hihat: [1, 1] },
    '3': { kick: [1, 0, 0], snare: [0, 1, 0], hihat: [1, 1, 1] },
    '4': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '6': { kick: [1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1] },
    '7': { kick: [1, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1] },
    '8': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '12': { kick: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] }
};
const drumSoundSets = [
    {
        name: "Drums",
        snare: "Snare.wav",
        hihat: "HiHat.wav",
        kick: "Kick.wav"
    },
    {
        name: "Makaya",
        snare: "Snare2.wav",
        hihat: "HiHat2.wav",
        kick: "Kick2.wav"
    },
    {
        name: "PhillyJoe",
        kick: 'jazzkick.wav',
        snare: 'jazzsnare.wav',
        hihat: 'jazzhat.wav'
    }
];

// Ensure variables are properly declared
let currentDrumSetIndex = 0;
let currentMeasure = 0;
            
const progressions = {
    "I V7": { defaultKey: "C", progression: ["I", "V7"] },
    "jazz_blues": { defaultKey: "Bb", progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "IIm7", "V7", "I7", "V7"] },
    "minor_blues": { defaultKey: "Am", progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"] },
    "rhythm_changes": { defaultKey: "Bb", progression: ["I6", "vim7", "iim7", "V7", "I6", "vim7", "iim7", "V7", "I6", "IV7", "I6", "I6", "iim7", "V7", "I6", "V7"] },
    "2_5_1": { defaultKey: "C", progression: ["iim7", "V7", "Imaj7", "Imaj7"] },
    "6_2_5_1": { defaultKey: "C", progression: ["vim7", "iim7", "V7", "Imaj7", "Imaj7"] },
    "minor_2_5_1": { defaultKey: "Am", progression: ["iim7b5", "V7b9", "im7", "im7"] },
    "dark_eyes": { defaultKey: "Dm", progression: ["V7", "V7", "im7", "im7", "V7", "V7", "VI6", "VI6", "ivm6", "ivm6", "im7", "im7", "V7", "V7", "im7", "im7"] },    
    "ill_see_you_in_my_dreams": { defaultKey: "F", progression: ["IV6", "IV6", "ivm6", "ivm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "iim7", "V7", "Imaj7"] },
    "rose_room": {defaultKey: "Ab", progression: ["II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"] },
    "black_orpheus": { defaultKey: "Am", progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"] },
    "all_the_things_you_are": { defaultKey: "Ab", progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"] },
    "all_of_me": { defaultKey: "C", progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IV", "iv", "Imaj7", "V7"] },
    "stella_by_starlight": { defaultKey: "Bb", progression: ["iim7b5", "V7b9", "im7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "iiim7b5", "VI7b9", "iim7", "V7", "im7", "IV7", "IVmaj7", "V7"] },
    "autumn_leaves": { defaultKey: "Em", progression: ["ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "im7"] },
    "summertime": { defaultKey: "Am", progression: ["im7", "V7", "im7", "V7", "im7", "V7", "im7", "V7", "iv7", "im7", "V7", "im7", "iv7", "im7", "V7", "im7"] },
    "girl_from_ipanema": { defaultKey: "F", progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "IV#maj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7"] },
    "coltrane_changes": { defaultKey: "C", progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"] },
    "bird_blues": { defaultKey: "F", progression: ["I7", "IV7", "I7", "vim7", "iim7", "V7", "IV7", "ivm7", "I7", "vim7", "iim7", "V7"] },
    "just_friends": { defaultKey: "G", progression: ["Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7"] },
    "blue_bossa": { defaultKey: "Cm", progression: ["im7", "im7", "bVII7", "bVII7", "im7", "im7", "ivm7", "bVII7", "im7", "V7", "im7", "im7"] },
    "on_green_dolphin_street": { defaultKey: "C", progression: ["Imaj7", "bIII7", "bVImaj7", "iim7", "V7", "Imaj7", "bIII7", "bVImaj7", "iim7", "V7", "Imaj7"] },
    "solar": { defaultKey: "C", progression: ["im7", "im7", "bIIImaj7", "bIIImaj7", "bVImaj7", "bVImaj7", "bII7", "bII7", "im7", "im7"] },
    "misty": { defaultKey: "Eb", progression: ["Imaj7", "I7", "IVmaj7", "ivm7", "Imaj7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7"] },
    "days_of_wine_and_roses": { defaultKey: "F", progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7"] },
    "cherokee": { defaultKey: "Bb", progression: ["Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7","bVI7", "bVI7", "V7", "V7", "Imaj7", "Imaj7", "iim7", "V7"] },
    "caravan": { defaultKey: "Eb", progression: ["im7", "IV7", "im7", "IV7", "im7", "IV7", "im7", "IV7", "bVII7", "bVII7", "Imaj7", "Imaj7", "V7", "V7", "im7", "im7"] },
    "nows_the_time": { defaultKey: "F", progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "V7", "IV7", "I7", "I7"] },
    "tenor_madness": { defaultKey: "Bb", progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "iim7", "V7", "I7", "I7"] }
};        
const scaleDegrees = {
    major: {
        // Basic triads (uppercase = major, lowercase = minor)
        'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11,
        'i': 0, 'ii': 2, 'iii': 4, 'iv': 5, 'v': 7, 'vi': 9, 'vii': 11,
        
        // Seventh chords
        'I7': 0, 'II7': 2, 'III7': 4, 'IV7': 5, 'V7': 7, 'VI7': 9, 'VII7': 11,
        'i7': 0, 'ii7': 2, 'iii7': 4, 'iv7': 5, 'v7': 7, 'vi7': 9, 'vii7': 11,
        'Im7': 0, 'IIm7': 2, 'IIIm7': 4, 'IVm7': 5, 'Vm7': 7, 'VIm7': 9, 'VIIm7': 11,
        'Imaj7': 0, 'IImaj7': 2, 'IIImaj7': 4, 'IVmaj7': 5, 'Vmaj7': 7, 'VImaj7': 9, 'VIImaj7': 11,
        
        // Extended and altered chords
        'I9': 0, 'II9': 2, 'III9': 4, 'IV9': 5, 'V9': 7, 'VI9': 9, 'VII9': 11,
        'I13': 0, 'II13': 2, 'III13': 4, 'IV13': 5, 'V13': 7, 'VI13': 9, 'VII13': 11,
        'V7b9': 7, 'V7#9': 7, 'V7b13': 7, 'V7#11': 7,
        
        // Diminished and half-diminished
        'vii°': 11, 'ii°': 2, 'iii°': 4,
        'vii∅7': 11, 'ii∅7': 2, 'iii∅7': 4,
        
        // Flat/borrowed chords
        'bII': 1, 'bIII': 3, 'bV': 6, 'bVI': 8, 'bVII': 10,
        'bII7': 1, 'bIII7': 3, 'bV7': 6, 'bVI7': 8, 'bVII7': 10,
        'bIImaj7': 1, 'bIIImaj7': 3, 'bVmaj7': 6, 'bVImaj7': 8, 'bVIImaj7': 10
    },
    minor: {
        // Basic triads
        'i': 0, 'ii': 2, 'III': 3, 'iv': 5, 'v': 7, 'VI': 8, 'VII': 10,
        'i°': 0, 'ii°': 2, 'III+': 3, 'iv°': 5, 'v°': 7, 'VI+': 8, 'vii°': 11,
        
        // Seventh chords
        'i7': 0, 'ii7': 2, 'III7': 3, 'iv7': 5, 'v7': 7, 'VI7': 8, 'VII7': 10,
        'im7': 0, 'iim7': 2, 'IIIm7': 3, 'ivm7': 5, 'vm7': 7, 'VIm7': 8, 'VIIm7': 10,
        'imaj7': 0, 'iimaj7': 2, 'IIImaj7': 3, 'ivmaj7': 5, 'vmaj7': 7, 'VImaj7': 8, 'VIImaj7': 10,
        
        // Half-diminished and diminished sevenths
        'iø7': 0, 'iiø7': 2, 'IIIø7': 3, 'ivø7': 5, 'vø7': 7, 'VIø7': 8, 'VIIø7': 10,
        'i°7': 0, 'ii°7': 2, 'III°7': 3, 'iv°7': 5, 'v°7': 7, 'VI°7': 8, 'VII°7': 10,
        'iim7b5': 2, 'iiim7b5': 4, 'vim7b5': 9,
        
        // Extended and altered chords
        'i9': 0, 'ii9': 2, 'III9': 3, 'iv9': 5, 'v9': 7, 'VI9': 8, 'VII9': 10,
        'i13': 0, 'ii13': 2, 'III13': 3, 'iv13': 5, 'v13': 7, 'VI13': 8, 'VII13': 10,
        'V7b9': 7, 'V7#9': 7, 'V7b13': 7, 'V7#11': 7,
        
        // Borrowed/modal interchange chords
        'bII': 1, 'bIII': 3, 'bIV': 4, 'bV': 6, 'bVI': 8, 'bVII': 10,
        'bII7': 1, 'bIII7': 3, 'bIV7': 4, 'bV7': 6, 'bVI7': 8, 'bVII7': 10,
        'bIImaj7': 1, 'bIIImaj7': 3, 'bIVmaj7': 4, 'bVmaj7': 6, 'bVImaj7': 8, 'bVIImaj7': 10,
        
        // Common secondary dominants
        'V7/III': 7, 'V7/iv': 7, 'V7/v': 7, 'V7/VI': 7, 'V7/VII': 7,
        'V7/bIII': 7, 'V7/bVI': 7, 'V7/bVII': 7
    }
};   
// State Management
const AppState = {
    isPlaying: false,
    currentBeat: 0,
    currentMeasure: 0,
    tempo: 120,
    audioInitialized: false,
    darkMode: false,
    listeners: [],
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};

// UI Management
class UIManager {
    static elements = {
        // Fretboard Elements
        chordFretboard: { id: 'chord-fretboard', required: true },
        fretboardsGrid: { selector: '.fretboards-grid', required: true },
        fretboardVolume: { id: 'fretboard-volume', defaultValue: 0.7 },
        
        // Chord Controls
        chordVolume: { id: 'chord-volume', defaultValue: 0.7 },
        chordsEnabled: { id: 'chords-enabled', isToggle: true },
        chordTuning: { id: 'chord-tuning', required: true },
        
        // Music Controls
        measures: { id: 'measures', required: true },
        progressionSelect: { id: 'progression-select', required: true },
        keySelect: { id: 'key-select', required: true },
        scaleDisplay: { id: 'scale-display', required: true },
        
        // Tempo Controls
        tempo: { id: 'tempo', required: true },
        tempoDisplay: { id: 'tempo-display', required: true },
        tapTempo: { id: 'tap-tempo', required: true },
        
        // Playback Controls
        startStopButton: { id: 'start-stop', required: true },
        timeSignature: { id: 'time-signature', required: true },
        metronomeVolume: { id: 'metronome-volume', required: true },
        
        // Sound Controls
        soundType: { id: 'sound-type', required: true },
        drumSetToggleBtn: { id: 'drumsettogglebtn', required: true },
        accentIntensity: { id: 'accent-intensity', required: true },
        
        // UI Controls
        darkModeToggle: { id: 'dark-mode-toggle', required: false },
        loadingIndicator: { id: 'loading-indicator', required: false }
    };

    static elementRefs = {};

    static init() {
        this.initializeElements();
        this.setupDefaultValues();
        return this.elementRefs;
    }

    static initializeElements() {
        for (const [key, config] of Object.entries(this.elements)) {
            const element = config.selector ? 
                document.querySelector(config.selector) : 
                document.getElementById(config.id);

            if (!element && config.required) {
                console.error(`Required UI element not found: ${key}`);
            } else if (!element) {
                console.warn(`Optional UI element not found: ${key}`);
            }

            this.elementRefs[key] = element;
        }
    }

    static setupDefaultValues() {
        for (const [key, config] of Object.entries(this.elements)) {
            const element = this.elementRefs[key];
            if (!element) continue;

            if (config.defaultValue !== undefined) {
                element.value = config.defaultValue;
            }
            if (config.isToggle) {
                element.classList.add('active');
            }
        }
    }

    static getElement(key) {
        return this.elementRefs[key];
    }
}
class AudioContextManager {
    static instance = null;

    constructor() {
        this.context = null;
        this.soundBuffers = {};
        this.pianoSampleBuffers = {};
        this.reverbNode = null;
        this.samplesLoaded = false;
        this.currentChordGain = null;
    }

    static getInstance() {
        if (!AudioContextManager.instance) {
            AudioContextManager.instance = new AudioContextManager();
        }
        return AudioContextManager.instance;
    }

    async initialize() {
        try {
            if (!this.context) {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                await Promise.all([
                    this.loadSounds(),
                    this.loadPianoSamples(),
                    this.setupReverb()
                ]);
            }

            if (this.context.state === 'suspended') {
                await this.context.resume();
            }

            AppState.updateState({ audioInitialized: true });
            return this.context;
        } catch (error) {
            console.error('Failed to initialize audio context:', error);
            throw new Error('Audio initialization failed');
        }
    }

    async loadSample(url, targetBuffer, key) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
            targetBuffer[key] = audioBuffer;
            return audioBuffer;
        } catch (error) {
            console.error(`Failed to load sample ${key} from ${url}:`, error);
            throw error;
        }
    }

    createAudioNode(buffer, options = {}) {
        const source = this.context.createBufferSource();
        const gainNode = this.context.createGain();
        
        source.buffer = buffer;
        gainNode.gain.value = options.gainValue ?? 1;

        source.connect(gainNode);
        gainNode.connect(options.destination || this.context.destination);

        return { source, gainNode };
    }

    playSample(buffer, time = 0, destination = null, gainValue = 1) {
        try {
            const { source } = this.createAudioNode(buffer, {
                gainValue,
                destination
            });

            source.start(this.context.currentTime + time);
            return source;
        } catch (error) {
            console.error('Error playing sample:', error);
            return null;
        }
    }

    setupReverb() {
        try {
            if (!this.reverbNode) {
                this.reverbNode = this.context.createConvolver();
                const sampleRate = this.context.sampleRate;
                const length = sampleRate * 2.5;
                const impulse = this.context.createBuffer(2, length, sampleRate);
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                this.reverbNode.buffer = impulse;
                this.reverbNode.connect(this.context.destination);
            }
        } catch (error) {
            console.error('Error setting up reverb:', error);
        }
    }

    applyReverb(buffer) {
        try {
            if (!this.reverbNode) return;
            
            buffer.connect(this.reverbNode);
            this.reverbNode.connect(this.context.destination);
        } catch (error) {
            console.error('Error applying reverb:', error);
        }
    }

    stopAllSounds() {
        try {
            if (this.currentChordGain) {
                this.currentChordGain.gain.setValueAtTime(
                    this.currentChordGain.gain.value,
                    this.context.currentTime
                );
                this.currentChordGain.gain.exponentialRampToValueAtTime(
                    0.001,
                    this.context.currentTime + 0.1
                );
                setTimeout(() => {
                    this.currentChordGain.disconnect();
                    this.currentChordGain = null;
                }, 200);
            }
        } catch (error) {
            console.error('Error stopping sounds:', error);
            // Fallback to immediate disconnect
            if (this.currentChordGain) {
                this.currentChordGain.disconnect();
                this.currentChordGain = null;
            }
        }
    }

    async ensureAudioContext() {
        return this.initialize();
    }

    async loadSounds() {
        const soundFiles = {
            'click': 'Click.wav',
            'hihat': 'HiHat.wav',
            'kick': 'Kick.wav',
            'snare': 'Snare.wav',
            'woodblock': 'woodblock.wav'
        };
        
        for (const [type, filename] of Object.entries(soundFiles)) {
            try {
                const response = await fetch(`./${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
                console.log(`Loaded ${type} sound from ${filename}`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                this.soundBuffers[type] = await this.createDrumSound(type);
                console.log(`Using fallback synthetic sound for ${type}`);
            }
        }
        
        if (typeof updateLoadingStatus === 'function') {
            updateLoadingStatus("Drum sounds loaded");
        }
    }

    async loadPianoSamples(sampleMap = null) {
        try {
            if (sampleMap) {
                const promises = Object.entries(sampleMap).map(([note, url]) =>
                    this.loadSample(url, this.pianoSampleBuffers, note)
                );
                await Promise.all(promises);
                this.samplesLoaded = true;
            } else {
                console.log('Starting full piano sample loading...');
                const octaves = [2, 3, 4, 5];
                const notes = ['c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs', 'a', 'as', 'b'];
                for (const octave of octaves) {
                    for (const note of notes) {
                        const sampleName = `${note}${octave}.wav`;
                        try {
                            const response = await fetch(`./${sampleName}`);
                            if (!response.ok) throw new Error(`Failed to load ${sampleName}`);
                            const arrayBuffer = await response.arrayBuffer();
                            this.pianoSampleBuffers[`${note.toUpperCase()}${octave}`] = await this.context.decodeAudioData(arrayBuffer);
                            console.log(`Loaded ${sampleName}`);
                        } catch (error) {
                            console.error(`Error loading ${sampleName}:`, error);
                        }
                    }
                }
                this.samplesLoaded = true;
                if (typeof updateLoadingStatus === 'function') {
                    updateLoadingStatus("Full piano samples loaded");
                }
            }
        } catch (error) {
            console.error('Error loading piano samples:', error);
            throw error;
        }
    }

    async createDrumSound(type) {
        try {
            const sampleRate = this.context.sampleRate;
            const duration = type === 'hihat' ? 0.05 : 0.2;
            const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
            const data = buffer.getChannelData(0);

            switch (type) {
                case 'click':
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
                    }
                    break;
                case 'hihat':
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
                    }
                    break;
                case 'kick':
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sampleRate;
                        data[i] = Math.sin(2 * Math.PI * 100 * t) * Math.exp(-t * 10) * 2;
                    }
                    break;
                case 'snare':
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sampleRate;
                        data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * t)) * Math.exp(-t * 10) * 2;
                    }
                    break;
                case 'woodblock':
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sampleRate;
                        data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 20);
                    }
                    break;
                default:
                    throw new Error(`Unknown drum sound type: ${type}`);
            }
            return buffer;
        } catch (error) {
            console.error(`Error creating drum sound ${type}:`, error);
            throw error;
        }
    }
}

function createFretboardContainer(index) {
    const container = document.createElement('div');
    container.className = 'fretboard-container';
    container.innerHTML = `
        <div class="controls">
            <select class="tuning-select" id="tuning-${index}">
                ${Object.entries(TUNINGS).map(([key, value]) =>
                    `<option value="${key}">${key} (${value.join('')})</option>`
                ).join('')}
            </select>
            <select id="key-${index}">
                ${NOTES.map(note => `<option>${note}</option>`).join('')}
            </select>
            <select id="scale-${index}">
                ${Object.keys(SCALES).map(scale =>
                    `<option value="${scale}">${scale.charAt(0).toUpperCase() + scale.slice(1)}</option>`
                ).join('')}
            </select>
        </div>
        <div id="fretboard-${index}" class="fretboard"></div>
    `;
    return container;
}
        
async function ensureAudioInitialized() {
    if (!AudioContextManager.context || AudioContextManager.context.state === 'suspended') {
        try {
            await AudioContextManager.initialize();
            if (AudioContextManager.context.state === 'suspended') {
                await AudioContextManager.context.resume();
            }
        } catch (error) {
            console.error('Audio initialization failed:', error);
            alert('Please click anywhere on the page to enable audio playback');
            throw error;
        }
    }
}
// Music Theory Utilities

// --- NEW GLOBAL HELPER -------------------------------------------
function getNoteFromScaleDegree(degree, key, scale) {
    // Convert the degree (0–6) into an actual note name in the chosen key
    const chromaticScale = ['C', 'Cs', 'D', 'Ds', 'E', 'F', 'Fs', 'G', 'Gs', 'A', 'As', 'B'];
    const keyIndex = chromaticScale.indexOf(standardizeNoteName(key));
    if (keyIndex === -1) return null;           // safety check

    const noteIndex = (keyIndex + scale[degree]) % 12;
    const note = chromaticScale[noteIndex];
    return flattenNote(note);                    // keep everything flat‑friendly
}
// ------------------------------------------------------------------
        
function standardizeNoteName(note) {
  if (!note) return 'C';
  const match = note.match(/^([A-G])([b#])?(\d)?$/);
  if (!match) return note.toUpperCase();
  let [, letter, accidental, octave] = match;
  letter = letter.toUpperCase();
  if (accidental === 'b') {
    const index = CHROMATIC.indexOf(letter);
    return CHROMATIC[(index - 1 + 12) % 12];
  } else if (accidental === '#') {
    const index = CHROMATIC.indexOf(letter);
    return CHROMATIC[(index + 1) % 12];
  }
  return letter;
}

       
function getNoteIndex(note) {
    const standardizedNote = standardizeNoteName(note);
    return NOTES.indexOf(standardizedNote);
}

const MIN_OCTAVE = 2;
const MAX_OCTAVE = 4;

function findNearestSampledNote(note, targetOctave = 3) {
    const cleanNote = standardizeNoteName(note).replace('m', '');
    const mappedNote = ENHARMONIC_MAP[cleanNote] || cleanNote;
    const targetIndex = NOTES.indexOf(toSampleNoteName(mappedNote));
    if (targetIndex === -1) {
        console.warn(`Note ${note} not found in NOTES.`);
        return { sampleKey: 'C3v12', semitoneDiff: 0 };
    }

    let bestMatch = null;
    let minDistance = Infinity;

    for (let sampleNote of SAMPLED_NOTES) {
        const sampleMapped = SAMPLE_NOTE_MAP[sampleNote] || sampleNote;
        const sampleIndex = NOTES.indexOf(ENHARMONIC_MAP[sampleMapped] || sampleMapped);
        for (let octave = MIN_OCTAVE; octave <= MAX_OCTAVE; octave++) {
            const noteMidi = targetIndex + targetOctave * 12;
            const sampleMidi = sampleIndex + octave * 12;
            const distance = Math.abs(noteMidi - sampleMidi);
            if (distance < minDistance) {
                minDistance = distance;
                bestMatch = {
                    sampleKey: `${sampleNote}${octave}v12`,
                    semitoneDiff: noteMidi - sampleMidi
                };
            }
        }
    }

    return bestMatch;
}



        
// Helper function to get note at specific fret
function getNoteAtFret(startNote, fretNumber) {
    const chromaticScale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const startIndex = chromaticScale.indexOf(standardizeNoteName(startNote));
    if (startIndex === -1) return startNote;
    
    const noteIndex = (startIndex + fretNumber) % 12;
    return chromaticScale[noteIndex];
}
        
function getChordFromFunction(chordFunction, key = 'C') {
    // Helper function to get note from scale degree
    
    // Initialize scales
    const majorScale = [0, 2, 4, 5, 7, 9, 11];
    const minorScale = [0, 2, 3, 5, 7, 8, 10];

    // Determine if we're in a minor key
    const isMinorKey = key.toLowerCase().includes('m');
    const actualKey = isMinorKey ? key.replace('m', '') : key;
    const scale = isMinorKey ? minorScale : majorScale;

    // Handle empty or invalid input
    if (!chordFunction) return null;

    // Parse the chord function
    // Updated regex to handle more chord variations
    let match = chordFunction.match(/^(b?[ivIV]+)([°ø]|maj|m|M)?([679]|11|13)?([b#]5|[b#]9|[b#]11|[b#]13)?(\([b#]5\)|\([b#]9\)|\([b#]11\)|\([b#]13\))?$/);
    if (!match) return null;

    let [_, roman, quality, extension, alteration, parenthesizedAlteration] = match;
    
    // Handle flattened degrees
    const isFlat = roman.startsWith('b');
    if (isFlat) roman = roman.substring(1);

    // Convert roman numeral to scale degree
    const romanToNumber = {
        'I': 0, 'II': 1, 'III': 2, 'IV': 3, 'V': 4, 'VI': 5, 'VII': 6,
        'i': 0, 'ii': 1, 'iii': 2, 'iv': 3, 'v': 4, 'vi': 5, 'vii': 6
    };

    let degree = romanToNumber[roman];
    if (degree === undefined) return null;

    // Store whether the original numeral was lowercase
    const isLowerCase = /^[b]?[iv]+$/.test(roman);

    // Apply flat modification if present
    if (isFlat) {
        degree = (degree - 1 + 7) % 7;
    }

    // Get the root note
    const rootNote = getNoteFromScaleDegree(degree, actualKey, scale);
    if (!rootNote) return null;

    // Determine chord quality
    let chordQuality = '';
    let chordExtension = '';
    let chordAlteration = '';

    // First check if there's an explicit quality specified
    if (quality === '°') {
        chordQuality = 'dim';
    } else if (quality === 'ø') {
        chordQuality = 'm7b5';
    } else if (quality === 'maj' || quality === 'M') {
        chordQuality = 'maj';
    } else if (quality === 'm') {
        chordQuality = 'm';
    } else {
        // If no explicit quality, check if it's lowercase (should be minor in major key)
        if (!isMinorKey && isLowerCase) {
            chordQuality = 'm';
        } else {
            // Use default qualities based on scale degree and mode
            if (isMinorKey) {
                const minorDefaultQualities = ['m', 'dim', 'maj', 'm', 'm', 'maj', 'maj'];
                chordQuality = minorDefaultQualities[degree];
            } else {
                const majorDefaultQualities = ['maj', 'm', 'm', 'maj', 'maj', 'm', 'dim'];
                chordQuality = majorDefaultQualities[degree];
            }
        }
    }

    // Handle extensions
    if (extension) {
        if (extension === '7') {
            // Special handling for dominant 7th
            if (chordQuality === 'maj' && (degree === 4 || chordFunction.toUpperCase().includes('V7'))) {
                chordQuality = '7';
            } else if (chordQuality === 'm') {
                chordQuality = 'm7';
            } else {
                chordQuality += '7';
            }
        } else {
            // Handle 9, 11, 13 extensions
            if (chordQuality === 'maj') {
                chordQuality = 'maj' + extension;
            } else if (chordQuality === 'm') {
                chordQuality = 'm' + extension;
            } else {
                chordQuality += extension;
            }
        }
    }

    // Handle alterations
    if (alteration) {
        chordAlteration = alteration;
    }

    // Handle parenthesized alterations
    if (parenthesizedAlteration) {
        chordAlteration += parenthesizedAlteration.replace(/[()]/g, '');
    }

    // Special cases for secondary dominants
    if (chordFunction.includes('7') && !isMinorKey && degree !== 4 && !isLowerCase) {
        chordQuality = '7'; // Make it dominant 7
    }

    // Special handling for diminished sevenths
    if (chordQuality === 'dim' && extension === '7') {
        chordQuality = 'dim7';
    }

    // Build the final chord symbol
    let chordSymbol = rootNote;
    
    // Add the chord quality
    if (chordQuality !== 'maj' || extension) {
        chordSymbol += chordQuality;
    }

    // Add any alterations
    if (chordAlteration) {
        chordSymbol += chordAlteration;
    }

    return chordSymbol;
}
        
    function parseChord(chord) {
            if (!chord) return ['C', 'maj'];
        
            // Updated regex to catch more qualities, including dom7, m7b5, and alt chords
            const regex = /^([A-Ga-g][b#]?)(maj7|m7b5|min7|m7|maj|min|dim7|dim|aug|sus2|sus4|add9|7b9|7#9|7b13|7#11|7|6|9|11|13|°|ø)?$/;
            const match = chord.match(regex);
        
            if (!match) {
                console.warn(`Unable to parse chord: ${chord}`);
                return [standardizeNoteName(chord), 'maj'];
            }
        
            let [, root, quality] = match;
            root = standardizeNoteName(root);
        
            if (!quality) quality = 'maj';
        
            switch (quality.toLowerCase()) {
                case 'min':
                case 'm':
                    quality = 'min';
                    break;
                case 'min7':
                case 'm7':
                    quality = 'min7';
                    break;
                case 'maj7':
                case 'maj':
                    quality = 'maj7';
                    break;
                case 'dim7':
                case '°':
                    quality = 'dim7';
                    break;
                case 'ø':
                case 'm7b5':
                    quality = 'm7b5';
                    break;
                case '7':
                    quality = '7';
                    break;
                default:
                    break; // leave as-is (e.g., add9, 9, 13, etc.)
            }
        
            return [root, quality];
        }


// Helper function for flat notes
function flattenNote(note) {
    const sharpToFlat = {
        'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'
    };
    return sharpToFlat[note] || note;
}

function getQualityValue(quality) {
    const qualityMap = {
        '': 'major',
        'm': 'minor',
        '7': 'dom7',
        'dom7': 'dom7',  // Add explicit mapping
        'maj7': 'maj7',
        'm7': 'min7',
        'min7': 'min7',
        'dim': 'dim',
        'min7b5': 'min7b5'
    };
    return qualityMap[quality] || 'major';
}
function suggestScaleForQuality(quality) {
    const scaleMap = {
        '': 'major',
        'maj7': 'major',
        'maj9': 'major',
        'maj13': 'major',
        'maj7#11': 'lydian',
        'm': 'dorian',
        'm7': 'dorian',
        'm9': 'dorian',
        'm11': 'dorian',
        'm13': 'dorian',
        'dom7': 'mixolydian',    // Ensure this mapping exists
        '7': 'mixolydian',       // Add this explicit mapping
        '9': 'mixolydian',
        '13': 'mixolydian',
        '7b9': 'bebopPhrygian',
        '7#9': 'mixolydian',
        '7#11': 'lydian',
        '7b13': 'mixolydian',
        '7#5': 'wholeHalf',
        '7b5': 'mixolydian',
        'dim7': 'diminished',
        'dim': 'diminished',
        'm7b5': 'locrian',
        'aug7': 'wholeHalf',
        'aug': 'wholeHalf',
        '6': 'major',
        'm6': 'melodicMinor',
        'sus4': 'mixolydian',
        'sus2': 'mixolydian',
        'add9': 'major',
        '7sus4': 'mixolydian',
        'minMaj7': 'melodicMinor',
        '7alt': 'altered'
    };
    return scaleMap[quality] || 'major';
}

    function getCompatibleScales(chord, quality) {
        const scaleChoices = {
            'major': ['major', 'lydian', 'mixolydian'],
            'minor': ['dorian', 'phrygian', 'aeolian'],
            'dominant': ['mixolydian', 'lydianDominant', 'altered', 'bebopDominant'],
            'halfDiminished': ['locrian', 'locrian#2'],
            'diminished': ['diminishedWH', 'diminishedHW'],
            'altered': ['altered', 'diminishedWH']
        };
    
    // Determine chord category
    let category = 'major';
    if (quality.includes('m7b5')) category = 'halfDiminished';
    else if (quality.includes('dim')) category = 'diminished';
    else if (quality.includes('m')) category = 'minor';
    else if (quality.includes('7')) category = 'dominant';
    else if (quality.includes('alt')) category = 'altered';
    
    return scaleChoices[category] || ['major'];
}

    function updateChordProgression(measure) {
    const rootSelect = measure.querySelector('.root-note');
    const qualitySelect = measure.querySelector('.chord-quality');
    const scaleSelect = measure.querySelector('.scale-select');
    
    if (!rootSelect || !qualitySelect || !scaleSelect) return;
    
    const root = rootSelect.value;
    const quality = qualitySelect.value;
    
    // Get compatible scales
    const compatibleScales = getCompatibleScales(root, quality);
    
    // Update scale options
    scaleSelect.innerHTML = compatibleScales
        .map(scale => `<option value="${scale}">${scale}</option>`)
        .join('');
    
    // Set default scale
    scaleSelect.value = suggestScaleForQuality(quality);
    
    // Update fretboard if this is the current measure
    if (measure === UI.elements.measures.children[AppState.currentMeasure]) {
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, root, scaleSelect.value, tuning);
    }
}
// DOM Utilities
function createKeyOptions(selected = 'C') {
    return NOTES.map(note =>
        `<option value="${note}"${note === selected ? ' selected' : ''}>${note}</option>`
    ).join('');
}

function createQualityOptions(selected = 'major') {
    const qualities = [
        { value: 'major', label: 'Major' },
        { value: 'minor', label: 'Minor' },
        { value: 'dom7', label: '7' },
        { value: 'maj7', label: 'Maj7' },
        { value: 'min7', label: 'Min7' },
        { value: 'min7b5', label: 'Min7b5 (Half Diminished)' }
    ];
    return qualities.map(q =>
        `<option value="${q.value}"${q.value === selected ? ' selected' : ''}>${q.label}</option>`
    ).join('');
}

function createScaleOptions(selected = 'major') {
    return Object.keys(SCALES).map(scale =>
        `<option value="${scale}"${scale === selected ? ' selected' : ''}>${scale.charAt(0).toUpperCase() + scale.slice(1)}</option>`
    ).join('');
}

// Audio Playback
// Note utilities
// Note utilities
const NoteUtils = {
    validateNote(noteName) {
        if (!noteName) {
            throw new Error('No note name provided');
        }
        const sampleNote = toSampleNoteName(noteName);
        if (!sampleNote) {
            throw new Error(`Invalid note format: ${noteName}`);
        }
        return sampleNote;
    },

    addOctave(sampleNote, defaultOctave = '3') {
        const octaveMatch = sampleNote.match(/([A-G][sb]?)(\d)?/);
        if (!octaveMatch) return null;
        
        const [, noteBase, octave] = octaveMatch;
        return `${noteBase}${octave || defaultOctave}`;
    },

    calculateVolume(baseVolume, controlVolume = 0.7) {
        return Math.max(0, Math.min(1, baseVolume * controlVolume));
    }
};

// Audio playback utilities
const AudioUtils = {
    async ensureBuffer(sampleKey) {
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
        if (!buffer) {
            throw new Error(`No piano sample found for ${sampleKey}`);
        }
        return buffer;
    },

    createStopTimeout(source, duration, sampleKey) {
        setTimeout(() => {
            try {
                source.stop();
            } catch (error) {
                console.error(`Error stopping source for ${sampleKey}:`, error);
            }
        }, duration);
    }
};

// Chord utilities
const ChordUtils = {
    validateChordPlayback() {
        if (!AudioContextManager.samplesLoaded) {
            throw new Error('Piano samples not loaded yet');
        }

        const chordsEnabled = UI.elements.chordsEnabled;
        if (!chordsEnabled) {
            throw new Error('Chords enabled element not found');
        }
        if (!chordsEnabled.classList.contains('active')) {
            return false;
        }
        return true;
    },

    applyInversion(chordNotes, shouldInvert) {
        if (!shouldInvert) return chordNotes;

        const inversionPool = ['drop2', 'drop2', 'drop3', 'drop2and4'];
        const inversionType = inversionPool[Math.floor(Math.random() * inversionPool.length)];
        const rootNote = chordNotes[0];
        const upperNotes = chordNotes.slice(1);

        const inversionMap = {
            drop2: (notes) => notes.length >= 2 ? 
                [rootNote, ...upperNotes.slice(0, 1), ...upperNotes.slice(2), upperNotes[1]] : notes,
            drop3: (notes) => notes.length >= 3 ? 
                [rootNote, upperNotes[0], ...upperNotes.slice(2), upperNotes[1]] : notes,
            drop2and4: (notes) => notes.length >= 4 ? 
                [rootNote, ...upperNotes.slice(0, 1), ...upperNotes.slice(2, 3), 
                 ...upperNotes.slice(4), upperNotes[1], upperNotes[3]] : notes
        };

        return (inversionMap[inversionType] || ((n) => n))(chordNotes);
    }
};

async function playNote(noteName, volume = 0.7, duration = null) {
    try {
        await AudioContextManager.ensureAudioContext();

        // Validate and prepare note
        const sampleNote = NoteUtils.validateNote(noteName);
        const sampleKey = NoteUtils.addOctave(sampleNote);
        
        // Calculate volume
        const fretboardVolume = parseFloat(UI.elements.fretboardVolume?.value ?? 0.7);
        const finalVolume = NoteUtils.calculateVolume(volume, fretboardVolume);
        if (finalVolume <= 0) return;

        // Get and validate buffer
        const buffer = await AudioUtils.ensureBuffer(sampleKey);
        
        // Play note
        const destination = AudioContextManager.reverbNode || AudioContextManager.context.destination;
        const source = AudioContextManager.playSample(buffer, 0, destination, finalVolume);

        // Set up stop timeout
        const effectiveDuration = duration || (buffer.duration * 1000) || 1000;
        AudioUtils.createStopTimeout(source, effectiveDuration, sampleKey);

    } catch (error) {
        console.error(`playNote: ${error.message}`);
    }
}

async function playChord(root, quality, startTime = 0, duration = null, shouldInvert = false) {
    try {
        await AudioContextManager.ensureAudioContext();

        // Validate chord playback state
        if (!ChordUtils.validateChordPlayback()) return;

        // Calculate volume
        const chordVolume = parseFloat(UI.elements.chordVolume?.value ?? 0.7);
        const finalVolume = NoteUtils.calculateVolume(1, chordVolume);
        if (finalVolume <= 0) return;

        // Get and validate chord notes
        const chordNotes = getChordNotes(root, quality);
        if (!chordNotes?.length) {
            throw new Error(`No valid notes for chord ${root} ${quality}`);
        }

        // Stop existing sounds and set up gain node
        AudioContextManager.stopAllSounds();
        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.value = finalVolume;
        const destination = AudioContextManager.reverbNode || AudioContextManager.context.destination;
        gainNode.connect(destination);
        AudioContextManager.currentChordGain = gainNode;

        // Apply inversion if needed
        const finalChordNotes = ChordUtils.applyInversion(chordNotes, shouldInvert);

        // Calculate swing
        const swingFactor = SwingControl.getSwingAmount() / 500; // Convert 0-20 to 0-0.04
        const maxSwingMs = swingFactor * 100;

        // Play notes
        await Promise.all(finalChordNotes.map(async (note, index) => {
            try {
                const sampleNote = NoteUtils.validateNote(note);
                const sampleKey = NoteUtils.addOctave(sampleNote);
                const buffer = await AudioUtils.ensureBuffer(sampleKey);

                const noteVolume = index === 0 ? 1.2 : 0.8;
                const swingOffset = (Math.random() - 0.5) * 2 * maxSwingMs / 1000;

                const source = AudioContextManager.playSample(
                    buffer,
                    startTime + swingOffset,
                    gainNode,
                    noteVolume
                );

                const effectiveDuration = (duration || buffer.duration || 2) * 1000;
                AudioUtils.createStopTimeout(source, effectiveDuration, sampleKey);
            } catch (error) {
                console.error(`Error playing note in chord: ${error.message}`);
            }
        }));

    } catch (error) {
        console.error(`playChord: ${error.message}`);
        AudioContextManager.stopAllSounds();
    }
}

// Make functions globally available
window.playNote = playNote;
window.playChord = playChord;
window.UI = UIManager;
window.Audio = AudioContextManager.getInstance();

        
function getChordNotes(root, quality) {
  const CHORD_INTERVALS = {
    'maj': [0, 4, 7],
    'min': [0, 3, 7],
    'minor': [0, 3, 7],
    'major': [0, 4, 7],
    'dim': [0, 3, 6],
    'aug': [0, 4, 8],
    '6': [0, 4, 9],
    'm6': [0, 3, 9],
    'min6': [0, 3, 9],
    '7': [0, 4, 7, 10],
    'dom7': [0, 4, 7, 10],
    'maj7': [0, 4, 7, 11],
    'min7': [0, 3, 7, 10],
    'm7': [0, 3, 7, 10],
    'dim7': [0, 3, 6, 9],
    'm7b5': [0, 3, 6, 10],
    'min7b5': [0, 3, 6, 10],
    'sus2': [0, 2, 7],
    'sus4': [0, 5, 7],
    'add9': [0, 4, 7, 14]
  };

  const standardizedRoot = standardizeNoteName(root);
  let rootIndex = CHROMATIC.indexOf(standardizedRoot);

  if (rootIndex === -1) {
    rootIndex = CHROMATIC.indexOf(root);
    if (rootIndex === -1) rootIndex = 0; // fallback to C
  }

  const normQuality = quality?.toLowerCase();
  let intervals = CHORD_INTERVALS[normQuality];

  if (!intervals) {
    console.warn(`Unknown chord quality "${quality}", defaulting to major`);
    intervals = CHORD_INTERVALS['maj'];
  }

  const chordNotes = intervals.map(semitones => {
    const noteIndex = (rootIndex + semitones) % 12;
    return CHROMATIC[noteIndex];
  });

  return chordNotes;
}


async function playMetronomeSound(baseVolume) {
    if (!AudioContextManager.context) return;

    // === Retrieve UI values ===
    const metronomeVolumeControl = document.getElementById('metronome-volume');
    const metronomeVolume = parseFloat(metronomeVolumeControl?.value ?? 1);
    const combinedVolume = baseVolume * metronomeVolume;
    if (combinedVolume <= 0) return;

    const soundType = UI.elements.soundType?.value || 'click';
    const beatElement = document.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    if (!beatElement) return;

    const drumSounds = beatElement.dataset.sound?.split(',') || [];
    const baseVolumeValue = parseFloat(beatElement.dataset.baseVolume || 0);
    const isAccent = baseVolumeValue >= 1 && ['kick', 'snare'].includes(drumSounds[0]);
    const accentBoost = parseFloat(UI.elements.accentIntensity?.value || 1);
    let adjustedVolume = isAccent ? Math.min(combinedVolume * accentBoost, 1) : combinedVolume;

    // === Iterate over drum sounds ===
    for (let soundKey of drumSounds) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;

        const buffer = await resolveMetronomeSoundBuffer(soundKey, soundType);
        if (!buffer) continue;

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;

        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.value = computeFinalVolume(soundKey, soundType, adjustedVolume, drumSounds.length);

        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);

        if (soundType === 'drums' && AudioContextManager.reverbNode) {
            const reverbGain = AudioContextManager.context.createGain();
            reverbGain.gain.value = 0.1;
            source.connect(reverbGain);
            reverbGain.connect(AudioContextManager.reverbNode);
        }

        try {
            source.start(0);
        } catch (error) {
            console.error('Error playing metronome sound:', error);
        }
    }
}
async function resolveMetronomeSoundBuffer(soundKey, soundType) {
    const currentSet = drumSoundSets[currentDrumSetIndex];

    if (soundType === 'drums' && soundKey !== 'default') {
        let sampleFile;
        switch (soundKey) {
            case 'kick': sampleFile = currentSet.kick; break;
            case 'snare': sampleFile = currentSet.snare; break;
            case 'hihat': sampleFile = currentSet.hihat; break;
            default: sampleFile = null;
        }

        if (sampleFile) {
            try {
                const response = await fetch(`./${sampleFile}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                return await AudioContextManager.context.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error(`Failed to load drum sample: ${sampleFile}`, error);
                return AudioContextManager.soundBuffers[soundKey]; // fallback
            }
        }
    }

    // fallback for non-drum types
    return AudioContextManager.soundBuffers[soundKey] || AudioContextManager.soundBuffers['click'];
}
function computeFinalVolume(soundKey, soundType, baseVolume, totalSounds) {
    let finalVolume = baseVolume;

    if (soundType === 'drums') {
        if (soundKey === 'hihat' && totalSounds > 1) {
            finalVolume *= 0.5;
        } else if (soundKey === 'kick') {
            finalVolume *= 1.2;
        } else if (soundKey === 'snare') {
            finalVolume *= 1.1;
        }
    }

    return Math.min(finalVolume, 1.0);
}

        
        
function onMetronomeInstrumentChange(selectedInstrument) {
    const drumSetToggleBtn = document.getElementById('drumsettogglebtn');
    if (drumSetToggleBtn) {
        // Only update the display, don't add another event listener
        drumSetToggleBtn.style.display = selectedInstrument === 'drums' ? 'inline-block' : 'none';
        
        // Initialize the button text if needed
        if (selectedInstrument === 'drums' && !drumSetToggleBtn.textContent) {
            drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
        }
    } else {
        console.warn('Drum set toggle button not found in the DOM');
    }
}
        
async function playDrumSample(type) {
    if (!AudioContextManager.context) return;
    
    const set = drumSoundSets[currentDrumSetIndex];
    let sampleFile;
    
    // Map the type to the current set's sample file
    switch(type) {
    case 'snare': sampleFile = set.snare; break;
    case 'hihat': sampleFile = set.hihat; break;
    case 'kick': sampleFile = set.kick; break;
    default: sampleFile = null;
    }
    
    try {
        let buffer;
        // Try to load the current set's sample
        const response = await fetch(`./${sampleFile}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        buffer = await AudioContextManager.context.decodeAudioData(arrayBuffer);
        
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        
        const gainNode = AudioContextManager.context.createGain();
        // Get the metronome volume
        const metronomeVolume = parseFloat(UI.elements.metronomeVolume.value);
        
        // Apply sound-specific volume adjustments
        let finalVolume = metronomeVolume;
        if (type === 'kick') {
            finalVolume *= 1.2; // Slightly boost kick
        } else if (type === 'snare') {
            finalVolume *= 1.1; // Slightly boost snare
        } else if (type === 'hihat') {
            finalVolume *= 0.8; // Slightly reduce hihat
        }
        
        // Ensure volume doesn't exceed 1.0
        finalVolume = Math.min(finalVolume, 1.0);
        gainNode.gain.value = finalVolume;
        
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);
        
        // Add slight reverb for more depth
        if (AudioContextManager.reverbNode) {
            const reverbGain = AudioContextManager.context.createGain();
            reverbGain.gain.value = 0.1; // Subtle reverb
            source.connect(reverbGain);
            reverbGain.connect(AudioContextManager.reverbNode);
        }
        
        source.start(0);
    } catch (error) {
        console.error(`Failed to play drum sample: ${type}`, error);
        try {
            // Fall back to default drum sounds if loading fails
            const fallbackBuffer = AudioContextManager.soundBuffers[type] || 
                await AudioContextManager.createDrumSound(type);
            const source = AudioContextManager.context.createBufferSource();
            source.buffer = fallbackBuffer;
            
            const gainNode = AudioContextManager.context.createGain();
            gainNode.gain.value = parseFloat(UI.elements.metronomeVolume.value);
            
            source.connect(gainNode);
            gainNode.connect(AudioContextManager.context.destination);
            
            source.start(0);
        } catch (fallbackError) {
            console.error('Failed to play fallback sound:', fallbackError);
        }
    }
}
        
function createFretboard(container, tuning) {
    container.innerHTML = '';

    // Create fret lines and fret numbers
    for (let i = 0; i <= 12; i++) {
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / 12) * 100}%`;
        container.appendChild(fretLine);

        if (i > 0) { // Add fret numbers for frets 1-12
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            fretNumber.style.left = `${((i - 0.5) / 12) * 100}%`;
            container.appendChild(fretNumber);
        }
    }

    // Create string lines
    for (let i = 0; i < 6; i++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        stringLine.style.top = `${(i / 5) * 100}%`;
        container.appendChild(stringLine);
    }

    // Add fret markers (dots)
    const markerPositions = [3, 5, 7, 9, 12]; // Frets with markers
    markerPositions.forEach(position => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((position - 0.5) / 12) * 100}%`;

        if (position === 12) {
            // Double markers at the 12th fret
            const topMarker = marker.cloneNode(true);
            topMarker.style.top = '25%';
            container.appendChild(topMarker);

            const bottomMarker = marker.cloneNode(true);
            bottomMarker.style.top = '75%';
            container.appendChild(bottomMarker);
        } else {
            // Single marker
            marker.style.top = '50%';
            container.appendChild(marker);
        }
    });
}
        
function updateFretboardNotes(container, rootNote, scale, tuning) {
    if (!(container instanceof HTMLElement)) {
        console.error('Invalid container element');
        return;
    }
    if (!NOTES.includes(standardizeNoteName(rootNote))) {
        console.error(`Invalid root note: ${rootNote}`);
        return;
    }
    if (!SCALES[scale]) {
        console.error(`Invalid scale: ${scale}`);
        return;
    }
    if (!Array.isArray(tuning) || tuning.length !== 6) {
        console.error('Invalid tuning');
        return;
    }
    container.querySelectorAll('.note').forEach(note => note.remove());
    if (container.id === 'chord-fretboard') {
        const measures = UI.elements.measures.children;
        if (measures.length > 0 && AppState.currentMeasure < measures.length) {
            const currentMeasureElement = measures[AppState.currentMeasure];
            const chordRoot = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const chordQuality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            if (chordRoot && chordQuality && scaleRoot && scaleType) {
                let displayQuality = chordQuality;
                switch (chordQuality) {
                    case 'dom7': displayQuality = '7'; break;
                    case 'maj7': displayQuality = 'Maj7'; break;
                    case 'min7': displayQuality = 'm7'; break;
                    case 'min7b5': displayQuality = 'm7b5'; break;
                    case 'minor': displayQuality = 'm'; break;
                }
                let displayScale = scaleType.charAt(0).toUpperCase() + scaleType.slice(1);
                displayScale = displayScale.replace(/([A-Z])/g, ' $1').trim();
                UI.elements.scaleDisplay.textContent = `${scaleRoot} ${displayScale} over ${chordRoot} ${displayQuality}`;
            }
        }
    }
    const scaleIntervals = SCALES[scale];
    const standardizedRoot = standardizeNoteName(rootNote);
    const rootIndex = NOTES.indexOf(standardizedRoot);
    const scaleNotes = scaleIntervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        return NOTES[noteIndex];
    });
    console.log(`[updateFretboardNotes] scaleNotes for ${rootNote} ${scale}: ${scaleNotes.join(',')}`);
    for (let string = 0; string < 6; string++) {
        const openNote = tuning[string];
        const openNoteIndex = NOTES.indexOf(openNote);
        for (let fret = 0; fret <= 12; fret++) {
            const noteIndex = (openNoteIndex + fret) % 12;
            const currentNote = NOTES[noteIndex];
            if (scaleNotes.includes(currentNote)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNote;
                const fretOffset = fret === 0 ? 0 : ((fret - 0.5) / 12) * 100;
                noteElement.style.left = `${fretOffset}%`;
                noteElement.style.top = `${(string / 5) * 100}%`;
                const degree = scaleNotes.indexOf(currentNote);
                if (currentNote === standardizedRoot) {
                    noteElement.style.backgroundColor = '#BD2031';
                } else if ([2, 4, 6].includes(degree)) {
                    noteElement.style.backgroundColor = '#006400';
                } else {
                    noteElement.style.backgroundColor = '#4CAF50';
                }
            noteElement.addEventListener('click', async () => {
                try {
                    await AudioContextManager.ensureAudioContext();
                    // Use fretboard volume for note playback
                    const volume = parseFloat(UI.elements.fretboardVolume?.value ?? 0.7);
                    await playNote(currentNote, volume);
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
                    setTimeout(() => {
                        noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    }, 100);
                } catch (error) {
                    console.error('Error playing note:', error);
                }
            });
                noteElement.addEventListener('mouseenter', () => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.1)';
                });
                noteElement.addEventListener('mouseleave', () => {
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                });
                container.appendChild(noteElement);
            }
        }
    }
    log(`Fretboard updated with ${rootNote} ${scale} scale`);
}
        
function createBeats() {
    const container = document.querySelector('.beats-container');
    container.innerHTML = '';

    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value;

    let totalBeats = timeSignature === 4 ? 8 : timeSignature; // 8 beats for 4/4 time (eighth notes)

    const beatConfigs = {
        4: { 
            strongBeats: [0, 4], 
            drumSounds: { 
                0: { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D' },
                2: { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50' },
                4: { sound: ['kick', 'hihat'], volume: '1', color: '#1F618D' },
                6: { sound: ['snare', 'hihat'], volume: '1', color: '#4CAF50' }
            }
        },
        3: { strongBeats: [0, 3, 6] },
        6: { strongBeats: [0, 3] },
        7: { strongBeats: [0, 4] },
        8: { strongBeats: [0, 4] },
        12: {
            strongBeats: [0, 4, 6, 10],
            drumSounds: { 0: 'kick', 4: 'snare', 6: 'kick', 10: 'snare' }
        }
    };

    const config = beatConfigs[timeSignature] || { strongBeats: [0] };

    for (let i = 0; i < totalBeats; i++) {
        const beat = document.createElement('div');
        beat.className = 'beat';
        beat.dataset.beat = i;

        if (timeSignature === 4) {
            const isQuarterNote = i % 2 === 0;
            beat.textContent = `${Math.floor(i / 2 + 1)}${isQuarterNote ? '' : '&'}`;

            if (soundType === 'drums') {
                // Set default hi-hat for all beats
                let volume = '0.7';
                let sound = 'hihat';
                let color = '#9E9E9E';

                // Check if this beat should also have kick or snare
                const drumConfig = config.drumSounds[i];
                if (drumConfig) {
                    sound = drumConfig.sound;  // This will be an array ['kick', 'hihat'] or ['snare', 'hihat']
                    volume = drumConfig.volume;
                    color = drumConfig.color;
                }

                beat.dataset.baseVolume = volume;
                beat.dataset.volume = volume;
                beat.dataset.sound = Array.isArray(sound) ? sound.join(',') : sound;
                beat.style.backgroundColor = color;
            } else {
                // For click and woodblock, only play on quarter notes
                if (isQuarterNote) {
                    beat.dataset.sound = soundType;
                    beat.dataset.baseVolume = i === 0 ? '1' : '0.3';
                    beat.dataset.volume = i === 0 ? '1' : '0.3';
                    beat.style.backgroundColor = i === 0 ? '#1F618D' : '#4CAF50';
                } else {
                    beat.dataset.sound = 'silent';
                    beat.dataset.baseVolume = '0';
                    beat.dataset.volume = '0';
                    beat.style.backgroundColor = '#9E9E9E';
                }
            }
        } else {
            beat.textContent = i + 1;
            const isStrong = config.strongBeats.includes(i);

            if (soundType === 'drums') {
                beat.dataset.sound = isStrong ? 'kick' : 'hihat';
                beat.dataset.baseVolume = '1';
                beat.dataset.volume = '1';
                beat.style.backgroundColor = isStrong ? '#1F618D' : '#9E9E9E';
            } else {
                beat.dataset.sound = soundType;
                beat.dataset.baseVolume = isStrong ? '1' : '0.3';
                beat.dataset.volume = isStrong ? '1' : '0.3';
                beat.style.backgroundColor = isStrong ? '#1F618D' : '#4CAF50';
            }
        }

        beat.addEventListener('click', () => toggleBeatState(beat, timeSignature, soundType));
        container.appendChild(beat);
    }
}
        
function toggleBeatState(beat, timeSignature, soundType) {
    const isEighth = timeSignature === 4 && parseInt(beat.dataset.beat) % 2 === 1;
    const states = soundType === 'drums' && timeSignature === 4 ? (
        isEighth ? [
            { volume: '1', sound: 'hihat', color: '#9E9E9E' },
            { volume: '1', sound: 'kick', color: '#1F618D' },
            { volume: '1', sound: 'snare', color: '#4CAF50' },
            { volume: '0', sound: 'silent', color: '#6666' }
        ] : [
            { volume: '1', sound: 'kick', color: '#1F618D' },
            { volume: '1', sound: 'snare', color: '#4CAF50' },
            { volume: '1', sound: 'hihat', color: '#9E9E9E' },
            { volume: '0', sound: 'silent', color: '#6666' }
        ]
    ) : [
        { volume: '1', sound: 'default', color: '#1F618D' },
        { volume: '0.3', sound: 'default', color: '#4CAF50' },
        { volume: '0', sound: 'default', color: '#9E9E9E' }
    ];
    const currentIndex = states.findIndex(state =>
        state.volume === beat.dataset.volume && state.sound === beat.dataset.sound
    );
    const nextState = states[(currentIndex + 1) % states.length];
    beat.dataset.volume = nextState.volume;
    beat.dataset.sound = nextState.sound;
    beat.style.backgroundColor = nextState.color;
}

async function playBeat() {
    // Remove active class from all beats and highlight current beat
    const beats = document.querySelectorAll('.beat');
    beats.forEach(beat => beat.classList.remove('active'));
    
    const currentBeatElement = beats[AppState.currentBeat];
    if (currentBeatElement) {
        currentBeatElement.classList.add('active');
        const volume = parseFloat(currentBeatElement.dataset.volume) || 0;
        await playMetronomeSound(volume);
    }

    const measures = Array.from(UI.elements.measures.children);
    const timeSignature = parseInt(UI.elements.timeSignature.value);

    if (measures.length > 0) {
        const currentMeasureElement = measures[AppState.currentMeasure];
        if (currentMeasureElement) {
            const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;

            if (root && quality && scaleRoot && scaleType) {
                const chordTuning = TUNINGS[UI.elements.chordTuning.value];
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);
                
                const beatDuration = 60 / AppState.tempo;
                if (timeSignature === 4) {
                    if (AppState.currentBeat === 0) {
                        // First chord in root position
                        await playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 2, false);
                    } else if (AppState.currentBeat === 4) {
                        // Second chord with inversion
                        await playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * 2, true);
                    }
                } else {
                    if (AppState.currentBeat === 0) {
                        // First chord in root position
                        await playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * (timeSignature/2), false);
                    } else if (AppState.currentBeat === Math.floor(timeSignature/2)) {
                        // Second chord with inversion
                        await playChord(root, quality, AudioContextManager.context.currentTime, beatDuration * (timeSignature/2), true);
                    }
                }
            }
        }
    }

    // Update measure highlighting
    if (measures.length > 0) {
        measures.forEach((measure, index) => {
            measure.classList.toggle('active', index === AppState.currentMeasure);
        });
    }

    // Update beat counter and measure counter
    const totalBeats = timeSignature === 4 ? 8 : timeSignature;
    AppState.currentBeat = (AppState.currentBeat + 1) % totalBeats;
    
    if (AppState.currentBeat === 0 && measures.length > 0) {
        AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
    }
}

async function startPlayback() {
    try {
        await ensureAudioInitialized();
        
        if (AppState.isPlaying) return;
        
        const timeSignature = parseInt(UI.elements.timeSignature.value);
        const measures = UI.elements.measures.children;
        
        if (measures.length === 0) {
            console.warn('No measures defined. Please add at least one measure.');
            return;
        }
        
        let interval = (60 / AppState.tempo) * 1000;
        if (timeSignature === 4) {
            interval = interval / 2;
        }
        
        AppState.updateState({ currentBeat: 0, currentMeasure: 0 });
        clearInterval(AppState.intervalId);
        
        const currentMeasureElement = measures[AppState.currentMeasure];
        if (currentMeasureElement) {
            const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            
            if (root && quality && scaleRoot && scaleType) {
                const chordTuning = TUNINGS[UI.elements.chordTuning.value];
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);
                
                try {
                    await playChord(root, quality);
                } catch (error) {
                    console.error('Failed to play initial chord:', error);
                }
            }
        }
        
        AppState.intervalId = setInterval(playBeat, interval);
        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started");
        
    } catch (error) {
        console.error('Failed to start playback:', error);
        alert('Please try clicking the start button again');
        stopPlayback(); // Ensure everything is reset if playback fails
        UI.elements.startStopButton.textContent = 'Start';
    }
}

function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false, currentBeat: 0, currentMeasure: 0 });
    const beats = document.querySelectorAll('.beat');
    beats.forEach(beat => beat.classList.remove('active'));
    const measures = UI.elements.measures.children;
    Array.from(measures).forEach(measure => measure.classList.remove('active'));
    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, AudioContextManager.context.currentTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, AudioContextManager.context.currentTime + 0.1);
        AudioContextManager.currentChordGain = null;
    }
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped");
}

// Chord Progression Management
function loadProgression(progressionName, overrideKey = null) {
    if (!progressionName || !progressions[progressionName]) {
        console.error(`Invalid progression name: ${progressionName}`);
        return;
    }

    const progression = progressions[progressionName];
    const selectedKey = overrideKey || progression.defaultKey || "C";
    UI.elements.keySelect.value = selectedKey;

    UI.elements.measures.innerHTML = '';

    progression.progression.forEach((chordFunction, index) => {
        const chord = getChordFromFunction(chordFunction, selectedKey);
        const [root, quality] = parseChord(chord);
        
        // Get the proper quality value and suggested scale
        const qualityValue = getQualityValue(quality);
        const suggestedScale = suggestScaleForQuality(qualityValue);

        const measure = document.createElement('div');
        measure.className = 'measure';
        measure.innerHTML = `
            <span class="measure-number">${index + 1}</span>
            <div class="chord-controls">
                <select class="root-note">${createKeyOptions(root)}</select>
                <select class="chord-quality">${createQualityOptions(qualityValue)}</select>
            </div>
            <div class="scale-controls">
                <select class="second-key">${createKeyOptions(root)}</select>
                <select class="scale-select">${createScaleOptions(suggestedScale)}</select>
            </div>
        `;

        UI.elements.measures.appendChild(measure);
        
        // Explicitly set the correct scale based on chord quality
        const scaleSelect = measure.querySelector('.scale-select');
        if (quality === '7' || quality === 'dom7') {
            scaleSelect.value = 'mixolydian';
        } else if (quality === 'min7' || quality === 'm7') {
            scaleSelect.value = 'dorian';
        } else if (quality === 'maj7') {
            scaleSelect.value = 'major';
        } else if (quality === 'min7b5') {
            scaleSelect.value = 'locrian';
        } else if (quality === 'm' || quality === 'minor') {
            scaleSelect.value = 'minor';
        }

    });

    updateMeasureNumbers();
    addFirstChordListener();

    // Update the fretboard with the first measure's scale
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key').value;
        const scaleType = firstMeasure.querySelector('.scale-select').value;
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }

    log(`Loaded progression "${progressionName}" in key: ${selectedKey}`);
}

function updateProgressionKey(newKey) {
    const selectedProgression = UI.elements.progressionSelect.value;
    if (!selectedProgression) return;
    const progression = progressions[selectedProgression];
    if (!progression) return;
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const chordFunc = progression.progression[index];
        if (!chordFunc) return;
        const chord = getChordFromFunction(newKey, chordFunc);
        const [root, quality] = parseChord(chord);
        const rootSelect = measure.querySelector('.root-note');
        const qualitySelect = measure.querySelector('.chord-quality');
        const secondKeySelect = measure.querySelector('.second-key');
        const scaleSelect = measure.querySelector('.scale-select');
        if (rootSelect) rootSelect.value = standardizeNoteName(root);
        if (qualitySelect) qualitySelect.value = getQualityValue(quality);
        if (secondKeySelect) secondKeySelect.value = standardizeNoteName(root);
        if (scaleSelect) scaleSelect.value = suggestScaleForQuality(getQualityValue(quality));
    });
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRoot = firstMeasure.querySelector('.second-key').value;
        const scaleType = firstMeasure.querySelector('.scale-select').value;
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning);
    }
    log(`Progression updated to key: ${newKey}`);
}

function addMeasure(chord = 'C', quality = 'major', scaleRoot = 'C', scaleType = 'major') {
    const measure = document.createElement('div');
    measure.className = 'measure';
    const measureCount = UI.elements.measures.children.length + 1;
    measure.innerHTML = `
        <span class="measure-number">${measureCount}</span>
        <div class="chord-controls">
            <select class="root-note">${createKeyOptions(chord)}</select>
            <select class="chord-quality">${createQualityOptions(quality)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key">${createKeyOptions(scaleRoot)}</select>
            <select class="scale-select">${createScaleOptions(scaleType)}</select>
        </div>
    `;

    // Add the measure to the measures container
    UI.elements.measures.appendChild(measure);

    // Set up event listeners for the new measure's controls
    const rootSelect = measure.querySelector('.root-note');
    const qualitySelect = measure.querySelector('.chord-quality');
    const scaleRootSelect = measure.querySelector('.second-key');
    const scaleTypeSelect = measure.querySelector('.scale-select');

    // Add change event listeners
    rootSelect.addEventListener('change', () => updateChordProgression(measure));
    qualitySelect.addEventListener('change', () => updateChordProgression(measure));
    scaleRootSelect.addEventListener('change', () => updateChordProgression(measure));
    scaleTypeSelect.addEventListener('change', () => updateChordProgression(measure));

    // Set initial values
    rootSelect.value = chord;
    qualitySelect.value = quality;
    scaleRootSelect.value = scaleRoot;
    scaleTypeSelect.value = scaleType;

    // Update measure numbers
    updateMeasureNumbers();

    // Return the measure element in case it's needed
    return measure;
}
        
function removeMeasure() {
    const measures = UI.elements.measures.children;
    if (measures.length > 0) {
        measures[measures.length - 1].remove();
        updateMeasureNumbers();
        log(`Removed last measure`);
    }
}

function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const number = measure.querySelector('.measure-number');
        if (number) number.textContent = index + 1;
    });
}


function setupEventListeners() {
    document.addEventListener('click', async () => {
        try {
            await ensureAudioInitialized();
        } catch (error) {
            console.error('Failed to initialize audio on click:', error);
        }
    }, { once: true });
    
    UI.elements.startStopButton.addEventListener('click', () => {
        if (AppState.isPlaying) {
            stopPlayback();
        } else {
            startPlayback();
        }
    });

    // Initial visibility of drum set toggle button
    const drumSetToggleBtn = document.getElementById('drumsettogglebtn');
    if (drumSetToggleBtn) {
        drumSetToggleBtn.style.display = 
            document.getElementById('sound-type').value === 'drums' ? 'inline-block' : 'none';
        
        // Add event listener for sound type change
        document.getElementById('sound-type').addEventListener('change', function(e) {
            drumSetToggleBtn.style.display = e.target.value === 'drums' ? 'inline-block' : 'none';
            createBeats(); // Recreate beats with new sound type
            onMetronomeInstrumentChange(e.target.value);
        });
        
        // Add event listener for drum set toggle button
        drumSetToggleBtn.addEventListener('click', () => {
            currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
            drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
        });
        
        // Initialize the button text with the first drum set name
        drumSetToggleBtn.textContent = drumSoundSets[0].name;
    } else {
        console.warn('Drum set toggle button not found. Check the ID: drumsettogglebtn');
    }

let colorMode = 0;
UI.elements.darkModeToggle.addEventListener('click', () => {
  colorMode = (colorMode + 1) % 3;
  document.body.className = `dark-mode-${colorMode}`;
});
// Initialization
// Helper functions for initialization
async function initializeUIComponents() {
    UI.init();
    await AudioContextManager.initialize();
    createBeats();
}

function initializeChordFretboard() {
    if (!UI.elements.chordFretboard) {
        console.warn('Chord fretboard element not found');
        return;
    }
    
    createFretboard(UI.elements.chordFretboard, TUNINGS.standard);
    updateFretboardNotes(UI.elements.chordFretboard, 'C', 'major', TUNINGS.standard);
    
    // Set up chord fretboard tuning listener
    if (!UI.elements.chordTuning) {
        console.warn('Chord tuning element not found');
        return;
    }

    UI.elements.chordTuning.addEventListener('change', () => {
        const measures = document.getElementsByClassName('measure');
        if (!measures.length || typeof AppState.currentMeasure !== 'number' || AppState.currentMeasure >= measures.length) {
            console.warn('No valid measures or invalid currentMeasure');
            return;
        }

        const currentMeasureElement = measures[AppState.currentMeasure];
        const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
        const scale = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
        
        if (!root || !scale || !UI.elements.chordFretboard) {
            console.warn('Invalid chord tuning inputs or missing chord fretboard');
            return;
        }

        updateFretboardNotes(UI.elements.chordFretboard, root, scale, TUNINGS[UI.elements.chordTuning.value]);
    });
}

function setupFretboardEventListeners(container, fretboard, i) {
    const tuningSelect = container.querySelector('.tuning-select');
    const keySelect = container.querySelector(`#key-${i}`);
    const scaleSelect = container.querySelector(`#scale-${i}`);

    if (!tuningSelect || !keySelect || !scaleSelect) {
        console.warn(`Fretboard controls missing in container ${i}`);
        return;
    }

    const updateFretboardHandler = () => {
        const tuning = TUNINGS[tuningSelect.value];
        updateFretboardNotes(fretboard, keySelect.value, scaleSelect.value, tuning);
    };

    tuningSelect.addEventListener('change', updateFretboardHandler);
    keySelect.addEventListener('change', updateFretboardHandler);
    scaleSelect.addEventListener('change', updateFretboardHandler);
}

function initializeFretboards() {
    initializeFretFlow();
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) {
        console.warn('Fretboards grid not found');
        return;
    }

    for (let i = 1; i <= 4; i++) {
        const container = createFretboardContainer(i);
        fretboardsGrid.appendChild(container);
        
        const fretboard = container.querySelector('.fretboard');
        if (!fretboard) {
            console.warn(`Fretboard not found in container ${i}`);
            continue;
        }

        createFretboard(fretboard, TUNINGS.standard);
        updateFretboardNotes(fretboard, 'C', 'major', TUNINGS.standard);
        setupFretboardEventListeners(container, fretboard, i);
    }
}

function initializeDrumControls() {
    const soundTypeSelect = UI.elements.soundType;
    const drumSetToggleBtn = document.getElementById('drum-set-toggle-btn');

    if (!soundTypeSelect || !drumSetToggleBtn) {
        console.warn('Sound type select or drum set toggle button not found');
        return;
    }

    const updateDrumSetVisibility = (value) => {
        drumSetToggleBtn.style.display = value === 'drums' ? 'inline-block' : 'none';
    };

    updateDrumSetVisibility(soundTypeSelect.value);
    drumSetToggleBtn.textContent = drumSoundSets[0].name;

    soundTypeSelect.addEventListener('change', (e) => {
        updateDrumSetVisibility(e.target.value);
        console.log(`Sound type changed to: ${e.target.value}`);
    });
}

// Main initialization function
async function initializeApp() {
    try {
        await initializeUIComponents();
        initializeChordFretboard();
        
        const progression = UI.elements.progressionSelect?.value || 'I V7';
        loadProgression(progression);
        
        initializeFretboards();
        setupEventListeners();
        
        updateLoadingStatus('Application initialized');
        log('Application initialized');

        // Remove loading indicator after 1 second
        setTimeout(() => {
            UI.elements.loadingIndicator?.remove();
        }, 1000);

    } catch (error) {
        console.error('Unexpected error in initializeApp:', error);
        updateLoadingStatus(`Initialization failed: ${error.message}`);
        throw error;
    }
}

// Main event listener
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initializeApp();
        SwingControl.initialize();
        initializeDrumControls();
    } catch (error) {
        console.error('Error during app initialization:', error);
        updateLoadingStatus(`Initialization failed: ${error.message}`);
    }
});
    </script>
        
</body>
</html>
