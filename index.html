<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1f618d;
        }
        .app-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .fretboards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .fretboard-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .scale-display {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .controls-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: bold;
        }
        
        .control-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .fretboard {
            position: relative;
            height: 200px;
            background-color: #FFCF79;
            border-radius: 5px;
            margin-bottom: 30px;
            border: 2px solid #4B1C2E;
            overflow: visible;
        }
        .fret-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #c0c0c0;
            border-right: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        .string-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background: silver;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            z-index: 0;
        }
        .fret-number {
            position: absolute;
            bottom: -40px;
            font-size: 16px;
            color: #1f618d;
            transform: translateX(-50%);
            font-weight: bold;
            z-index: 2;
            width: 20px;
            text-align: center;
        }
        .fret-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .note {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            z-index: 3;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease;
        }
        .note:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        .beat {
            width: 40px;
            height: 80px;
            background: #9E9E9E;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 14px;
            margin: 0 2px;
        }
        .beats-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            flex-wrap: nowrap;
        }
        .beat.active {
            transform: translateY(-10px);
        }
        #measures {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }
        .measure {
            position: relative;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            transition: opacity 0.2s ease;
        }
        .measure.dragging {
            opacity: 0.5;
        }
        .measure.active {
            background-color: #c3e6cb;
            border: 2px solid #28a745;
        }
        .measure-number {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #333;
        }
        .chord-controls, .scale-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .chord-controls select, .scale-controls select {
            flex: 1;
        }

        .fretboard-section {
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        
        /* Dark Mode 1 */
        body.dark-mode .fretboard-section {
            background-color: #23272e; /* A bit darker than the main app-section */
            border-color: #444;
            color: #fefae0;
        }
        
        /* Dark Mode 2 */
        body.dark-mode-2 .fretboard-section {
            background-color: #001f54; /* Consistent with app-section or slightly varied */
            border-color: #1282a2;
            color: #fefcfb;
        }
        
        /* Dark Mode 3 */
        body.dark-mode-3 .fretboard-section {
            background-color: #a5a58d; /* Consistent or varied */
            border-color: #cb997e;
            color: #ffe8d6;
        }
        
        .fretboard-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        /* .control-group is already defined, ensure it works for fretboard-controls too */
        
        .control-group label {
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .control-group select {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        /* .scale-display is already defined, check for specificity issues if styling differs */
        /* .fretboard is already defined */
        
        @media (max-width: 1200px) {
            #measures {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 600px) {
            #measures {
                grid-template-columns: 1fr;
            }
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        select {
            padding: 5px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        #tempo-display {
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 10px;
        }
        #loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 5px;
            z-index: 1000;
        }

        .checkbox-wrapper {
            margin-top: 20px;  /* Add space above the button */
            margin-left: 20px; /* Move button to the left */
            display: flex;
            align-items: center;
        }

        .control-button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            background: #45a049;
        }
        
        #chordsEnabled {
            margin-bottom: 10px;
            padding: 8px 16px;
        }
        body.dark-mode {
            background-color: #283618;
            color: #fefae0;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark-mode .app-section {
            background: linear-gradient(145deg, #283618, #606c38);
            color: #fefae0;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .fretboard-container {
            background-color: #606c38;
            border: 1px solid #dda15e;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .dark-mode .fretboard {
            background-color: #dda15e;
            border: 2px solid #4b4b4b;
            border-radius: 5px;
        }
        .dark-mode .note {
            /* background-color: #dda15e; */ /* Let JS control this for root/other notes */
            color: #283618;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .note:hover {
            /* transform: scale(1.2); */ /* JS handles this on click */
            /* background-color: #bc6c25; */
        }
        .dark-mode .scale-display {
            color: #fefae0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .dark-mode button {
            background-color: #dda15e;
            color: #283618;
            border: 1px solid #bc6c25;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode button:hover {
            background-color: #bc6c25;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        .dark-mode select {
            background-color: #dda15e;
            color: #283618;
            border: 1px solid #bc6c25;
        }
        .dark-mode select:hover {
            background-color: #bc6c25;
        }
        .dark-mode .measure {
            background-color: #606c38;
            color: #fefae0;
            border: 1px solid #dda15e;
        }
        .dark-mode .measure.active {
            background-color: #dda15e;
            border-color: #bc6c25;
        }
        .dark-mode .beat {
            background-color: #dda15e;
            color: #283618;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode .beat.active {
            background-color: #bc6c25;
            transform: translateY(-5px);
        }
        .dark-mode .volume-control {
            color: #fefae0;
        }
        .dark-mode .volume-control input[type="range"] {
            /* Default browser styles might override, specific targeting may be needed */
            /* background: #606c38; */
        }
        .dark-mode .volume-control input[type="range"]::-webkit-slider-thumb {
            background: #dda15e;
            border: 1px solid #bc6c25;
        }
        #dark-mode-toggle.active { /* Specific to dark-mode-1 */
            background-color: #283618;
            color: #fefae0;
            border: 1px solid #dda15e;
        }

        .dark-mode-2 {
            background-color: #0a1128;
            color: #fefcfb;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .dark-mode-2 .app-section {
            background: linear-gradient(145deg, #001f54, #034078);
            color: #fefcfb;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 .fretboard-container {
            background-color: #034078;
            border: 1px solid #1282a2;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .dark-mode-2 .fretboard {
            background-color: #001f54;
            border: 2px solid #1282a2;
            border-radius: 5px;
        }
        
        .dark-mode-2 .note {
            /* background-color: #1282a2; */
            color: #fefcfb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 .scale-display {
            color: #fefcfb;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .dark-mode-2 button {
            background-color: #1282a2;
            color: #fefcfb;
            border: 1px solid #034078;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        .dark-mode-2 button:hover {
            background-color: #0e6c89;
        }
        
        .dark-mode-2 select {
            background-color: #034078;
            color: #fefcfb;
            border: 1px solid #1282a2;
        }
        .dark-mode-2 select:hover {
            background-color: #0e6c89;
        }
        
        .dark-mode-2 .measure {
            background-color: #034078;
            color: #fefcfb;
            border: 1px solid #1282a2;
        }
        
        .dark-mode-2 .measure.active {
            background-color: #1282a2;
            border-color: #fefcfb;
        }
        
        .dark-mode-2 .beat {
            background-color: #1282a2;
            color: #fefcfb;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-2 .beat.active {
            background-color: #034078;
            transform: translateY(-5px);
        }
         #dark-mode-toggle.active-2 { /* Specific to dark-mode-2 */
            background-color: #1282a2;
            color: #fefcfb;
            border: 1px solid #034078;
        }


        .dark-mode-3 {
            background-color: #6b705c;
            color: #ffe8d6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .dark-mode-3 .app-section {
            background: linear-gradient(145deg, #6b705c, #a5a58d);
            color: #ffe8d6;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 .fretboard-container {
            background-color: #a5a58d; /* Adjusted from #606c38 for more distinction */
            border: 1px solid #cb997e;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .dark-mode-3 .fretboard {
            background-color: #cb997e;
            border: 2px solid #6b705c;
            border-radius: 5px;
        }
        
        .dark-mode-3 .note {
            /* background-color: #b7b7a4; */
            color: #6b705c;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 .scale-display {
            color: #ffe8d6;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .dark-mode-3 button {
            background-color: #cb997e;
            color: #ffe8d6; /* Ensure contrast */
            border: 1px solid #6b705c;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
         .dark-mode-3 button:hover {
            background-color: #b2856c;
        }
        
        .dark-mode-3 select {
            background-color: #ddbea9;
            color: #6b705c;
            border: 1px solid #cb997e;
        }
        .dark-mode-3 select:hover {
            background-color: #c7a993;
        }
        
        .dark-mode-3 .measure {
            background-color: #a5a58d;
            color: #ffe8d6;
            border: 1px solid #cb997e;
        }
        
        .dark-mode-3 .measure.active {
            background-color: #ddbea9;
            border-color: #cb997e;
        }
        
        .dark-mode-3 .beat {
            background-color: #ddbea9;
            color: #6b705c;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode-3 .beat.active {
            background-color: #cb997e;
            transform: translateY(-5px);
        }
        
        .dark-mode-3 .volume-control {
            color: #ffe8d6;
        }
        
        #dark-mode-toggle.active-3 { /* Specific to dark-mode-3 */
            background-color: #cb997e;
            color: #ffe8d6;
            border: 1px solid #6b705c;
        }

        /* Add these to your existing dark mode CSS sections */
        .dark-mode #fretflow-section { /* FretFlow section styles for dark-mode-1 */
            background: linear-gradient(145deg, #283618, #606c38);
            color: #fefae0;
        }
        
        .dark-mode-2 #fretflow-section { /* FretFlow section styles for dark-mode-2 */
            background: linear-gradient(145deg, #001f54, #034078);
            color: #fefcfb;
        }
        
        .dark-mode-3 #fretflow-section { /* FretFlow section styles for dark-mode-3 */
            background: linear-gradient(145deg, #6b705c, #a5a58d);
            color: #ffe8d6;
        }
        
        .toggle-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            /* background: #4CAF50; // Default active */
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-button.active {
            background: #4CAF50; /* Green when active */
        }
        
        .toggle-button:not(.active) {
            background: #9E9E9E; /* Grey when inactive */
        }

         #song-info-display {
            background-color: #f0f0f0; /* Light background for contrast */
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
        }
        body.dark-mode #song-info-display {
            background-color: #4a542e; /* Dark mode equivalent */
            border-color: #7a845e;
            color: #fefae0;
        }
        body.dark-mode-2 #song-info-display {
            background-color: #023059; /* Dark mode 2 equivalent */
            border-color: #0f6090;
            color: #fefcfb;
        }
        body.dark-mode-3 #song-info-display {
            background-color: #8a8a75; /* Dark mode 3 equivalent */
            border-color: #b6a191;
            color: #ffe8d6;
        }

        #current-song-title {
            font-size: 1.4em; /* Larger title */
            font-weight: bold;
            margin-top: 0;
            margin-bottom: 5px;
            color: #333; /* Default color */
        }
        body.dark-mode #current-song-title { color: #fefae0; }
        body.dark-mode-2 #current-song-title { color: #fefcfb; }
        body.dark-mode-3 #current-song-title { color: #ffe8d6; }


        #current-song-description {
            font-size: 0.95em;
            margin-top: 0;
            margin-bottom: 0;
            line-height: 1.4;
            color: #555; /* Default color */
        }
        body.dark-mode #current-song-description { color: #e0daca; }
        body.dark-mode-2 #current-song-description { color: #e0e0df; }
        body.dark-mode-3 #current-song-description { color: #f0d8c6; }
        
    </style>
</head>
<body>
    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <div class="scale-display" id="scale-display"></div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls">
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option>
                <option value="3">3/4</option>
                <option value="4" selected>4/4</option>
                <option value="6">6/8</option>
                <option value="7">7/8</option>
                <option value="8">8/8</option>
                <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option>
                <option value="woodblock">Woodblock</option>
                <option value="drums">Drums</option>
            </select>
            <button id="drumSetToggleBtn" class="control-button">Drums</button> <!-- Name will be updated by JS -->
            <div class="volume-control">
                <span>Metronome Volume:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>
        <div class="beats-container"></div>
    </div>

    <div class="volume-control">
        <label for="accent-intensity">Accent Intensity:</label>
        <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
    </div>
    
<div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <div id="song-info-display">
            <h4 id="current-song-title"></h4> 
            <p id="current-song-description"></p>
        </div>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
        <label for="progression-select">Select Progression:</label>
        <select id="progression-select" aria-label="Select chord progression">
            <option value="I V7">I-V7</option>
            <option value="jazz_blues">Jazz Blues</option>
            <option value="minor_blues">Minor Blues</option>
            <option value="rhythm_changes">Rhythm Changes</option>
            <option value="2_5_1">II-V-I</option>
            <option value="6_2_5_1">VI-II-V-I</option>
            <option value="minor_2_5_1">Minor iim-V7-im</option>
            <option value="dark_eyes">Dark Eyes</option>
            <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams</option>
            <option value="rose_room">Rose Room</option>
            <option value="black_orpheus">Black Orpheus</option>
            <option value="all_the_things_you_are">All The Things You Are</option>
            <option value="all_of_me">All of Me</option>
            <option value="stella_by_starlight">Stella By Starlight</option>
            <option value="autumn_leaves">Autumn Leaves</option>
            <option value="summertime">Summertime</option>
            <option value="girl_from_ipanema">Girl From Ipanema</option>
            <option value="coltrane_changes">Coltrane Changes</option>
            <option value="bird_blues">Bird Blues</option>
            <option value="just_friends">Just Friends</option>
            <option value="blue_bossa">Blue Bossa</option>
            <option value="on_green_dolphin_street">On Green Dolphin Street</option>
            <option value="solar">Solar</option>
            <option value="misty">Misty</option>
            <option value="days_of_wine_and_roses">Days of Wine and Roses</option>
            <option value="cherokee">Cherokee</option>
            <option value="caravan">Caravan</option>
            <option value="nows_the_time">Now's The Time</option>
            <option value="tenor_madness">Tenor Madness</option>
        </select>
        <label for="keySelect">Select Key:</label>
        <select id="keySelect" aria-label="Select key">
          <option value="C">C</option>
          <option value="Cm">Cm</option>
          <option value="Db">Db</option>
          <option value="Dbm">Dbm</option>
          <option value="D">D</option>
          <option value="Dm">Dm</option>
          <option value="Eb">Eb</option>
          <option value="Ebm">Ebm</option>
          <option value="E">E</option>
          <option value="Em">Em</option>
          <option value="F">F</option>
          <option value="Fm">Fm</option>
          <option value="Gb">Gb</option>
          <option value="Gbm">Gbm</option>
          <option value="G">G</option>
          <option value="Gm">Gm</option>
          <option value="Ab">Ab</option>
          <option value="Abm">Abm</option>
          <option value="A">A</option>
          <option value="Am">Am</option>
          <option value="Bb">Bb</option>
          <option value="Bbm">Bbm</option>
          <option value="B">B</option>
          <option value="Bm">Bm</option>
        </select>
        <div id="measures">
            <!-- Measures will be populated dynamically -->
        </div>
        <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
        <button onclick="removeMeasure()" aria-label="Remove measure">Remove Measure</button>
        <div class="checkbox-wrapper">
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.75" aria-label="Chord volume">
        </div>
        <div class="control-group">
              <label for="reverb-dial">Reverb</label>
              <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
              <span id="reverb-dial-value">20</span>%
         </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <div class="fretboards-grid"></div>
</div>

    <script>
// Utility Functions
function log(message) {
    console.log(`[Bebop Blueprint Debug] ${message}`);
}

function updateLoadingStatus(message) {
    let indicator = document.getElementById('loading-indicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'loading-indicator';
        document.body.appendChild(indicator);
    }
    indicator.textContent = message;
}

function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// Musical Constants
const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']; // Canonical notes using flats
const NOTES_CHROMATIC = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']; // For internal calculations, consistent with NOTES

const ALL_NOTES_FOR_SAMPLES = ['a', 'as', 'b', 'c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs']; // Note names for sample files
const OCTAVES_FOR_SAMPLES = [2, 3, 4, 5];
const FILE_FORMAT = 'wav';

function getSampleFileName(note, octave) {
  return `${note}${octave}.${FILE_FORMAT}`;
}
        
const allSampleFiles = [];
for (const note of ALL_NOTES_FOR_SAMPLES) {
  for (const octave of OCTAVES_FOR_SAMPLES) {
    allSampleFiles.push(getSampleFileName(note, octave));
  }
}
        
const SAMPLE_NOTE_MAP = { // Maps canonical note names (from NOTES array) to sample file note names
    'C': 'c',
    'C#': 'cs', 'Db': 'cs', // Db maps to cs sample
    'D': 'd',
    'D#': 'ds', 'Eb': 'ds', // Eb maps to ds sample
    'E': 'e',
    'F': 'f',
    'F#': 'fs', 'Gb': 'fs', // Gb maps to fs sample
    'G': 'g',
    'G#': 'gs', 'Ab': 'gs', // Ab maps to gs sample
    'A': 'a',
    'A#': 'as', 'Bb': 'as', // Bb maps to as sample
    'B': 'b'
};
      
const PIANO_FREQUENCIES = { // Renamed from PIANO_NOTES to avoid confusion with note names
    'A2': 110.00, 'As2': 116.54, 'B2': 123.47,
    'C3': 130.81, 'Cs3': 138.59, 'D3': 146.83, 'Ds3': 155.56, 'E3': 164.81, 'F3': 174.61,
    'Fs3': 185.00, 'G3': 196.00, 'Gs3': 207.65, 'A3': 220.00, 'As3': 233.08, 'B3': 246.94,
    'C4': 261.63, 'Cs4': 277.18, 'D4': 293.66, 'Ds4': 311.13, 'E4': 329.63
};
        
function standardizeNoteName(note) { // Standardizes to use flats (Db instead of C#)
    if (!note) return '';
    let standardized = note.toUpperCase().trim();
    standardized = standardized.replace('♭', 'b').replace('♯', '#');
    
    const sharpToFlat = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
    if (standardized.includes('#')) {
        return sharpToFlat[standardized] || standardized;
    }
    // Ensure it's one of the canonical names if it's simple (e.g. "DB" -> "Db")
    const found = NOTES.find(n => n.toUpperCase() === standardized.toUpperCase());
    return found || standardized;
}
        
const FRETBOARD_FREQUENCIES = {
    'string6': [82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81],
    'string5': [110.00, 116.54, 123.47, 130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00],
    'string4': [146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66],
    'string3': [196.00, 207.65, 220.00, 233.08, 246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00],
    'string2': [246.94, 261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88],
    'string1': [329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88, 523.25, 554.37, 587.33, 622.25, 659.25]
};

const SCALES = {
    major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10], harmonicMinor: [0, 2, 3, 5, 7, 8, 11], melodicMinor: [0, 2, 3, 5, 7, 9, 11],
    dorian: [0, 2, 3, 5, 7, 9, 10], phrygian: [0, 1, 3, 5, 7, 8, 10], lydian: [0, 2, 4, 6, 7, 9, 11], mixolydian: [0, 2, 4, 5, 7, 9, 10], locrian: [0, 1, 3, 5, 6, 8, 10],
    bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11], bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11], bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10], bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10],
    altered: [0, 1, 3, 4, 6, 8, 10], lydianDominant: [0, 2, 4, 6, 7, 9, 10],
    diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11], diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10], wholeTone: [0, 2, 4, 6, 8, 10], // Renamed 'wholeHalf' to 'wholeTone' for clarity
    pentatonicMajor: [0, 2, 4, 7, 9], pentatonicMinor: [0, 3, 5, 7, 10],
    blues: [0, 3, 5, 6, 7, 10], majorBlues: [0, 2, 3, 4, 7, 9],
    // 'altered' is duplicated, keeping the common one. 'halfWhole' is Diminished HW.
    harmonicMajor: [0, 2, 4, 5, 7, 8, 11], doubleHarmonic: [0, 1, 4, 5, 7, 8, 11],
    enigmatic: [0, 1, 4, 6, 8, 10, 11], persian: [0, 1, 4, 5, 6, 8, 11], arabic: [0, 2, 4, 5, 6, 8, 10], japanese: [0, 2, 5, 7, 8], egyptian: [0, 2, 5, 7, 10]
};

const TUNINGS = { // EADGBE standard from low E to high E
    standard: ['E', 'A', 'D', 'G', 'B', 'E'].reverse(), // JS will read 0 as high E, so reverse for display logic
    dropD:    ['D', 'A', 'D', 'G', 'B', 'E'].reverse(),
    openG:    ['D', 'G', 'D', 'G', 'B', 'D'].reverse(),
    DADGAD:   ['D', 'A', 'D', 'G', 'A', 'D'].reverse(),
    openE:    ['E', 'B', 'E', 'G#', 'B', 'E'].reverse() // G# needs to be Ab for NOTES array
};
// Correct Open E tuning using canonical note names
TUNINGS.openE = ['E', 'B', 'E', 'Ab', 'B', 'E'].reverse();


const DRUM_PATTERNS = { // These are base patterns, actual sounds depend on createBeats logic
    '2': { kick: [1, 0], snare: [0, 1], hihat: [1, 1] },
    '3': { kick: [1, 0, 0], snare: [0, 1, 0], hihat: [1, 1, 1] },
    '4': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] }, // This is 8 eighth notes
    '6': { kick: [1, 0, 0, 1, 0, 0], snare: [0, 0, 1, 0, 0, 1], hihat: [1, 1, 1, 1, 1, 1] },
    '7': { kick: [1, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1] },
    '8': { kick: [1, 0, 0, 0, 1, 0, 0, 0], snare: [0, 0, 1, 0, 0, 0, 1, 0], hihat: [1, 1, 1, 1, 1, 1, 1, 1] },
    '12':{ kick: [1,0,0,1,0,0,1,0,0,1,0,0], snare: [0,0,1,0,0,1,0,0,1,0,0,1], hihat: [1,1,1,1,1,1,1,1,1,1,1,1] }
};
let currentDrumSetIndex = 0;
const drumSoundSets = [
    { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" },
    { name: "Makaya", snare: "Snare2.wav", hihat: "HiHat2.wav", kick: "Kick2.wav" },
    { name: "PhillyJoe", kick: 'jazzkick.wav', snare: 'jazzsnare.wav', hihat: 'jazzhat.wav' }
];

const progressions = {
    "I V7": { 
        defaultKey: "C", 
        progression: ["Imaj7", "V7"], 
        description: "A classic two-chord progression often used in jazz standards for a simple, elegant harmonic resolution."
    },
    "jazz_blues": { 
        defaultKey: "Bb", 
        progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "iim7", "V7", "I7", "V7"], 
        description: "A swinging 12-bar blues with jazzy substitutions, perfect for improvisation and soulful melodies."
    },
    "minor_blues": { 
        defaultKey: "Am", 
        progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"], 
        description: "A moody minor blues progression with a melancholic vibe, ideal for expressive solos."
    },
    "rhythm_changes": { 
        defaultKey: "Bb", 
        progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7", "IV7", "Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "V7"], 
        description: "A fast-paced, iconic jazz structure based on Gershwin's 'I Got Rhythm,' great for bebop."
    },
    "2_5_1": { 
        defaultKey: "C", 
        progression: ["iim7", "V7", "Imaj7", "Imaj7"], 
        description: "The quintessential jazz turnaround, providing a smooth and satisfying resolution."
    },
    "6_2_5_1": { 
        defaultKey: "C", 
        progression: ["vim7", "iim7", "V7", "Imaj7", "Imaj7"], 
        description: "An extended version of the 2-5-1, starting on the vi minor for a richer harmonic journey."
    },
    "minor_2_5_1": { 
        defaultKey: "Am", 
        progression: ["iim7b5", "V7b9", "im7", "im7"], 
        description: "A dramatic minor key progression, often used for intense and emotional resolutions."
    },
    "dark_eyes": { 
        defaultKey: "Dm", 
        progression: ["V7", "V7", "im7", "im7", "V7", "V7", "VI6", "VI6", "ivm6", "ivm6", "im7", "im7", "V7", "V7", "im7", "im7"], 
        description: "A passionate, Gypsy jazz-inspired progression with a fiery, Eastern European flair."
    },
    "ill_see_you_in_my_dreams": { 
        defaultKey: "F", 
        progression: ["IV6", "IV6", "ivm6", "ivm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "iim7", "V7", "Imaj7"], 
        description: "A dreamy, nostalgic progression from the 1920s, evoking romance and whimsy."
    },
    "rose_room": { 
        defaultKey: "Ab", 
        progression: ["II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"], 
        description: "A sophisticated swing tune with lush chords, perfect for a classy jazz vibe."
    },
    "black_orpheus": { 
        defaultKey: "Am", 
        progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"], 
        description: "A bossa nova classic with a haunting minor key, inspired by Brazilian rhythms."
    },
    "all_the_things_you_are": { 
        defaultKey: "Ab", 
        progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"], 
        description: "A harmonically complex standard with shifting keys, beloved in jazz for its beauty."
    },
    "all_of_me": { 
        defaultKey: "C", 
        progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IVmaj7", "ivm7", "Imaj7", "V7"], 
        description: "A cheerful, upbeat standard with a catchy progression, great for vocal jazz."
    },
    "stella_by_starlight": { 
        defaultKey: "Bb", 
        progression: ["iim7b5", "V7b9", "Imaj7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "biiim7b5", "VI7b9", "iim7", "V7", "Imaj7", "IV7", "IVmaj7", "V7"], 
        description: "A lush, cinematic progression with a romantic and introspective feel."
    },
    "autumn_leaves": { 
        defaultKey: "Gm", 
        progression: ["iim7b5", "V7", "imaj7", "IVmaj7", "viim7b5", "III7", "vim7", "vim7"], 
        description: "A melancholic jazz standard evoking falling leaves and wistful nostalgia."
    },
    "summertime": { 
        defaultKey: "Am", 
        progression: ["im7", "V7", "im7", "V7", "im7", "V7", "im7", "V7", "ivm7", "im7", "V7", "im7", "ivm7", "im7", "V7", "im7"], 
        description: "A sultry, soulful progression from Gershwin's opera, perfect for laid-back grooves."
    },
    "girl_from_ipanema": { 
        defaultKey: "F", 
        progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "#IVm7b5", "VII7", "iiim7", "VI7", "iim7", "V7"], 
        description: "A breezy bossa nova tune with a sunny, beachy vibe, iconic in jazz."
    },
    "coltrane_changes": { 
        defaultKey: "C", 
        progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"], 
        description: "A challenging, innovative progression from John Coltrane, with rapid key shifts."
    },
    "bird_blues": { 
        defaultKey: "F", 
        progression: ["I7", "IV7", "I7", "vim7", "iim7", "V7", "IV7", "ivm7", "I7", "vim7", "iim7", "V7"], 
        description: "A bebop blues progression inspired by Charlie Parker, full of energy and drive."
    },
    "just_friends": { 
        defaultKey: "G", 
        progression: ["Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7"], 
        description: "A lively, upbeat standard with a playful harmonic structure, great for swing."
    },
    "blue_bossa": { 
        defaultKey: "Cm", 
        progression: ["im7", "im7", "bVII7", "bVII7", "im7", "im7", "ivm7", "bVII7", "im7", "V7", "im7", "im7"], 
        description: "A cool, Latin-jazz progression with a relaxed yet groovy bossa nova feel."
    },
    "on_green_dolphin_street": { 
        defaultKey: "C", 
        progression: ["Imaj7", "im7", "Imaj7", "im7", "bIImaj7", "Imaj7", "bIImaj7", "Imaj7", "iim7", "V7"], 
        description: "A modal, cinematic progression with a mysterious and captivating atmosphere."
    },
    "solar": { 
        defaultKey: "Cm", 
        progression: ["imaj7", "iim7b5", "V7alt", "imaj7", "bVImaj7", "bIIImaj7", "bVII7", "bVII7", "imaj7", "imaj7"], 
        description: "A contemplative, Miles Davis original with a flowing, introspective harmonic line."
    },
    "misty": { 
        defaultKey: "Eb", 
        progression: ["Imaj7", "vm7", "I7", "IVmaj7", "ivm7", "Imaj7", "iim7", "V7", "iiim7", "VI7", "iim7", "V7"], 
        description: "A tender, romantic ballad progression, evoking misty-eyed sentimentality."
    },
    "days_of_wine_and_roses": { 
        defaultKey: "F", 
        progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "IVmaj7", "vm7", "I7", "IVmaj7", "iiim7", "VI7", "iim7", "V7"], 
        description: "A bittersweet, elegant progression with a waltzing, reflective quality."
    },
    "cherokee": { 
        defaultKey: "Bb", 
        progression: ["Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7", "bVImaj7", "bVImaj7", "V7", "V7", "Imaj7", "Imaj7", "iim7", "V7"], 
        description: "A high-energy bebop standard with a fast-moving, adventurous harmonic structure."
    },
    "caravan": { 
        defaultKey: "Fm", 
        progression: ["im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "bVII7", "bVII7", "Imaj7", "Imaj7", "V7", "V7", "im7", "im7"], 
        description: "An exotic, Latin-tinged progression with a hypnotic, caravan-like rhythm."
    },
    "nows_the_time": { 
        defaultKey: "F", 
        progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "V7", "IV7", "I7", "I7"], 
        description: "A gritty, straightforward blues progression by Charlie Parker, full of soul."
    },
    "tenor_madness": { 
        defaultKey: "Bb", 
        progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "iim7", "V7", "I7", "I7"], 
        description: "A hard-swinging blues progression, ideal for fiery tenor sax battles."
    }
};
        
const CHORD_INTERVALS = {
    'maj': [0, 4, 7], 'min': [0, 3, 7], 'dim': [0, 3, 6], 'aug': [0, 4, 8], 'sus4': [0, 5, 7], 'sus2': [0, 2, 7],
    'maj7': [0, 4, 7, 11], 'dom7': [0, 4, 7, 10], 'min7': [0, 3, 7, 10], 'min7b5': [0, 3, 6, 10], 'dim7': [0, 3, 6, 9],
    'maj6': [0, 4, 7, 9], 'min6': [0, 3, 7, 9],
    'dom7b9': [0, 4, 7, 10, 13], 'dom7#9': [0, 4, 7, 10, 15], 'dom7b5': [0, 4, 6, 10],
    'alt': [0, 4, 6, 10, 13], 'dom7sus': [0, 5, 7, 10],
    'maj9': [0, 4, 7, 11, 14], 'dom9': [0, 4, 7, 10, 14], 'min9': [0, 3, 7, 10, 14],
    'imaj7': [0, 3, 7, 11], // Minor-Major 7th
    'unknown': [0, 4, 7, 10] // Fallback
};
async function loadProgression(progressionName, key = null) {
    if (!progressions[progressionName]) {
        console.error(`Unknown progression: ${progressionName}`);
        return;
    }

    // Clear current song info display
    UI.elements.currentSongTitle.textContent = progressionName.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    UI.elements.currentSongDescription.textContent = progressions[progressionName].description || '';

    // Use provided key or default from progression definition
    const progressionKey = key || progressions[progressionName].defaultKey;
    currentProgressionName = progressionName;
    
    // Store the functional progression (Roman numerals)
    currentFunctionalProgression = progressions[progressionName].progression;

    // Update key select to match
    if (UI.elements.keySelect) {
        UI.elements.keySelect.value = progressionKey;
    }

    // Clear existing measures
    UI.elements.measures.innerHTML = '';

    // Create measures for each chord in the progression
    currentFunctionalProgression.forEach((romanChordString, index) => {
        addMeasure(); // This will create a new measure element
        const measureElement = UI.elements.measures.children[index];
        
        if (measureElement) {
            const parsedChord = parseRomanNumeralToAbsoluteChord(romanChordString, progressionKey);
            
            const rootSelect = measureElement.querySelector('.root-note');
            const qualitySelect = measureElement.querySelector('.chord-quality');
            const secondKeySelect = measureElement.querySelector('.scale-controls .second-key');
            const scaleSelect = measureElement.querySelector('.scale-controls .scale-select');

            if (rootSelect) rootSelect.value = parsedChord.root;
            if (qualitySelect) qualitySelect.value = parsedChord.quality;
            if (secondKeySelect) secondKeySelect.value = parsedChord.root;
            if (scaleSelect) scaleSelect.value = suggestScaleForQuality(parsedChord.quality);
        }
    });

    // Reset current measure and beat
    AppState.updateState({
        currentMeasure: 0,
        currentBeat: 0
    });

    addFirstChordListener();
    log(`Loaded progression '${progressionName}' in key ${progressionKey}`);
}
// State Management
const AppState = {
    isPlaying: false,
    currentBeat: 0,
    currentMeasure: 0,
    tempo: 120,
    audioInitialized: false,
    darkMode: false, // This seems unused, dark mode is handled by body classes
    intervalId: null, // Store interval ID for metronome
    lastTap: null,    // For tap tempo
    listeners: [],
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },
    addListener(callback) {
        this.listeners.push(callback);
    },
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};
// For storing the functional progression (Roman numerals) of the currently loaded song
let currentFunctionalProgression = [];
let currentProgressionName = "";


// UI Management
const UI = {
    elements: {}, // Will be populated in init
    init() {
        this.elements = {
            chordFretboard: document.getElementById('chord-fretboard'),
            measures: document.getElementById('measures'),
            tempoDisplay: document.getElementById('tempo-display'),
            startStopButton: document.getElementById('start-stop'),
            progressionSelect: document.getElementById('progression-select'),
            keySelect: document.getElementById('keySelect'),
            scaleDisplay: document.getElementById('scale-display'), // Main fretboard scale display
            chordTuning: document.getElementById('chord-tuning'),
            timeSignature: document.getElementById('time-signature'),
            soundType: document.getElementById('sound-type'),
            metronomeVolume: document.getElementById('metronome-volume'),
            tempo: document.getElementById('tempo'),
            tapTempo: document.getElementById('tap-tempo'),
            chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
            chordVolume: document.getElementById('chord-volume'),
            chordsEnabled: document.getElementById('chordsEnabled'),
            fretboardsGrid: document.querySelector('.fretboards-grid'), // For FretFlow
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            accentIntensity: document.getElementById('accent-intensity'),
            drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
            currentSongTitle: document.getElementById('current-song-title'), // New
            currentSongDescription: document.getElementById('current-song-description'),
            reverbDial: document.getElementById('reverb-dial'),
            reverbDialValue: document.getElementById('reverb-dial-value')
        };
        Object.entries(this.elements).forEach(([key, el]) => {
            if (!el && key !== 'reverbDialValue') { // reverbDialValue might not always exist if dial is hidden
                 console.warn(`Missing DOM element: ${key}`);
            }
        });
        log("UI elements cached.");
    }
};
function initializeScaleSelects() {
    const scaleOptions = Object.keys(SCALES).map(scale => {
        const displayName = scale.replace(/([A-Z])/g, ' $1').toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
        return `<option value="${scale}">${displayName}</option>`;
    }).join('');

    const fretflowScaleSelects = document.querySelectorAll('.fretflow-scale'); // For FretFlow sections
    fretflowScaleSelects.forEach(select => {
        if (select) select.innerHTML = scaleOptions;
    });

    // For measure scale selects, this will be handled when measures are created/updated
    // as their default depends on the chord.
}
        
// Audio Management
const AudioContextManager = {
    context: null,
    soundBuffers: {},
    pianoSampleBuffers: {},
    reverbNode: null,
    samplesLoaded: false,
    reverbAmount: 0.2, 
    currentChordGain: null,

    initialize: async function() {
        if (this.context && this.context.state !== 'closed') return this.context; // Already initialized and not closed

        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            log("AudioContext created/resumed.");
            await this.loadSounds();
            await this.loadPianoSamples(); // This now loads from ALL_NOTES_FOR_SAMPLES
            await this.setupReverb();
            if (this.context.state === 'suspended') {
                await this.context.resume();
                log("AudioContext resumed from suspended state.");
            }
            AppState.updateState({ audioInitialized: true });
            log("AudioContextManager initialized.");
        } catch (error) {
            console.error("Error initializing AudioContextManager:", error);
            alert("Failed to initialize audio. Please ensure your browser supports Web Audio API and refresh.");
            throw error; // Re-throw to be caught by caller
        }
        return this.context;
    },

    ensureAudioContext: async function() { // Renamed for clarity
        if (!this.context || this.context.state === 'suspended') {
            return await this.initialize();
        }
        return this.context;
    },
    
    loadSounds: async function() { // For metronome clicks, fallback drums
        const soundFiles = {
            'click': 'Click.wav', 'hihat': 'HiHat.wav', 'kick': 'Kick.wav',
            'snare': 'Snare.wav', 'woodblock': 'woodblock.wav'
        };
        for (let [type, filename] of Object.entries(soundFiles)) {
            try {
                const response = await fetch(`./${filename}`); // Assuming files are in the same directory
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${filename}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
                log(`Loaded ${type} sound from ${filename}`);
            } catch (error) {
                console.error(`Failed to load ${filename}:`, error);
                this.soundBuffers[type] = await this.createDrumSound(type); // Fallback
                log(`Using fallback synthetic sound for ${type}`);
            }
        }
        updateLoadingStatus("Drum sounds loaded/synthesized");
    },
    
    createDrumSound: async function(type) { // Fallback if sample loading fails
        const sampleRate = this.context.sampleRate;
        const duration = type === 'hihat' ? 0.05 : 0.2;
        const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
        const data = buffer.getChannelData(0);
        switch (type) {
            case 'click': for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01); break;
            case 'hihat': for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01)); break;
            case 'kick': for (let i = 0; i < data.length; i++) { const t = i / sampleRate; data[i] = Math.sin(2 * Math.PI * 100 * t) * Math.exp(-t * 10) * 2; } break;
            case 'snare': for (let i = 0; i < data.length; i++) { const t = i / sampleRate; data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * t)) * Math.exp(-t * 10) * 2; } break;
            case 'woodblock': for (let i = 0; i < data.length; i++) { const t = i / sampleRate; data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 20); } break;
        }
        return buffer;
    },
    
    loadPianoSamples: async function() {
        this.pianoSampleBuffers = {}; // Reset
        let loadedCount = 0;
        for (const note of ALL_NOTES_FOR_SAMPLES) {
            for (const octave of OCTAVES_FOR_SAMPLES) {
                const fileName = getSampleFileName(note, octave);
                const key = `${note}${octave}`;
                try {
                    const response = await fetch(fileName); // Assuming files are in the same directory
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${fileName}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
                    this.pianoSampleBuffers[key] = audioBuffer;
                    loadedCount++;
                    // log(`Loaded piano sample: ${fileName}`);
                } catch (e) {
                    console.error(`Failed to load piano sample: ${fileName}`, e);
                }
            }
        }
        if (loadedCount > 0) {
            this.samplesLoaded = true;
            log(`Successfully loaded ${loadedCount} piano samples.`);
        } else {
            console.warn("No piano samples were loaded. Chord playback will be silent.");
            this.samplesLoaded = false;
        }
        updateLoadingStatus("Piano samples processing complete.");
    },
    
    setupReverb: async function() {
        if (!this.context) {
            console.error("AudioContext not available for reverb setup.");
            return;
        }
        if (!this.reverbNode) {
            this.reverbNode = this.context.createConvolver();
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 2.5; // 2.5 seconds reverb tail
            const impulse = this.context.createBuffer(2, length, sampleRate); // Stereo impulse
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5); // Smoother decay
                }
            }
            this.reverbNode.buffer = impulse;
            // Destination connection will be handled by nodes that use reverb
            log("Reverb node created.");
        }
    }
};

async function ensureAudioInitializedUserInteraction() { // To be called on first user click
    if (!AppState.audioInitialized) {
        try {
            await AudioContextManager.initialize(); // This will try to create/resume
            log("Audio context initialized/resumed on user interaction.");
        } catch (error) {
            console.error('Audio initialization failed on user interaction:', error);
            // Potentially show a more prominent error to the user here
        }
    }
}


// CHORD PARSING AND MUSIC THEORY HELPERS
function getStandardQuality(rawQuality) { // Maps various quality inputs to CHORD_INTERVALS keys
    if (!rawQuality) return 'maj7'; // Default for simple root like "C" could be maj or maj7
    const q = rawQuality.toLowerCase().trim();

    if (q === 'maj7' || q === 'ma7' || q === 'Δ' || q === 'maj') return 'maj7'; // Treat 'maj' as 'maj7' for jazz
    if (q === '7' || q === 'dom7' || q === 'dom') return 'dom7';
    if (q === 'm7' || q === 'min7' || q === 'mi7' || q === 'min' || q === 'm') return 'min7'; // Treat 'min'/'m' as 'min7'
    if (q === 'm7b5' || q === 'min7b5' || q === 'ø' || q === 'mi7b5') return 'min7b5';
    if (q === 'dim7' || q === '°7') return 'dim7';
    if (q === 'maj6' || q === 'ma6' || (q === '6' && !rawQuality.startsWith('m') && !rawQuality.startsWith('M'))) return 'maj6';
    if (q === 'm6' || q === 'min6' || q === 'mi6') return 'min6';
    if (q === 'dim' || q === '°') return 'dim'; // Triad
    if (q === 'aug' || q === '+') return 'aug'; // Triad
    if (q === 'sus4' || q === 'sus') return 'sus4'; // Triad
    if (q === '7b9' || q === 'dom7b9') return 'dom7b9';
    if (q === '7#9' || q === 'dom7#9') return 'dom7#9';
    if (q === '7b5' || q === 'dom7b5') return 'dom7b5';
    if (q === 'alt' || q === '7alt') return 'alt';
    if (q === '7sus' || q === '7sus4') return 'dom7sus';
    if (q === 'imaj7' || q === 'm(maj7)' || q === 'minmaj7') return 'imaj7';


    // If it's already a key in CHORD_INTERVALS, use it
    if (CHORD_INTERVALS[rawQuality]) return rawQuality;
    
    console.warn(`getStandardQuality: Could not fully standardize quality "${rawQuality}". Defaulting to 'maj7'.`);
    return 'maj7';
}


function parseChord(chordString) { // Parses absolute chord strings like "Cmaj7", "Db7"
    if (typeof chordString !== 'string' || !chordString.trim()) {
        console.warn('parseChord: Invalid chord string input:', chordString);
        return null;
    }
    chordString = chordString.trim();

    // Regex for absolute chords: (Root Note)([Quality Suffix])
    // Root Note: A-G with optional # or b
    // Quality Suffix: anything else
    const chordRegex = /^([A-G][#b]?)(.*)$/;
    const match = chordString.match(chordRegex);

    if (!match) {
        console.warn('parseChord: Could not parse chord string:', chordString);
        return null;
    }

    const root = standardizeNoteName(match[1]); // Standardize root (e.g. C# -> Db)
    const rawQuality = match[2].trim();
    
    return {
        root: root,
        quality: getStandardQuality(rawQuality) // Get a quality string that's a key in CHORD_INTERVALS
    };
}


function parseRomanNumeralToAbsoluteChord(romanString, key) {
    const keyIsMinor = key.includes('m');
    const normalizedKeyRoot = standardizeNoteName(key.replace('m', ''));
    const keyRootIndex = NOTES_CHROMATIC.indexOf(normalizedKeyRoot);

    if (keyRootIndex === -1) {
        console.error(`Invalid key for Roman numeral parsing: ${key}`);
        return { root: 'C', quality: 'maj7', originalRoman: romanString };
    }

    const romanRegex = /^(b|#)?([IViv]+)(.*)$/;
    const match = romanString.match(romanRegex);

    if (!match) { // Not a Roman numeral, try parsing as an absolute chord
        const parsedAbsolute = parseChord(romanString);
        if (parsedAbsolute && parsedAbsolute.root) {
            if (!CHORD_INTERVALS[parsedAbsolute.quality]) {
                console.warn(`Quality from parseChord "${parsedAbsolute.quality}" (for ${romanString}) not in CHORD_INTERVALS. Defaulting.`);
                parsedAbsolute.quality = 'maj7';
            }
            return { ...parsedAbsolute, originalRoman: romanString };
        }
        console.warn(`Could not parse as Roman or Absolute: ${romanString}. Defaulting.`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }

    const accidental = match[1];
    const numeral = match[2];
    let qualitySuffix = match[3].trim();

    const majorScaleIntervals = { 'I':0,'II':2,'III':4,'IV':5,'V':7,'VI':9,'VII':11 };
    const minorScaleIntervals = { 'i':0,'ii':2,'III':3,'iv':5,'v':7,'VI':8,'VII':10 }; // Natural minor b3,b6,b7

    let degreeInterval;
    const isUpperCaseNumeral = numeral === numeral.toUpperCase();

    if (keyIsMinor) {
        degreeInterval = minorScaleIntervals[numeral.toLowerCase()]; // Base on natural minor degree
        if (isUpperCaseNumeral && numeral === 'V') degreeInterval = majorScaleIntervals[numeral]; // V in minor is often Major/Dom
        else if (isUpperCaseNumeral && numeral === 'IV') degreeInterval = majorScaleIntervals[numeral]; // IV in minor can be Major
        // III, VI, VII in minor are typically bIII, bVI, bVII (already covered by minorScaleIntervals)
    } else { // Major key
        degreeInterval = majorScaleIntervals[numeral.toUpperCase()];
    }
    
    if (degreeInterval === undefined) {
        console.warn(`Unknown Roman numeral base: ${numeral} in key ${key}`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }

    let chordRootIndex = (keyRootIndex + degreeInterval) % 12;
    if (accidental === 'b') chordRootIndex = (chordRootIndex - 1 + 12) % 12;
    else if (accidental === '#') chordRootIndex = (chordRootIndex + 1) % 12;
    
    const chordRoot = NOTES_CHROMATIC[chordRootIndex];

    // Determine final quality string for CHORD_INTERVALS
    let finalQuality;
    if (qualitySuffix) {
        finalQuality = getStandardQuality(qualitySuffix);
         // Special handling for "6" suffix on Roman numerals
        if (qualitySuffix === "6") {
            finalQuality = isUpperCaseNumeral ? "maj6" : "min6";
        } else if (qualitySuffix === "m6") { // e.g. ivm6
            finalQuality = "min6";
        }
    } else { // No explicit suffix, infer common jazz qualities
        if (numeral.toLowerCase() === 'v') finalQuality = 'dom7';
        else if (numeral.toLowerCase() === 'vii' && !isUpperCaseNumeral) finalQuality = 'min7b5'; // e.g. viiø7
        else if (isUpperCaseNumeral) finalQuality = 'maj7'; // e.g. I -> Imaj7
        else finalQuality = 'min7'; // e.g. ii -> iim7
    }
    
    // Ensure the determined quality is valid
    if (!CHORD_INTERVALS[finalQuality]) {
        console.warn(`Determined quality "${finalQuality}" for ${romanString} in ${key} is not in CHORD_INTERVALS. Defaulting.`);
        finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7'; // Sensible default
    }

    return { root: chordRoot, quality: finalQuality, originalRoman: romanString };
}

function getChordNotes(root, quality) {
    // log(`Getting notes for chord: ${root}${quality}`);
    let intervals = CHORD_INTERVALS[quality];
    if (!intervals) {
        console.warn(`Quality "${quality}" not found in CHORD_INTERVALS for root ${root}. Defaulting to 'dom7'.`);
        intervals = CHORD_INTERVALS['dom7'];
    }
    
    const rootNoteName = standardizeNoteName(root);
    const rootIndex = NOTES.indexOf(rootNoteName);
    
    if (rootIndex === -1) {
        console.error(`Invalid root note for getChordNotes: ${root} (standardized to ${rootNoteName})`);
        return [rootNoteName]; // Fallback, just return the (possibly problematic) root
    }

    const voicing = intervals.map(interval => {
        const noteIndex = (rootIndex + interval) % 12;
        return NOTES[noteIndex];
    });
    // log(`Voicing for ${root}${quality}: ${voicing.join(', ')}`);
    return voicing;
}
        
function suggestScaleForQuality(quality) { // quality should be a CHORD_INTERVALS key
    const scaleMap = {
        'maj7': 'major', 'maj': 'major', 'maj6': 'major',
        'dom7': 'mixolydian', 'dom9': 'mixolydian', 'dom7b9': 'diminishedWH', 'dom7#9': 'altered', 'alt': 'altered', 'dom7sus': 'mixolydian', // or dorian
        'min7': 'dorian', 'min': 'dorian', 'min9': 'dorian', 'min6': 'dorian',
        'min7b5': 'locrian', // or locrian #2 / locrian natural 9
        'dim7': 'diminishedWH', // or HW
        'imaj7': 'melodicMinor', // or harmonic minor
        // Add more specific suggestions if needed
    };
    return scaleMap[quality] || 'major'; // Default to major
}

// DOM Utilities
function createKeyOptions(selectedKey = 'C') {
    const standardizedSelectedKey = standardizeNoteName(selectedKey);
    return NOTES.map(note =>
        `<option value="${note}"${note === standardizedSelectedKey ? ' selected' : ''}>${note}</option>`
    ).join('');
}

function createQualityOptions(selectedQuality = 'maj7') { // selectedQuality should be a CHORD_INTERVALS key
    const qualities = [ // value attributes MUST match keys in CHORD_INTERVALS
        { value: 'maj7', label: 'Maj7' }, { value: 'dom7', label: '7 (Dominant)' },
        { value: 'min7', label: 'min7' }, { value: 'min7b5', label: 'min7♭5 (ø)' },
        { value: 'dim7', label: 'dim7 (°)' }, { value: 'maj6', label: 'Maj6' },
        { value: 'min6', label: 'min6' }, { value: 'dom7b9', label: '7♭9' },
        { value: 'dom7#9', label: '7♯9' }, { value: 'dom7b5', label: '7♭5' },
        { value: 'alt', label: 'Altered Dom' }, { value: 'dom7sus', label: '7sus4' },
        { value: 'imaj7', label: 'm(maj7)'},
        { value: 'maj', label: 'Maj (triad)' }, { value: 'min', label: 'min (triad)' },
        { value: 'dim', label: 'dim (triad)' }, { value: 'aug', label: 'aug (triad)' },
        { value: 'sus4', label: 'sus4 (triad)' }
    ];

    return qualities.map(q =>
        `<option value="${q.value}"${q.value === selectedQuality ? ' selected' : ''}>${q.label}</option>`
    ).join('');
}

function createScaleOptions(selectedScale = 'major') {
    return Object.keys(SCALES).map(scaleName => {
        const displayName = scaleName.replace(/([A-Z]+)/g, ' $1').replace(/([A-Z][a-z])/g, ' $1').split(' ').map(s => s.charAt(0).toUpperCase() + s.substring(1)).join(' ');
        return `<option value="${scaleName}"${scaleName === selectedScale ? ' selected' : ''}>${displayName}</option>`;
    }).join('');
}
       
// Audio Playback
function standardizeNoteNameForSamples(note) { // Maps canonical (flat) note names to sample file names (sharp or natural)
    const stdNote = standardizeNoteName(note); // Ensure we start from Db, Eb etc.
    return SAMPLE_NOTE_MAP[stdNote] || stdNote.toLowerCase(); // Fallback to lowercase if not in map
}


function playNote(noteNameWithOctave, volume = 1.0, duration = 1000) { // noteNameWithOctave e.g. "Db3", "C4"
    if (!AudioContextManager.context || !AudioContextManager.samplesLoaded || !noteNameWithOctave) return;

    const match = noteNameWithOctave.match(/^([A-G][b#]?)(\d)$/i);
    if (!match) {
        console.warn(`Invalid note format for playNote: ${noteNameWithOctave}`);
        return;
    }

    let [, pitchClass, octaveStr] = match;
    const samplePitchClass = standardizeNoteNameForSamples(pitchClass); // e.g. Db -> cs
    const octave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length -1], parseInt(octaveStr)));

    const sampleKey = `${samplePitchClass}${octave}`; // e.g. cs3, c4
    const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

    if (!buffer) {
        console.warn(`No piano sample found for ${sampleKey} (original: ${noteNameWithOctave})`);
        return;
    }

    try {
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;

        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.setValueAtTime(volume, AudioContextManager.context.currentTime);

        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination); // Connect directly for fretboard notes

        source.start(AudioContextManager.context.currentTime);
        source.stop(AudioContextManager.context.currentTime + duration/1000); // duration is in ms
        // log(`Played note: ${sampleKey} (from ${noteNameWithOctave}) at volume ${volume}`);
    } catch (error) {
        console.error('Error playing note:', error);
    }
}


async function playChord(root, quality, startTime, duration, isContinuation = false) {
    if (!UI.elements.chordsEnabled.classList.contains('active')) return;
    if (!AudioContextManager.samplesLoaded) {
        // console.warn("Piano samples not loaded, skipping chord playback.");
        return;
    }
    await AudioContextManager.ensureAudioContext(); // Ensures context is running

    const chordNotes = getChordNotes(root, quality); // Array of note names like ['C', 'E', 'G']
    const chordVolume = parseFloat(UI.elements.chordVolume.value) * 0.7; // Overall chord volume
    if (chordVolume <= 0) return;

    // Fade out previous chord
    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, startTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
    }

    const mainGainNode = AudioContextManager.context.createGain(); // Gain for this specific chord instance
    mainGainNode.gain.setValueAtTime(0, startTime); // Start silent
    mainGainNode.gain.linearRampToValueAtTime(chordVolume, startTime + 0.02); // Quick fade in (attack)
    mainGainNode.connect(AudioContextManager.context.destination); // Connect before reverb for main sound
    AudioContextManager.currentChordGain = mainGainNode; // Store for next fade out

    // Reverb connection
    const reverbDryWet = AudioContextManager.context.createGain();
    reverbDryWet.gain.value = AudioContextManager.reverbAmount; // Set reverb level
    mainGainNode.connect(reverbDryWet); // Send chord sound to reverb control
    if (AudioContextManager.reverbNode) {
        reverbDryWet.connect(AudioContextManager.reverbNode); // Connect reverb control to reverb effect
        AudioContextManager.reverbNode.connect(AudioContextManager.context.destination); // Ensure reverb output goes to speakers
    }


    // Basic voicing: root in octave 3, others in octave 3 or 4
    // A more sophisticated voicing algorithm would be needed for smoother voice leading
    let baseOctave = 3;
    const previousChordRootIndex = AppState.previousChordRootIndex !== undefined ? AppState.previousChordRootIndex : NOTES.indexOf(standardizeNoteName(root));
    const currentRootIndex = NOTES.indexOf(standardizeNoteName(root));

    // Simple voice leading: try to keep root motion smooth
    if (AppState.previousChordRootIndex !== undefined) {
        if (currentRootIndex < previousChordRootIndex - 3) baseOctave = 4; // If new root is much lower, play it higher
        else if (currentRootIndex > previousChordRootIndex + 3) baseOctave = 2; // If new root is much higher, play it lower
    }
    AppState.previousChordRootIndex = currentRootIndex;


    chordNotes.forEach((noteName, index) => {
        let noteOctave = baseOctave + (index > 1 ? 1 : 0); // Crude octave spread
        if (index === 0) noteOctave = baseOctave; // Root note at baseOctave
        else if (index > 0 && NOTES.indexOf(noteName) < currentRootIndex) noteOctave = baseOctave + 1; // If note is "below" root, push up octave

        noteOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length-1], noteOctave));
        
        const samplePitchClass = standardizeNoteNameForSamples(noteName);
        const sampleKey = `${samplePitchClass}${noteOctave}`;
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

        if (!buffer) {
            console.warn(`No sample for ${sampleKey} (chord note ${noteName})`);
            return;
        }

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        
        const noteSpecificGain = AudioContextManager.context.createGain();
        // Slightly vary velocity for each note in the chord
        noteSpecificGain.gain.value = 0.8 + Math.random() * 0.2; 
        
        source.connect(noteSpecificGain);
        noteSpecificGain.connect(mainGainNode); // Connect to the main gain for this chord instance

        const timeVariation = Math.random() * 0.02; // Strumming effect
        source.start(startTime + timeVariation);
        source.stop(startTime + duration + timeVariation);
    });
    // log(`Playing chord: ${root}${quality} (notes: ${chordNotes.join(',')}) for ${duration}s`);
} 
        
async function playMetronomeSound(baseVolumeForBeatType) {
    if (!AudioContextManager.context) return;

    const metronomeOverallVolume = parseFloat(UI.elements.metronomeVolume.value);
    const combinedVolume = baseVolumeForBeatType * metronomeOverallVolume;
    if (combinedVolume <= 0) return;

    const soundType = UI.elements.soundType.value;
    const beatElement = document.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    if (!beatElement) return;

    const soundKeysToPlay = beatElement.dataset.sound.split(','); // Can be multiple like "kick,hihat"
    const isAccentBeat = parseFloat(beatElement.dataset.baseVolume) >= 1; // Or some other logic
    const accentBoost = parseFloat(UI.elements.accentIntensity?.value || 1.0);
    
    let finalVolumeForThisSound = combinedVolume;
    if (isAccentBeat && (soundKeysToPlay.includes('kick') || soundKeysToPlay.includes('snare') || soundType === 'click' || soundType === 'woodblock')) {
         finalVolumeForThisSound = Math.min(combinedVolume * accentBoost, 1.0);
    }


    for (let soundKey of soundKeysToPlay) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;

        let bufferToPlay;
        let effectiveSoundKey = soundKey; // For volume adjustments

        if (soundType === 'drums') {
            const currentSet = drumSoundSets[currentDrumSetIndex];
            let sampleFileName;
            switch(soundKey) {
                case 'kick': sampleFileName = currentSet.kick; break;
                case 'snare': sampleFileName = currentSet.snare; break;
                case 'hihat': sampleFileName = currentSet.hihat; break;
                default: 
                    console.warn(`Unknown drum sound key: ${soundKey}`);
                    effectiveSoundKey = 'click'; // Fallback if drum sound key is weird
                    sampleFileName = null; // Will use fallback buffer
            }

            if (sampleFileName) {
                try { // Try loading specific drum set sample on the fly (can be cached if already in soundBuffers)
                    if (!AudioContextManager.soundBuffers[sampleFileName]) { // Check if we've loaded it before
                        const response = await fetch(`./${sampleFileName}`);
                        if (!response.ok) throw new Error(`HTTP error for ${sampleFileName}`);
                        const arrayBuffer = await response.arrayBuffer();
                        AudioContextManager.soundBuffers[sampleFileName] = await AudioContextManager.context.decodeAudioData(arrayBuffer);
                    }
                    bufferToPlay = AudioContextManager.soundBuffers[sampleFileName];
                } catch (error) {
                    console.error(`Failed to load/use drum sample ${sampleFileName}:`, error);
                    bufferToPlay = AudioContextManager.soundBuffers[soundKey] || AudioContextManager.soundBuffers['click']; // Fallback to generic or click
                }
            } else {
                 bufferToPlay = AudioContextManager.soundBuffers[effectiveSoundKey] || AudioContextManager.soundBuffers['click'];
            }
        } else { // Click or Woodblock
            effectiveSoundKey = soundType; // For volume adjustment
            bufferToPlay = AudioContextManager.soundBuffers[soundType] || AudioContextManager.soundBuffers['click'];
        }

        if (!bufferToPlay) continue;

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = bufferToPlay;
        const gainNode = AudioContextManager.context.createGain();
        
        let adjustedFinalVolume = finalVolumeForThisSound;
        if (soundType === 'drums') {
            if (effectiveSoundKey === 'hihat' && soundKeysToPlay.length > 1) adjustedFinalVolume *= 0.6; // Quieter hihat if with other drums
            else if (effectiveSoundKey === 'kick') adjustedFinalVolume *= 1.0; // Kick full volume (accent already applied)
            else if (effectiveSoundKey === 'snare') adjustedFinalVolume *= 0.9;
        }
        gainNode.gain.setValueAtTime(Math.min(adjustedFinalVolume, 1.0), AudioContextManager.context.currentTime);

        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);
        
        // Subtle reverb for drums only
        if (soundType === 'drums' && AudioContextManager.reverbNode) {
            const reverbGain = AudioContextManager.context.createGain();
            reverbGain.gain.setValueAtTime(0.05, AudioContextManager.context.currentTime); // Very subtle reverb
            source.connect(reverbGain);
            reverbGain.connect(AudioContextManager.reverbNode);
        }
        source.start(AudioContextManager.context.currentTime);
    }
}

function onMetronomeInstrumentChange(selectedInstrument) {
  UI.elements.drumSetToggleBtn.style.display = selectedInstrument === "drums" ? "inline-block" : "none";
  createBeats(); // Re-create beats to apply new sound types immediately
}
      
function createFretboard(container, tuningArray) { // tuningArray is from TUNINGS (e.g., TUNINGS.standard)
    container.innerHTML = ''; // Clear previous fretboard

    const numFrets = 12;
    const numStrings = tuningArray.length; // Should be 6 for standard guitar

    // Create fret lines and fret numbers
    for (let i = 0; i <= numFrets; i++) { // Fret 0 (nut) to 12
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`;
        container.appendChild(fretLine);

        if (i > 0) {
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            // Position fret number in the middle of the fret space
            fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
            container.appendChild(fretNumber);
        }
    }

    // Create string lines
    for (let i = 0; i < numStrings; i++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        // Strings spread from 0% to 100% top
        stringLine.style.top = `${(i / (numStrings - 1)) * 100}%`;
        container.appendChild(stringLine);
    }

    // Add fret markers (dots)
    const markerPositions = [3, 5, 7, 9, 12];
    markerPositions.forEach(fretPos => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((fretPos - 0.5) / numFrets) * 100}%`;

        if (fretPos === 12) { // Double dots at 12th fret
            const topMarker = marker.cloneNode(true);
            topMarker.style.top = `${(1 / (numStrings -1)) * 100 * 1.5}%`; // Approx between string 1 and 2 if numStrings=6
            container.appendChild(topMarker);

            const bottomMarker = marker.cloneNode(true);
            bottomMarker.style.top = `${(1 / (numStrings -1)) * 100 * 3.5}%`; // Approx between string 4 and 5
            container.appendChild(bottomMarker);
        } else { // Single dot
            marker.style.top = '50%'; // Vertically centered
            container.appendChild(marker);
        }
    });
}
        
function updateFretboardNotes(fretboardContainer, rootNote, scaleName, tuningArray) {
    if (!(fretboardContainer instanceof HTMLElement)) {
        console.error('Invalid fretboardContainer element'); return;
    }
    const standardizedRoot = standardizeNoteName(rootNote);
    if (!NOTES.includes(standardizedRoot)) {
        console.error(`Invalid root note for fretboard: ${rootNote} (std: ${standardizedRoot})`); return;
    }
    if (!SCALES[scaleName]) {
        console.error(`Invalid scale for fretboard: ${scaleName}`); return;
    }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) {
        console.error('Invalid tuning array for fretboard'); return;
    }

    // Clear existing note elements
    fretboardContainer.querySelectorAll('.note').forEach(noteEl => noteEl.remove());

    // Update scale display text for the main fretboard if it's the one being updated
    if (fretboardContainer.id === 'chord-fretboard' && UI.elements.scaleDisplay) {
        // This display logic is now more complex due to chord/scale separation
        // It will be updated when the current measure changes.
        // For now, just show the scale being drawn.
        const measures = UI.elements.measures.children;
        if (measures.length > 0 && AppState.currentMeasure < measures.length) {
            const currentMeasureElement = measures[AppState.currentMeasure];
            const chordRoot = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const chordQualityRaw = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value;
            const chordQualityDisplay = UI.elements.chordFretboard.querySelector(`.chord-quality option[value="${chordQualityRaw}"]`)?.textContent || chordQualityRaw;

            const scaleRootDisplay = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleTypeDisplayRaw = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;
            const scaleTypeDisplay = UI.elements.chordFretboard.querySelector(`.scale-select option[value="${scaleTypeDisplayRaw}"]`)?.textContent || scaleTypeDisplayRaw;
             
            UI.elements.scaleDisplay.textContent = `${scaleRootDisplay} ${scaleTypeDisplay} over ${chordRoot} ${chordQualityDisplay}`;
        } else {
             UI.elements.scaleDisplay.textContent = `${standardizedRoot} ${scaleName.replace(/([A-Z])/g, ' $1').trim()}`;
        }
    }


    const scaleIntervals = SCALES[scaleName];
    const rootIndex = NOTES.indexOf(standardizedRoot);
    const notesInScale = scaleIntervals.map(interval => NOTES[(rootIndex + interval) % 12]);

    const numStrings = tuningArray.length;
    const numFrets = 12; // Display up to 12 frets

    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) { // stringIndex 0 is high E if tuning is reversed
        const openStringNote = standardizeNoteName(tuningArray[stringIndex]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);

        if (openStringNoteIndex === -1) {
            console.warn(`Invalid open string note: ${tuningArray[stringIndex]}`);
            continue;
        }

        for (let fret = 0; fret <= numFrets; fret++) {
            const currentNoteIndex = (openStringNoteIndex + fret) % 12;
            const currentNoteName = NOTES[currentNoteIndex];

            if (notesInScale.includes(currentNoteName)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNoteName;

                // Calculate position: stringY is 0-100%, fretX is 0-100%
                const stringY = (stringIndex / (numStrings - 1)) * 100;
                const fretX = fret === 0 ? 2 : ((fret - 0.5) / numFrets) * 100 + 2; // Offset open string notes slightly, center others
                 if (fret === 0) noteElement.style.left = `1.5%`; // Special position for open string
                 else noteElement.style.left = `${((fret - 0.5) / numFrets) * 100}%`;
                noteElement.style.top = `${stringY}%`;


                // Color coding: root is red, others green/darker green
                if (currentNoteName === standardizedRoot) {
                    noteElement.style.backgroundColor = '#BD2031'; // Red for root
                } else {
                    // Simple alternating colors for other scale degrees for now
                    const degreeIndex = notesInScale.indexOf(currentNoteName);
                    noteElement.style.backgroundColor = (degreeIndex % 2 === 0) ? '#006400' : '#4CAF50';
                }
                
                // Determine octave (approximate, good enough for fretboard note playback)
                let approxOctave = 3; // Default
                if (stringIndex < 2) approxOctave = 4; // High strings
                if (stringIndex > 3) approxOctave = 2; // Low strings
                if (fret > 7 && approxOctave < 5) approxOctave++;


                noteElement.dataset.note = `${currentNoteName}${approxOctave}`; // e.g., Db3, C4
                
                noteElement.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent document click listener if any
                    await AudioContextManager.ensureAudioContext();
                    const noteToPlay = noteElement.dataset.note;
                    const fretboardVolume = parseFloat(UI.elements.chordFretboardVolume.value) || 0.5;
                    playNote(noteToPlay, fretboardVolume, 500); // Play for 0.5 seconds

                    // Visual feedback
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                    setTimeout(() => {
                        noteElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    }, 150);
                });
                // Hover effect handled by CSS .note:hover
                fretboardContainer.appendChild(noteElement);
            }
        }
    }
    // log(`Fretboard updated for ${rootNote} ${scaleName}`);
}
        
function createBeats() {
    const container = document.querySelector('.beats-container');
    if (!container) { console.error("Beats container not found"); return; }
    container.innerHTML = '';

    const timeSignature = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value; // 'click', 'woodblock', 'drums'

    let totalBeatsToDisplay = timeSignature; // Beats per measure
    let subdivisionFactor = 1; // 1 for quarter notes, 2 for eighth notes

    if (timeSignature === 4) { // For 4/4, display 8 eighth notes
        totalBeatsToDisplay = 8;
        subdivisionFactor = 2;
    } else if (timeSignature === 6 || timeSignature === 12) { // 6/8, 12/8 often felt in pulses of 3 eighths
        totalBeatsToDisplay = timeSignature; // Display each eighth note
        subdivisionFactor = 1; // Each displayed beat is an eighth
    }


    for (let i = 0; i < totalBeatsToDisplay; i++) {
        const beatDiv = document.createElement('div');
        beatDiv.className = 'beat';
        beatDiv.dataset.beat = i; // 0-indexed beat within the displayed sequence

        let beatLabel = `${Math.floor(i / subdivisionFactor) + 1}`;
        if (subdivisionFactor > 1 && (i % subdivisionFactor !== 0)) {
            beatLabel += "&"; // For off-beats like "1&"
        } else if ((timeSignature === 6 || timeSignature === 12) && (i % 3 === 0) && i !== 0) {
            // For 6/8 or 12/8, group in 3s
            beatLabel = `${Math.floor(i / 3) +1}`;
        }


        beatDiv.textContent = beatLabel;

        // Default sound settings
        let beatSound = soundType === 'drums' ? 'hihat' : soundType; // Default for drums is hihat
        let baseVolume = 0.3; // Default for weaker beats
        let color = '#4CAF50'; // Default color

        // Strong beats
        const isFirstBeatOfMeasure = (i === 0);
        let isStrongBeatInTimeSig = false;

        if (timeSignature === 4) { // 4/4: Strong on 1 and 3 (0 and 4 in 8-beat display)
            isStrongBeatInTimeSig = (i === 0 || i === 4);
        } else if (timeSignature === 3) { // 3/4: Strong on 1
            isStrongBeatInTimeSig = (i === 0);
        } else if (timeSignature === 2) { // 2/4: Strong on 1
            isStrongBeatInTimeSig = (i === 0);
        } else if (timeSignature === 6) { // 6/8: Strong on 1 and 4 (beat 0 and 3)
            isStrongBeatInTimeSig = (i === 0 || i === 3);
        } else if (timeSignature === 12) { // 12/8: Strong on 1, 4, 7, 10
             isStrongBeatInTimeSig = (i === 0 || i === 3 || i === 6 || i === 9);
        } else { // Other time signatures, typically strong on the first beat
            isStrongBeatInTimeSig = (i === 0);
        }


        if (isStrongBeatInTimeSig) {
            baseVolume = 1.0;
            color = '#1F618D'; // Strong beat color
            if (soundType === 'drums') {
                beatSound = (i === 0 || (timeSignature === 4 && i === 4) || (timeSignature === 6 && i === 3) || (timeSignature === 12 && (i===3 || i===6 || i===9))) ? 'kick,hihat' : 'kick,hihat'; // Kick on strong, snare on typical backbeats
                 if (timeSignature === 4 && (i === 2 || i === 6)) { // Snare on 2 and 4 for 4/4
                    beatSound = 'snare,hihat';
                    baseVolume = 0.8; // Snare slightly less than kick
                    color = '#D9534F'; // Snare color
                }
            }
        } else if (timeSignature === 4 && (i === 2 || i === 6) && soundType === 'drums') { // Snare on 2 & 4 for 4/4
            beatSound = 'snare,hihat';
            baseVolume = 0.8;
            color = '#D9534F';
        } else if (soundType === 'drums' && subdivisionFactor > 1 && (i % subdivisionFactor !== 0)) { // Off-beat hihats
            beatSound = 'hihat';
            baseVolume = 0.2;
            color = '#9E9E9E'; // Softer color for off-beats
        } else if (soundType !== 'drums' && subdivisionFactor > 1 && (i % subdivisionFactor !== 0)) { // Silent off-beats for click/woodblock
            beatSound = 'silent';
            baseVolume = 0;
            color = '#666';
        }


        beatDiv.dataset.sound = beatSound;
        beatDiv.dataset.baseVolume = baseVolume; // Store base volume for toggling accents
        beatDiv.dataset.volume = baseVolume;      // Current volume, can be toggled
        beatDiv.style.backgroundColor = color;

        beatDiv.addEventListener('click', () => toggleBeatAccent(beatDiv, soundType, subdivisionFactor > 1));
        container.appendChild(beatDiv);
    }
}
        
function toggleBeatAccent(beatElement, currentSoundType, isSubdivision) {
    // More nuanced accent toggling
    // States: 0 (silent), 0.3 (normal/off-beat), 1.0 (accented), 1.5 (super-accented, if desired)
    // Or for drums: 'hihat', 'snare,hihat', 'kick,hihat', 'silent'
    const currentVolume = parseFloat(beatElement.dataset.volume);
    let newVolume, newSound, newColor;

    if (currentSoundType === 'drums') {
        const sounds = ['silent', 'hihat', 'snare,hihat', 'kick,hihat'];
        const colors = ['#666', '#9E9E9E', '#D9534F', '#1F618D'];
        const volumes = [0, 0.3, 0.8, 1.0];
        
        let currentIndex = sounds.indexOf(beatElement.dataset.sound);
        if (currentIndex === -1) currentIndex = 1; // Default to hihat if unknown

        let nextIndex = (currentIndex + 1) % sounds.length;
        // Skip kick/snare for off-beats if it's a subdivision unless explicitly clicked to it
        if (isSubdivision && (sounds[nextIndex] === 'snare,hihat' || sounds[nextIndex] === 'kick,hihat')) {
            if (sounds[currentIndex] !== 'hihat' && sounds[currentIndex] !== 'silent') { // allow toggle from kick/snare back to hihat/silent
                 nextIndex = (currentIndex + 1) % sounds.length;
            } else {
                 nextIndex = (currentIndex + 2) % sounds.length; // Skip to next sensible state (e.g. hihat -> silent or silent -> hihat)
                 if (nextIndex === currentIndex) nextIndex = (nextIndex +1) % sounds.length; // ensure change
            }
        }


        newSound = sounds[nextIndex];
        newVolume = volumes[nextIndex];
        newColor = colors[nextIndex];

    } else { // Click or Woodblock
        const states = [
            { volume: 0, sound: 'silent', color: '#666' },    // Silent
            { volume: 0.3, sound: currentSoundType, color: '#9E9E9E' }, // Normal off-beat
            { volume: 1.0, sound: currentSoundType, color: '#1F618D' }  // Accented
        ];
        // Find current state based on volume
        let currentStateIndex = states.findIndex(s => s.volume === currentVolume);
        if (currentStateIndex === -1) { // If current volume doesn't match, find closest or default
            if (currentVolume > 0.5) currentStateIndex = 2;
            else if (currentVolume > 0) currentStateIndex = 1;
            else currentStateIndex = 0;
        }
        
        const nextState = states[(currentStateIndex + 1) % states.length];
        newVolume = nextState.volume;
        newSound = nextState.sound;
        newColor = nextState.color;
    }

    beatElement.dataset.volume = newVolume;
    beatElement.dataset.sound = newSound;
    beatElement.dataset.baseVolume = newVolume; // Update baseVolume as well, as user explicitly set it
    beatElement.style.backgroundColor = newColor;
}


async function playBeat() { // This is the metronome's tick function
    const beatsUI = document.querySelectorAll('.beat');
    if (beatsUI.length === 0) return; // No beats to play

    // Deactivate previous beat
    beatsUI.forEach(b => b.classList.remove('active'));
    
    // Activate current beat UI
    const currentBeatElement = beatsUI[AppState.currentBeat];
    if (currentBeatElement) {
        currentBeatElement.classList.add('active');
        const baseVolumeForType = parseFloat(currentBeatElement.dataset.volume) || 0;
        if (baseVolumeForType > 0) {
            await playMetronomeSound(baseVolumeForType);
        }
    }

    // Chord progression and fretboard update logic
    const measures = UI.elements.measures.children;
    if (measures.length > 0) {
        const currentMeasureElement = measures[AppState.currentMeasure];
        if (currentMeasureElement) {
            // Update active measure highlight
            Array.from(measures).forEach((m, idx) => m.classList.toggle('active', idx === AppState.currentMeasure));

            const root = currentMeasureElement.querySelector('.chord-controls .root-note')?.value;
            const quality = currentMeasureElement.querySelector('.chord-controls .chord-quality')?.value; // This is CHORD_INTERVALS key
            
            const scaleRoot = currentMeasureElement.querySelector('.scale-controls .second-key')?.value;
            const scaleType = currentMeasureElement.querySelector('.scale-controls .scale-select')?.value;

            if (root && quality && scaleRoot && scaleType) {
                // Update main fretboard display
                const chordTuning = TUNINGS[UI.elements.chordTuning.value];
                updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, chordTuning);

                // Play chord sound
                const timeSignatureValue = parseInt(UI.elements.timeSignature.value);
                const beatDurationSec = 60 / AppState.tempo;
                let chordPlayDuration = beatDurationSec * timeSignatureValue; // Default: chord lasts one measure
                
                // Play chord on the '1' of the measure, or specific beats for 4/4
                if (timeSignatureValue === 4) {
                    chordPlayDuration = beatDurationSec * 2; // Chord lasts 2 quarter notes (half measure)
                    if (AppState.currentBeat === 0 || AppState.currentBeat === 4) { // Play on beat 1 and 3 (0 and 4 in 8-beat display)
                        playChord(root, quality, AudioContextManager.context.currentTime, chordPlayDuration, AppState.currentBeat === 4);
                    }
                } else { // For other time signatures, play chord on beat 1 of the measure
                    if (AppState.currentBeat === 0) {
                        playChord(root, quality, AudioContextManager.context.currentTime, chordPlayDuration, false);
                    }
                }
            }
        }
    }
    
    // Advance beat and measure counters
    const totalBeatsInDisplay = beatsUI.length; // e.g., 8 for 4/4, 3 for 3/4
    AppState.currentBeat = (AppState.currentBeat + 1) % totalBeatsInDisplay;
    
    if (AppState.currentBeat === 0 && measures.length > 0) { // Advanced to next measure
        AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
    }
    // AppState.updateState({}); // If listeners need to know about beat/measure change
}


async function startPlayback() {
    try {
        await AudioContextManager.ensureAudioContext(); // Crucial: ensure audio is ready
        
        if (AppState.isPlaying) return;
        
        const measures = UI.elements.measures.children;
        if (measures.length === 0) {
            log('No measures to play.');
            // Optionally, could just run metronome without chords
            // For now, require measures for playback with chords.
            // return; 
        }
        
        const timeSignatureNum = parseInt(UI.elements.timeSignature.value);
        let intervalMs = (60 / AppState.tempo) * 1000; 
        if (timeSignatureNum === 4) { // For 4/4, interval is for 8th notes if displaying 8 beats
            intervalMs /= 2;
        } else if (timeSignatureNum === 6 || timeSignatureNum === 12) {
            // If displaying each 8th note, interval is per 8th note.
            // If felt in pulses (e.g. 6/8 as two dotted quarters), this might need adjustment
            // But current createBeats shows each 8th.
        }


        AppState.currentBeat = 0; // Reset beat for current measure
        // AppState.currentMeasure is NOT reset here, playback continues from where it stopped or from start if first time.

        // Initial chord play for the first beat before interval starts
        // This ensures the first chord/beat sounds immediately.
        if (!AppState.intervalId) { // Only if not resuming from a simple tempo change
            AppState.currentBeat = 0;
            AppState.currentMeasure = 0; // Start from the beginning of the progression
            await playBeat(); // Play the first beat/chord immediately
             // Advance beat for the first setInterval tick
            const totalBeatsInDisplay = document.querySelectorAll('.beat').length;
            AppState.currentBeat = (AppState.currentBeat + 1) % totalBeatsInDisplay;
            if (AppState.currentBeat === 0 && measures.length > 0) {
                 AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
            }
        }


        clearInterval(AppState.intervalId); // Clear any existing interval
        AppState.intervalId = setInterval(async () => {
            await playBeat(); // Call the main beat playing logic
        }, intervalMs);
        
        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started.");
        
    } catch (error) {
        console.error('Failed to start playback:', error);
        alert('Playback error. Please ensure audio is enabled and try again.');
        stopPlayback(); // Reset state
    }
}

function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false }); // Keep currentBeat and currentMeasure for resume
    
    document.querySelectorAll('.beat.active').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));
    
    if (AudioContextManager.currentChordGain && AudioContextManager.context) {
        const now = AudioContextManager.context.currentTime;
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, now);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        AudioContextManager.currentChordGain = null; // Allow it to be garbage collected
    }
    
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped.");
}

function updateProgressionKey(newKey) {
    // Song info display should remain as the song is still "loaded", just transposed
    // No need to clear it here unless a new song is chosen (handled in loadProgression)

    Array.from(UI.elements.measures.children).forEach((measureElement, index) => {
        if (index < currentFunctionalProgression.length) {
            const romanChordString = currentFunctionalProgression[index];
            const parsedChord = parseRomanNumeralToAbsoluteChord(romanChordString, newKey);

            const rootSelect = measureElement.querySelector('.root-note');
            const qualitySelect = measureElement.querySelector('.chord-quality');
            const secondKeySelect = measureElement.querySelector('.scale-controls .second-key');
            const scaleSelect = measureElement.querySelector('.scale-controls .scale-select');

            if (rootSelect) rootSelect.value = parsedChord.root;
            if (qualitySelect) qualitySelect.value = parsedChord.quality;
            if (secondKeySelect) secondKeySelect.value = parsedChord.root;
            if (scaleSelect) scaleSelect.value = suggestScaleForQuality(parsedChord.quality);
        }
    });

    addFirstChordListener();
    log(`Progression '${currentProgressionName}' re-calculated for new key: ${newKey}`);
}


function addMeasure(root = 'C', quality = 'maj7', scaleRoot = 'C', scaleType = 'major') { // Default quality is CHORD_INTERVALS key
    const measureCount = UI.elements.measures.children.length + 1;
    const measureDiv = document.createElement('div');
    measureDiv.className = 'measure';
    measureDiv.draggable = true;
    
    measureDiv.innerHTML = `
        <span class="measure-number">${measureCount}</span>
        <div class="chord-controls">
            <select class="root-note">${createKeyOptions(root)}</select>
            <select class="chord-quality">${createQualityOptions(quality)}</select>
        </div>
        <div class="scale-controls">
            <select class="second-key">${createKeyOptions(scaleRoot)}</select>
            <select class="scale-select">${createScaleOptions(scaleType)}</select>
        </div>
    `;
    
    UI.elements.measures.appendChild(measureDiv);
    measureDiv.querySelectorAll('select').forEach(sel => {
        sel.addEventListener('change', () => handleMeasureControlChange(measureDiv));
    });
    
    // Add drag/drop event listeners if implemented
    // measureDiv.addEventListener('dragstart', dragStart); ...

    updateMeasureNumbers();
    if (measureCount === 1) addFirstChordListener(); // If it's the first measure, update main fretboard
    log(`Added measure ${measureCount}`);
}

function removeMeasure() {
    const measures = UI.elements.measures.children;
    if (measures.length > 0) {
        measures[measures.length - 1].remove();
        updateMeasureNumbers();
        if (measures.length > 0) addFirstChordListener(); // Update fretboard if measures still exist
        else if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = ""; // Clear display if no measures
        log(`Removed last measure`);
    }
}

function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        const numberSpan = measure.querySelector('.measure-number');
        if (numberSpan) numberSpan.textContent = index + 1;
    });
}

// Drag and Drop Handlers (basic structure)
function dragStart(e) {
    e.dataTransfer.setData('text/plain', Array.from(UI.elements.measures.children).indexOf(e.target));
    setTimeout(() => e.target.classList.add('dragging'), 0);
}
function dragOver(e) { e.preventDefault(); }
function drop(e) {
    e.preventDefault();
    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
    const targetElement = e.target.closest('.measure');
    if (!targetElement) return;
    const targetIndex = Array.from(UI.elements.measures.children).indexOf(targetElement);
    
    if (draggedIndex === targetIndex || isNaN(draggedIndex) || isNaN(targetIndex)) return;
    
    const measuresArray = Array.from(UI.elements.measures.children);
    const draggedMeasure = measuresArray[draggedIndex];
    
    // Re-insert
    if (draggedIndex < targetIndex) {
        targetElement.after(draggedMeasure);
    } else {
        targetElement.before(draggedMeasure);
    }
    updateMeasureNumbers();
    // Update currentFunctionalProgression if a song was loaded
    if (currentFunctionalProgression.length > 0) {
        const movedItem = currentFunctionalProgression.splice(draggedIndex, 1)[0];
        currentFunctionalProgression.splice(targetIndex, 0, movedItem);
    }
    addFirstChordListener(); // Update main fretboard
    log(`Moved measure from index ${draggedIndex} to ${targetIndex}`);
}
function dragEnd(e) { e.target.classList.remove('dragging');}


function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) { console.error("FretFlow grid not found."); return; }
    fretboardsGrid.innerHTML = ''; 
    
    fretboardsGrid.style.display = 'grid';
    fretboardsGrid.style.gridTemplateColumns = 'repeat(2, 1fr)';
    fretboardsGrid.style.gap = '20px';
    
    for (let i = 0; i < 4; i++) {
        const fretboardSection = document.createElement('div');
        fretboardSection.className = 'fretboard-section';
        
        const scaleOptionsHTML = Object.entries(SCALES).map(([scaleKey, _]) => {
            const displayName = scaleKey.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
            return `<option value="${scaleKey}">${displayName}</option>`;
        }).join('');
        
        fretboardSection.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group">
                    <label for="fretflow-key-${i}">Key:</label>
                    <select id="fretflow-key-${i}" class="fretflow-key">${createKeyOptions()}</select>
                </div>
                <div class="control-group">
                    <label for="fretflow-scale-${i}">Scale:</label>
                    <select id="fretflow-scale-${i}" class="fretflow-scale">${scaleOptionsHTML}</select>
                </div>
                <div class="control-group">
                    <label for="fretflow-tuning-${i}">Tuning:</label>
                    <select id="fretflow-tuning-${i}" class="tuning-select">
                        <option value="standard">Standard</option><option value="dropD">Drop D</option>
                        <option value="openG">Open G</option><option value="DADGAD">DADGAD</option>
                        <option value="openE">Open E</option>
                    </select>
                </div>
            </div>
            <div class="scale-display" id="fretflow-scale-display-${i}"></div>
            <div id="fretflow-fretboard-${i}" class="fretboard"></div>
        `;
        fretboardsGrid.appendChild(fretboardSection);
        
        const fretboardEl = fretboardSection.querySelector(`#fretflow-fretboard-${i}`);
        const keySelectEl = fretboardSection.querySelector(`#fretflow-key-${i}`);
        const scaleSelectEl = fretboardSection.querySelector(`#fretflow-scale-${i}`);
        const tuningSelectEl = fretboardSection.querySelector(`#fretflow-tuning-${i}`);
        const scaleDisplayEl = fretboardSection.querySelector(`#fretflow-scale-display-${i}`);
        
        function updateThisFretFlowFretboard() {
            const selectedKey = keySelectEl.value;
            const selectedScale = scaleSelectEl.value;
            const selectedTuningValue = tuningSelectEl.value;
            const selectedTuningArray = TUNINGS[selectedTuningValue];
            
            if (!selectedTuningArray) { console.error(`Invalid tuning ${selectedTuningValue} for FretFlow`); return; }
            
            const displayScaleName = scaleSelectEl.options[scaleSelectEl.selectedIndex].text;
            scaleDisplayEl.textContent = `${selectedKey} ${displayScaleName}`;
            
            createFretboard(fretboardEl, selectedTuningArray);
            updateFretboardNotes(fretboardEl, selectedKey, selectedScale, selectedTuningArray);
            // Note click handlers are added within updateFretboardNotes if it's general enough,
            // or could be called here specifically: attachNoteClickHandlers(fretboardEl);
        }
        
        keySelectEl.addEventListener('change', updateThisFretFlowFretboard);
        scaleSelectEl.addEventListener('change', updateThisFretFlowFretboard);
        tuningSelectEl.addEventListener('change', updateThisFretFlowFretboard);
        
        updateThisFretFlowFretboard(); // Initial render
    }
    log("FretFlow initialized with 4 independent fretboards.");
}
      
function addFirstChordListener() { // Updates main fretboard display based on first measure
    const firstMeasure = UI.elements.measures.firstElementChild;
    if (firstMeasure) {
        const scaleRootSelect = firstMeasure.querySelector('.scale-controls .second-key');
        const scaleTypeSelect = firstMeasure.querySelector('.scale-controls .scale-select');
        const tuningSelect = UI.elements.chordTuning;

        const updateFirstMeasureFretboard = () => {
            if (scaleRootSelect && scaleTypeSelect && tuningSelect) {
                const tuning = TUNINGS[tuningSelect.value];
                updateFretboardNotes(UI.elements.chordFretboard, scaleRootSelect.value, scaleTypeSelect.value, tuning);
            }
        };
        // These listeners are now part of handleMeasureControlChange, but this ensures initial setup
        updateFirstMeasureFretboard(); 
    } else {
        // No measures, clear or show default on main fretboard
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, "C", "major", tuning);
        if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "C Major (Default)";
    }
}

function handleMeasureControlChange(measureElement) {
    // Update the scale root and type based on chord, if desired
    const rootSelect = measureElement.querySelector('.chord-controls .root-note');
    const qualitySelect = measureElement.querySelector('.chord-controls .chord-quality');
    const scaleRootSelect = measureElement.querySelector('.scale-controls .second-key');
    const scaleTypeSelect = measureElement.querySelector('.scale-controls .scale-select');

    if (rootSelect && qualitySelect && scaleRootSelect && scaleTypeSelect) {
        scaleRootSelect.value = rootSelect.value; // Default scale root to chord root
        scaleTypeSelect.value = suggestScaleForQuality(qualitySelect.value);
    }
    
    // If this is the first measure, update the main fretboard display
    if (measureElement === UI.elements.measures.firstElementChild) {
        addFirstChordListener();
    }
    // If playback is active and this is the current measure, could update fretboard immediately
    const measureIndex = Array.from(UI.elements.measures.children).indexOf(measureElement);
    if (AppState.isPlaying && measureIndex === AppState.currentMeasure) {
        const tuning = TUNINGS[UI.elements.chordTuning.value];
        updateFretboardNotes(UI.elements.chordFretboard, scaleRootSelect.value, scaleTypeSelect.value, tuning);
    }
}


function setupEventListeners() {
    // Audio initialization on first user interaction
    document.body.addEventListener('click', ensureAudioInitializedUserInteraction, { once: true });
    
    UI.elements.startStopButton.addEventListener('click', () => {
        if (AppState.isPlaying) stopPlayback(); else startPlayback();
    });

    if (UI.elements.drumSetToggleBtn) {
        UI.elements.drumSetToggleBtn.addEventListener('click', () => {
            currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
            UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
            log(`Switched to drum set: ${drumSoundSets[currentDrumSetIndex].name}`);
        });
    }

    if (UI.elements.soundType) {
        UI.elements.soundType.addEventListener('change', (e) => onMetronomeInstrumentChange(e.target.value));
        // Initial state for drumSetToggleBtn visibility
        onMetronomeInstrumentChange(UI.elements.soundType.value);
    }

    let colorMode = 0; // 0: Light, 1: DM1, 2: DM2, 3: DM3
    UI.elements.darkModeToggle.addEventListener('click', () => {
        colorMode = (colorMode + 1) % 4;
        document.body.classList.remove('dark-mode', 'dark-mode-2', 'dark-mode-3');
        UI.elements.darkModeToggle.classList.remove('active', 'active-2', 'active-3');
        
        const modes = ['', 'dark-mode', 'dark-mode-2', 'dark-mode-3'];
        const activeClasses = ['', 'active', 'active-2', 'active-3'];
        if (colorMode > 0) {
            document.body.classList.add(modes[colorMode]);
            UI.elements.darkModeToggle.classList.add(activeClasses[colorMode]);
        }
        log(`Color mode set to: ${modes[colorMode] || 'Light Mode'}`);
    });

    UI.elements.chordsEnabled.addEventListener('click', () => {
        const isActive = UI.elements.chordsEnabled.classList.toggle('active');
        UI.elements.chordsEnabled.textContent = isActive ? 'Chords Enabled' : 'Chords Disabled';
        log(`Chords ${isActive ? 'enabled' : 'disabled'}`);
    });

    UI.elements.tempo.addEventListener('input', () => {
        AppState.tempo = parseInt(UI.elements.tempo.value);
        UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        if (AppState.isPlaying) { // Restart playback with new tempo
            stopPlayback(); startPlayback();
        }
    });
    let tapTempoTimestamps = [];
    UI.elements.tapTempo.addEventListener('click', () => {
        const now = Date.now();
        tapTempoTimestamps.push(now);
        if (tapTempoTimestamps.length > 4) tapTempoTimestamps.shift(); // Keep last 4 taps

        if (tapTempoTimestamps.length > 1) {
            let totalInterval = 0;
            for (let i = 1; i < tapTempoTimestamps.length; i++) {
                totalInterval += tapTempoTimestamps[i] - tapTempoTimestamps[i-1];
            }
            const avgInterval = totalInterval / (tapTempoTimestamps.length - 1);
            if (avgInterval > 0 && avgInterval < 3000) { // Reasonable interval range
                const bpm = Math.round(60000 / avgInterval);
                AppState.tempo = Math.max(40, Math.min(220, bpm));
                UI.elements.tempo.value = AppState.tempo;
                UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
            }
        }
        // Reset if too long between taps
        setTimeout(() => { if (tapTempoTimestamps.length > 0 && Date.now() - tapTempoTimestamps[tapTempoTimestamps.length-1] > 3000) tapTempoTimestamps = []; }, 3100);
    });


    UI.elements.timeSignature.addEventListener('change', () => {
        createBeats();
        if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
    });

    // Volume controls just log for now, actual volume applied in playback functions
    UI.elements.metronomeVolume.addEventListener('input', () => log(`Metronome volume slider: ${UI.elements.metronomeVolume.value}`));
    UI.elements.chordFretboardVolume.addEventListener('input', () => log(`Fretboard note volume slider: ${UI.elements.chordFretboardVolume.value}`));
    UI.elements.chordVolume.addEventListener('input', () => log(`Chord playback volume slider: ${UI.elements.chordVolume.value}`));
    if (UI.elements.reverbDial && UI.elements.reverbDialValue) {
        UI.elements.reverbDial.addEventListener('input', function(e) {
            const value = parseInt(e.target.value, 10);
            AudioContextManager.reverbAmount = value / 100;
            UI.elements.reverbDialValue.textContent = value;
            log(`Reverb amount set to: ${AudioContextManager.reverbAmount}`);
        });
    }


    UI.elements.progressionSelect.addEventListener('change', (e) => {
        const selectedSong = e.target.value;
        const currentKeyFromUI = UI.elements.keySelect.value; // Use the currently selected key in UI
        loadProgression(selectedSong, currentKeyFromUI);
    });

    UI.elements.keySelect.addEventListener('change', (e) => {
        const newKey = e.target.value;
        // If a song is loaded (currentFunctionalProgression has items), update its key.
        // Otherwise, this key change is for manual entries or default display.
        updateProgressionKey(newKey);
    });
    
    UI.elements.chordTuning.addEventListener('change', () => {
        addFirstChordListener(); // Update main fretboard with new tuning
        initializeFretFlow();    // Reinitialize FretFlow boards if tuning changes affect them
    });

    // Event delegation for measure controls (if measures are dynamically added/removed)
    // This is now handled by adding listeners when measures are created/parsed in loadProgression/addMeasure.
    // UI.elements.measures.addEventListener('change', (e) => { ... });

    // Setup for drag and drop on measures container
    UI.elements.measures.addEventListener('dragover', dragOver);
    UI.elements.measures.addEventListener('drop', drop);
    // Individual measures get dragstart/dragend when created.
    
    log("Event listeners set up.");
}

// Initialize the application
async function initializeApp() {
    try {
        // Initialize UI first to ensure all elements are cached
        UI.init();
        if (!UI.elements.measures || !UI.elements.progressionSelect || !UI.elements.keySelect) {
            throw new Error("Critical UI elements not found");
        }

        // Initialize audio with proper error handling
        try {
            await AudioContextManager.initialize();
            log("Audio context initialized successfully");
        } catch (error) {
            console.warn("Initial AudioContextManager initialization delayed:", error);
            updateLoadingStatus("Audio will be enabled on first interaction");
            // Will retry on user interaction via ensureAudioInitializedUserInteraction
        }

        // Create metronome beats
        createBeats();
        if (!document.querySelector('.beats-container .beat')) {
            console.warn("Beats creation may have failed");
        }

        // Initialize fretboard with proper error checking
        const initialTuning = UI.elements.chordTuning?.value 
            ? TUNINGS[UI.elements.chordTuning.value] 
            : TUNINGS.standard;
        
        if (UI.elements.chordFretboard) {
            createFretboard(UI.elements.chordFretboard, initialTuning);
            log("Fretboard created with tuning:", initialTuning);
        } else {
            throw new Error("Chord fretboard container not found");
        }

        // Initialize progression with fallbacks
        const initialProgression = UI.elements.progressionSelect?.value || 'I V7';
        const initialKey = UI.elements.keySelect?.value || 
                          progressions[initialProgression]?.defaultKey || 
                          "C";

        if (!progressions[initialProgression]) {
            console.warn(`Progression ${initialProgression} not found, using fallback`);
        }

        // Load initial progression
        await loadProgression(initialProgression, initialKey);
        log(`Loaded initial progression: ${initialProgression} in ${initialKey}`);

        // Initialize additional components
        initializeFretFlow();
        initializeScaleSelects();
        setupEventListeners();

        // Update UI to show initialization complete
        updateLoadingStatus("Application Ready");
        log("Application initialization complete");

        // Hide loading indicator smoothly
        setTimeout(() => {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) {
                indicator.style.opacity = '0';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 300); // Hide after fade
            }
        }, 1000);

    } catch (error) {
        console.error("Application initialization failed:", error);
        updateLoadingStatus("Initialization failed. Please refresh the page.");
        throw error; // Re-throw for global error handling
    }
}
// Initial setup when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Full application initialization failed:", error);
        updateLoadingStatus("Error during initialization. Some features may not work.");
    });
});

            </script>
        </body>
        </html>
