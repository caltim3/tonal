<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0; /* Lighter default background */
        }
        .app-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .fretboards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .fretboard-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .scale-display {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }
        .controls, .top-controls { /* Added .top-controls */
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: bold;
        }
        
        .control-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .fretboard {
            position: relative;
            height: 200px;
            background-color: #FFCF79; /* Tan color for fretboard wood */
            border-radius: 5px;
            margin-bottom: 30px; /* Space for fret numbers */
            border: 2px solid #4A3B31; /* Darker wood color for border */
            overflow: visible; /* Allow fret numbers to show */
        }
        .fret-line {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px; /* Thinner fret lines */
            background: #A0A0A0; /* Lighter gray for frets */
            border-right: 1px solid rgba(0,0,0,0.1); /* Subtle shadow */
            z-index: 1;
        }
        .string-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px;
            background: #C0C0C0; /* Silver for strings */
            border-bottom: 1px solid rgba(0,0,0,0.1); /* Subtle shadow */
            z-index: 0; /* Behind notes */
        }
        .fret-number {
            position: absolute;
            bottom: -25px; /* Closer to the fretboard */
            font-size: 14px; /* Slightly smaller */
            color: #555; /* Dark gray for numbers */
            transform: translateX(-50%);
            font-weight: bold;
            z-index: 2;
            width: 20px;
            text-align: center;
        }
        .fret-marker { /* Dot inlays */
            position: absolute;
            width: 10px; /* Slightly smaller */
            height: 10px;
            background-color: #5A4F46; /* Darker inlay color */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 1; /* Above strings, below notes if overlapping */
        }
        .note {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            z-index: 3;
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .note.guide-tone-highlight { /* For guide tones */
            box-shadow: 0 0 0 3px orange, 0 1px 3px rgba(0,0,0,0.2);
            /* Or use outline: 3px solid orange; */
        }
        .note:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .beat {
            width: 40px;
            height: 80px;
            background: #9E9E9E;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: all 0.2s ease;
            font-size: 14px;
            margin: 0 2px;
        }
        .beats-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 20px 0;
            flex-wrap: nowrap; /* Ensure beats stay in one line */
            overflow-x: auto; /* Allow horizontal scrolling if too many beats */
        }
        .beat.active {
            transform: translateY(-10px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #measures {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* Responsive columns */
            gap: 20px;
        }
        .measure {
            position: relative;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            transition: opacity 0.2s ease, background-color 0.2s ease, border 0.2s ease;
            border: 2px solid transparent; /* For selection border */
            cursor: pointer; /* Indicate clickable for looping */
        }
        .measure.loop-selected {
            border: 2px solid #007bff; /* Blue border for loop selection */
            background-color: #e6f2ff;
        }
        .measure.dragging {
            opacity: 0.5;
        }
        .measure.active { /* Current playing measure */
            background-color: #c3e6cb;
            border: 2px solid #28a745;
        }
        .measure-number {
            position: absolute;
            top: 5px;
            left: 5px; /* Moved to top-left for better click target on measure */
            font-size: 12px;
            color: #333;
            background-color: rgba(255,255,255,0.7);
            padding: 2px 4px;
            border-radius: 3px;
        }
        .chord-controls, .scale-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .chord-controls select, .scale-controls select {
            flex: 1;
        }

        .fretboard-section {
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        
        body.dark-mode .fretboard-section {
            background-color: #3a441e; /* Adjusted for green dark mode */
            border-color: #606c38;
            color: #fefae0;
        }
        
        body.dark-mode-2 .fretboard-section {
            background-color: #001f54;
            border-color: #1282a2;
            color: #fefcfb;
        }
        
        body.dark-mode-3 .fretboard-section {
            background-color: #a5a58d;
            border-color: #cb997e;
            color: #ffe8d6;
        }
        
        .fretboard-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-group label {
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .control-group select {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        @media (max-width: 1200px) {
            /* #measures grid-template-columns already responsive */
        }
        @media (max-width: 600px) {
            /* #measures grid-template-columns already responsive */
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        button, .button-like { /* Added .button-like for styling consistency */
            padding: 10px 15px; /* Adjusted padding */
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }
        button:hover, .button-like:hover {
            background: #45a049;
        }
        button.secondary { /* For less prominent buttons */
            background-color: #007bff;
        }
        button.secondary:hover {
            background-color: #0056b3;
        }
        button.danger {
            background-color: #a8dadc;
        }
        button.danger:hover {
            background-color: #c82333;
        }


        select {
            padding: 8px 10px; /* Increased padding */
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
            background-color: white; /* Default background */
        }
        #tempo-display {
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 10px;
            min-width: 70px; /* Ensure space */
            text-align: center;
        }
        #loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.8);
            color: white;
            border-radius: 5px;
            z-index: 1000;
            font-size: 0.9em;
        }

        .checkbox-wrapper { /* Re-evaluate if this specific wrapper is still needed */
            margin-top: 10px;
            margin-left: 0; /* Align with other controls */
            display: flex;
            align-items: center;
        }

        .control-button { /* Generic class for toggle buttons */
            padding: 8px 12px; /* Adjusted padding */
            font-size: 0.9em;
            /* background will be handled by .active / :not(.active) for toggle-button */
        }
        
        #chordsEnabled { /* Specific ID if needed, but .toggle-button is better */
            margin-bottom: 10px;
        }
        body.dark-mode {
            background-color: #283618; color: #fefae0; transition: background-color 0.3s ease, color 0.3s ease;
        }
        .dark-mode .app-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .dark-mode .fretboard-container { background-color: #606c38; border: 1px solid #dda15e; }
        .dark-mode .fretboard { background-color: #dda15e; border: 2px solid #4b4b4b; }
        .dark-mode .note { color: #283618; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .dark-mode .scale-display { color: #fefae0; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .dark-mode button, .dark-mode .button-like { background-color: #dda15e; color: #283618; border: 1px solid #bc6c25; }
        .dark-mode button:hover, .dark-mode .button-like:hover { background-color: #bc6c25; }
        .dark-mode button.secondary { background-color: #a17d40; } /* Dark mode secondary */
        .dark-mode button.secondary:hover { background-color: #8a6930; }
        .dark-mode select { background-color: #dda15e; color: #283618; border: 1px solid #bc6c25; }
        .dark-mode select:hover { background-color: #bc6c25; }
        .dark-mode .measure { background-color: #606c38; color: #fefae0; border: 1px solid #dda15e; }
        .dark-mode .measure.active { background-color: #dda15e; border-color: #bc6c25; }
        .dark-mode .measure.loop-selected { border-color: #ffc107; background-color: #7d6830; }
        .dark-mode .beat { background-color: #dda15e; color: #283618; }
        .dark-mode .beat.active { background-color: #bc6c25; transform: translateY(-5px); }
        .dark-mode .volume-control { color: #fefae0; }
        #dark-mode-toggle.active { background-color: #283618; color: #fefae0; border: 1px solid #dda15e; }

        .dark-mode-2 { background-color: #0a1128; color: #fefcfb; }
        .dark-mode-2 .app-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
        .dark-mode-2 .fretboard-container { background-color: #034078; border: 1px solid #1282a2; }
        .dark-mode-2 .fretboard { background-color: #001f54; border: 2px solid #1282a2; }
        .dark-mode-2 .note { color: #fefcfb; }
        .dark-mode-2 .scale-display { color: #fefcfb; }
        .dark-mode-2 button, .dark-mode-2 .button-like { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }
        .dark-mode-2 button:hover, .dark-mode-2 .button-like:hover { background-color: #0e6c89; }
        .dark-mode-2 button.secondary { background-color: #0c5f7d; }
        .dark-mode-2 button.secondary:hover { background-color: #094b61; }
        .dark-mode-2 select { background-color: #034078; color: #fefcfb; border: 1px solid #1282a2; }
        .dark-mode-2 .measure { background-color: #034078; color: #fefcfb; border: 1px solid #1282a2; }
        .dark-mode-2 .measure.active { background-color: #1282a2; border-color: #fefcfb; }
        .dark-mode-2 .measure.loop-selected { border-color: #61dafb; background-color: #01325A; }
        .dark-mode-2 .beat { background-color: #1282a2; color: #fefcfb; }
        .dark-mode-2 .beat.active { background-color: #034078; }
        #dark-mode-toggle.active-2 { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }

        .dark-mode-3 { background-color: #6b705c; color: #ffe8d6; }
        .dark-mode-3 .app-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; }
        .dark-mode-3 .fretboard-container { background-color: #a5a58d; border: 1px solid #cb997e; }
        .dark-mode-3 .fretboard { background-color: #cb997e; border: 2px solid #6b705c; }
        .dark-mode-3 .note { color: #6b705c; }
        .dark-mode-3 .scale-display { color: #ffe8d6; }
        .dark-mode-3 button, .dark-mode-3 .button-like { background-color: #cb997e; color: #6b705c; border: 1px solid #6b705c; }
        .dark-mode-3 button:hover, .dark-mode-3 .button-like:hover { background-color: #b2856c; }
        .dark-mode-3 button.secondary { background-color: #b18f7a; }
        .dark-mode-3 button.secondary:hover { background-color: #9a7860; }
        .dark-mode-3 select { background-color: #ddbea9; color: #6b705c; border: 1px solid #cb997e; }
        .dark-mode-3 .measure { background-color: #a5a58d; color: #ffe8d6; border: 1px solid #cb997e; }
        .dark-mode-3 .measure.active { background-color: #ddbea9; border-color: #cb997e; }
        .dark-mode-3 .measure.loop-selected { border-color: #e7ad99; background-color: #BDA290; }
        .dark-mode-3 .beat { background-color: #ddbea9; color: #6b705c; }
        .dark-mode-3 .beat.active { background-color: #cb997e; }
        #dark-mode-toggle.active-3 { background-color: #cb997e; color: #ffe8d6; border: 1px solid #6b705c; }

        .dark-mode #fretflow-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; }
        .dark-mode-2 #fretflow-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
        .dark-mode-3 #fretflow-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; }
        
        .toggle-button { /* General toggle button styling */
            padding: 8px 12px; /* Consistent padding */
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 0.9em;
        }
        .toggle-button.active {
            background: #4CAF50; /* Green when active */
        }
        .toggle-button:not(.active) {
            background: #9E9E9E; /* Grey when inactive */
        }

        /* Styling for song info display */
        #song-info-display {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }
        body.dark-mode #song-info-display { background-color: #4a542e; border-color: #7a845e; color: #fefae0; }
        body.dark-mode-2 #song-info-display { background-color: #023059; border-color: #0f6090; color: #fefcfb; }
        body.dark-mode-3 #song-info-display { background-color: #8a8a75; border-color: #b6a191; color: #ffe8d6; }

        #current-song-title {
            font-size: 1.4em; font-weight: bold; margin-top: 0; margin-bottom: 5px; color: #212529;
        }
        body.dark-mode #current-song-title { color: #fefae0; }
        body.dark-mode-2 #current-song-title { color: #fefcfb; }
        body.dark-mode-3 #current-song-title { color: #ffe8d6; }

        #current-song-description {
            font-size: 0.95em; margin-top: 0; margin-bottom: 0; line-height: 1.4; color: #495057;
        }
        body.dark-mode #current-song-description { color: #e0daca; }
        body.dark-mode-2 #current-song-description { color: #e0e0df; }
        body.dark-mode-3 #current-song-description { color: #f0d8c6; }

        /* User songs section */
        #user-songs-section { margin-top: 15px; }
        #user-songs-section label { margin-right: 5px; }
        
    </style>
</head>
<body>
    <div class="top-controls app-section"> <!-- Moved some top-level controls here -->
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <button id="guide-tones-toggle" class="toggle-button" aria-label="Toggle guide tones">Guide Tones Off</button>
        <button id="loop-selected-toggle" class="toggle-button" aria-label="Toggle measure looping">Looping Off</button>
    </div>

    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <!-- Dark mode toggle moved to top-controls -->
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <div class="scale-display" id="scale-display">Select a progression and key.</div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls">
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option> <option value="3">3/4</option> <option value="4" selected>4/4</option>
                <option value="6">6/8</option> <option value="7">7/8</option> <option value="8">8/8</option> <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option> <option value="woodblock">Woodblock</option> <option value="drums">Drums</option>
            </select>
            <button id="drumSetToggleBtn" class="control-button">Drums</button>
            <div class="volume-control">
                <span>Metronome Volume:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>
        <div class="beats-container"></div>
         <div class="volume-control"> <!-- Moved accent intensity here -->
            <label for="accent-intensity">Accent Intensity:</label>
            <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
        </div>
    </div>
    
    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <div id="song-info-display">
            <h4 id="current-song-title"></h4> 
            <p id="current-song-description"></p>
        </div>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
        <div class="controls"> <!-- Wrapped selects in a controls div -->
            <label for="progression-select">Select Progression:</label>
            <select id="progression-select" aria-label="Select chord progression">
                <option value="I V7">I-V7</option> <option value="jazz_blues">Jazz Blues</option> <option value="minor_blues">Minor Blues</option>
                <option value="rhythm_changes">Rhythm Changes</option> <option value="2_5_1">II-V-I</option> <option value="6_2_5_1">VI-II-V-I</option>
                <option value="minor_2_5_1">Minor iim-V7-im</option> <option value="dark_eyes">Dark Eyes</option>
                <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams</option> <option value="rose_room">Rose Room</option>
                <option value="black_orpheus">Black Orpheus</option> <option value="all_the_things_you_are">All The Things You Are</option>
                <option value="all_of_me">All of Me</option> <option value="stella_by_starlight">Stella By Starlight</option>
                <option value="autumn_leaves">Autumn Leaves</option> <option value="summertime">Summertime</option>
                <option value="girl_from_ipanema">Girl From Ipanema</option> <option value="coltrane_changes">Coltrane Changes</option>
                <option value="bird_blues">Bird Blues</option> <option value="just_friends">Just Friends</option>
                <option value="blue_bossa">Blue Bossa</option> <option value="on_green_dolphin_street">On Green Dolphin Street</option>
                <option value="solar">Solar</option> <option value="misty">Misty</option>
                <option value="days_of_wine_and_roses">Days of Wine and Roses</option> <option value="cherokee">Cherokee</option>
                <option value="caravan">Caravan</option> <option value="nows_the_time">Now's The Time</option> <option value="tenor_madness">Tenor Madness</option>
            </select>
            <label for="keySelect">Select Key:</label>
            <select id="keySelect" aria-label="Select key">
              <option value="C">C</option> <option value="Cm">Cm</option> <option value="Db">Db</option> <option value="Dbm">Dbm</option>
              <option value="D">D</option> <option value="Dm">Dm</option> <option value="Eb">Eb</option> <option value="Ebm">Ebm</option>
              <option value="E">E</option> <option value="Em">Em</option> <option value="F">F</option> <option value="Fm">Fm</option>
              <option value="Gb">Gb</option> <option value="Gbm">Gbm</option> <option value="G">G</option> <option value="Gm">Gm</option>
              <option value="Ab">Ab</option> <option value="Abm">Abm</option> <option value="A">A</option> <option value="Am">Am</option>
              <option value="Bb">Bb</option> <option value="Bbm">Bbm</option> <option value="B">B</option> <option value="Bm">Bm</option>
            </select>
        </div>
        <div id="user-songs-section" class="controls">
            <label for="user-progression-select">Your Saved Songs:</label>
            <select id="user-progression-select" aria-label="Select your saved chord progression">
                <option value="">-- Select a saved song --</option>
            </select>
            <button id="delete-user-song-button" class="danger">Delete Selected Song</button>
        </div>

        <div id="measures"></div>

        <div class="controls">
            <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
            <button onclick="removeMeasure()" aria-label="Remove measure">Remove Last Measure</button>
            <button id="save-progression-button" class="secondary" aria-label="Save current progression">Save Current Progression</button>
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.5" aria-label="Chord volume">
        </div>
        <div class="control-group">
              <label for="reverb-dial">Reverb</label>
              <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
              <span id="reverb-dial-value">20</span>%
         </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <div class="fretboards-grid"></div>
</div>

    <script>
// Utility Functions
function log(message) {
    console.log(`[Bebop Blueprint Debug] ${message}`);
}

function updateLoadingStatus(message, isVisible = true) {
    let indicator = document.getElementById('loading-indicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'loading-indicator';
        document.body.appendChild(indicator);
    }
    indicator.textContent = message;
    indicator.style.display = isVisible ? 'block' : 'none';
}

// Musical Constants (ensure 'progressions' is defined with descriptions as provided by user)
const progressions = {
    "I V7": { defaultKey: "C", progression: ["Imaj7", "V7"], description: "A classic two-chord progression often used in jazz standards for a simple, elegant harmonic resolution." },
    "jazz_blues": { defaultKey: "Bb", progression: ["I7", "IV7", "I7", "I7", "IV7", "IV7", "I7", "VI7", "iim7", "V7", "I7", "V7"], description: "A swinging 12-bar blues with jazzy substitutions, perfect for improvisation and soulful melodies." },
    "minor_blues": { defaultKey: "Am", progression: ["im7", "ivm7", "im7", "im7", "ivm7", "ivm7", "im7", "im7", "V7", "V7", "im7", "V7"], description: "A moody minor blues progression with a melancholic vibe, ideal for expressive solos." },
    "rhythm_changes": { defaultKey: "Bb", progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "Imaj7", "IV7", "Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "V7"], description: "A fast-paced, iconic jazz structure based on Gershwin's 'I Got Rhythm,' great for bebop." },
    "2_5_1": { defaultKey: "C", progression: ["iim7", "V7", "Imaj7", "Imaj7"], description: "The quintessential jazz turnaround, providing a smooth and satisfying resolution." },
    "6_2_5_1": { defaultKey: "C", progression: ["vim7", "iim7", "V7", "Imaj7", "Imaj7"], description: "An extended version of the 2-5-1, starting on the vi minor for a richer harmonic journey." },
    "minor_2_5_1": { defaultKey: "Am", progression: ["iim7b5", "V7b9", "im7", "im7"], description: "A dramatic minor key progression, often used for intense and emotional resolutions." },
    "dark_eyes": { defaultKey: "Dm", progression: ["V7", "V7", "im7", "im7", "V7", "V7", "VI6", "VI6", "ivm6", "ivm6", "im7", "im7", "V7", "V7", "im7", "im7"], description: "A passionate, Gypsy jazz-inspired progression with a fiery, Eastern European flair." },
    "ill_see_you_in_my_dreams": { defaultKey: "F", progression: ["IV6", "IV6", "ivm6", "ivm6", "Imaj7", "VII7", "Imaj7", "Imaj7", "VI7", "VI7", "VI7", "VI7", "II7", "II7", "iim7", "V7", "Imaj7"], description: "A dreamy, nostalgic progression from the 1920s, evoking romance and whimsy." },
    "rose_room": { defaultKey: "Ab", progression: ["II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "V7", "V7", "II7", "V7", "I6", "I7", "IV6", "ivm7", "bVII7", "I6", "VI7", "IV7", "V7", "I6", "VI7"], description: "A sophisticated swing tune with lush chords, perfect for a classy jazz vibe." },
    "black_orpheus": { defaultKey: "Am", progression: ["im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7", "bIIImaj7", "bVImaj7", "iim7b5", "V7b9", "im7", "iim7b5", "V7b9", "im7", "ivm7", "VII7"], description: "A bossa nova classic with a haunting minor key, inspired by Brazilian rhythms." },
    "all_the_things_you_are": { defaultKey: "Ab", progression: ["vim7", "iim7", "V7", "Imaj7", "IVmaj7", "iiim7", "VI7", "IImaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "V7", "Imaj7", "iim7", "vm7", "I7", "IVmaj7", "Imaj7"], description: "A harmonically complex standard with shifting keys, beloved in jazz for its beauty." },
    "all_of_me": { defaultKey: "C", progression: ["Imaj7", "III7", "VI7", "iim7", "III7", "vim7", "II7", "iim7", "V7", "Imaj7", "III7", "VI7", "iim7", "IVmaj7", "ivm7", "Imaj7", "V7"], description: "A cheerful, upbeat standard with a catchy progression, great for vocal jazz." },
    "stella_by_starlight": { defaultKey: "Bb", progression: ["iim7b5", "V7b9", "Imaj7", "IV7", "vm7", "I7", "IVmaj7", "bVIImaj7", "biiim7b5", "VI7b9", "iim7", "V7", "Imaj7", "IV7", "IVmaj7", "V7"], description: "A lush, cinematic progression with a romantic and introspective feel." },
    "autumn_leaves": { defaultKey: "Gm", progression: ["iim7b5", "V7", "imaj7", "IVmaj7", "viim7b5", "III7", "vim7", "vim7"], description: "A melancholic jazz standard evoking falling leaves and wistful nostalgia." },
    "summertime": { defaultKey: "Am", progression: ["im7", "V7", "im7", "V7", "im7", "V7", "im7", "V7", "ivm7", "im7", "V7", "im7", "ivm7", "im7", "V7", "im7"], description: "A sultry, soulful progression from Gershwin's opera, perfect for laid-back grooves." },
    "girl_from_ipanema": { defaultKey: "F", progression: ["Imaj7", "II7", "iim7", "V7", "Imaj7", "II7", "iim7", "V7", "Imaj7", "bII7", "#IVm7b5", "VII7", "iiim7", "VI7", "iim7", "V7"], description: "A breezy bossa nova tune with a sunny, beachy vibe, iconic in jazz." },
    "coltrane_changes": { defaultKey: "C", progression: ["Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7", "Imaj7", "bIII7", "bVImaj7", "VII7", "IIImaj7", "V7"], description: "A challenging, innovative progression from John Coltrane, with rapid key shifts." },
    "bird_blues": { defaultKey: "F", progression: ["I7", "IV7", "I7", "vim7", "iim7", "V7", "IV7", "ivm7", "I7", "vim7", "iim7", "V7"], description: "A bebop blues progression inspired by Charlie Parker, full of energy and drive." },
    "just_friends": { defaultKey: "G", progression: ["Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "iim7", "V7", "Imaj7", "VI7", "iim7", "V7", "Imaj7", "VI7"], description: "A lively, upbeat standard with a playful harmonic structure, great for swing." },
    "blue_bossa": { defaultKey: "Cm", progression: ["im7", "im7", "bVII7", "bVII7", "im7", "im7", "ivm7", "bVII7", "im7", "V7", "im7", "im7"], description: "A cool, Latin-jazz progression with a relaxed yet groovy bossa nova feel." },
    "on_green_dolphin_street": { defaultKey: "C", progression: ["Imaj7", "im7", "Imaj7", "im7", "bIImaj7", "Imaj7", "bIImaj7", "Imaj7", "iim7", "V7"], description: "A modal, cinematic progression with a mysterious and captivating atmosphere." },
    "solar": { defaultKey: "Cm", progression: ["imaj7", "iim7b5", "V7alt", "imaj7", "bVImaj7", "bIIImaj7", "bVII7", "bVII7", "imaj7", "imaj7"], description: "A contemplative, Miles Davis original with a flowing, introspective harmonic line." },
    "misty": { defaultKey: "Eb", progression: ["Imaj7", "vm7", "I7", "IVmaj7", "ivm7", "Imaj7", "iim7", "V7", "iiim7", "VI7", "iim7", "V7"], description: "A tender, romantic ballad progression, evoking misty-eyed sentimentality." },
    "days_of_wine_and_roses": { defaultKey: "F", progression: ["Imaj7", "vim7", "iim7", "V7", "Imaj7", "vim7", "iim7", "V7", "IVmaj7", "vm7", "I7", "IVmaj7", "iiim7", "VI7", "iim7", "V7"], description: "A bittersweet, elegant progression with a waltzing, reflective quality." },
    "cherokee": { defaultKey: "Bb", progression: ["Imaj7", "Imaj7", "iim7", "V7", "Imaj7", "Imaj7", "iim7", "V7", "bVImaj7", "bVImaj7", "V7", "V7", "Imaj7", "Imaj7", "iim7", "V7"], description: "A high-energy bebop standard with a fast-moving, adventurous harmonic structure." },
    "caravan": { defaultKey: "Fm", progression: ["im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "im7", "IV7b5", "bVII7", "bVII7", "Imaj7", "Imaj7", "V7", "V7", "im7", "im7"], description: "An exotic, Latin-tinged progression with a hypnotic, caravan-like rhythm." },
    "nows_the_time": { defaultKey: "F", progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "V7", "IV7", "I7", "I7"], description: "A gritty, straightforward blues progression by Charlie Parker, full of soul." },
    "tenor_madness": { defaultKey: "Bb", progression: ["I7", "I7", "I7", "I7", "IV7", "IV7", "I7", "I7", "iim7", "V7", "I7", "I7"], description: "A hard-swinging blues progression, ideal for fiery tenor sax battles." }
};

const NOTES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
const NOTES_CHROMATIC = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
const ALL_NOTES_FOR_SAMPLES = ['a', 'as', 'b', 'c', 'cs', 'd', 'ds', 'e', 'f', 'fs', 'g', 'gs'];
const OCTAVES_FOR_SAMPLES = [2, 3, 4, 5]; // Samples available
const PLAYBACK_OCTAVES = [3, 4]; // Octaves to use for chord playback
const FILE_FORMAT = 'wav';

function getSampleFileName(note, octave) { return `${note}${octave}.${FILE_FORMAT}`; }
const SAMPLE_NOTE_MAP = {
    'C': 'c',
    'Db': 'cs', 'C#': 'cs', // Keep C# mapping for potential other uses
    'D': 'd',
    'Eb': 'ds', 'D#': 'ds',
    'E': 'e',
    'F': 'f',
    'Gb': 'fs', 'F#': 'fs', // Explicitly map F# used in the constant
    'G': 'g',
    'Ab': 'gs', 'G#': 'gs', // Explicitly map G# used in the constant
    'A': 'a',
    'Bb': 'as', 'A#': 'as', // Explicitly map A# used in the constant
    'B': 'b',
    // Add mappings for the 's' versions if your constant uses them directly
    'CS': 'cs', // Map Cs (from constant) to cs (sample)
    'DS': 'ds', // Map Ds to ds
    'FS': 'fs', // Map Fs to fs
    'GS': 'gs', // Map Gs to gs
    'AS': 'as'  // Map As to as
};

function standardizeNoteName(note) {
    if (!note) return ''; // Handle null or empty input

    let standardized = note.toUpperCase().trim(); // Convert to uppercase and trim whitespace

    // Replace common symbols
    standardized = standardized.replace('♭', 'b').replace('♯', '#');

    // Define the mapping from sharps to flats
    const sharpToFlatMap = {
        'C#': 'Db',
        'D#': 'Eb',
        'F#': 'Gb',
        'G#': 'Ab',
        'A#': 'Bb'
        // B# would be C, E# would be F - handle these as edge cases if needed, but NOTES array uses flats primarily
    };

    // Convert sharps to flats using the map
    if (standardized.includes('#')) {
        return sharpToFlatMap[standardized] || standardized; // Return the flat equivalent or original if not in map (e.g., G# -> Ab)
    }

    // For notes without sharps/flats or already using flats,
    // ensure they match the canonical names in the NOTES array (e.g., handles "FLAT" text, case issues)
    const found = NOTES.find(n => n.toUpperCase() === standardized.toUpperCase());

    // Return the canonical name found in NOTES, or the processed input if not found (handles potential errors)
    return found || standardized;
}
        
const FRETBOARD_NOTES_OCTAVES = {
  // String 1 (High E) - Visually Bottom
  string1: ['E4', 'F4', 'Fs4', 'G4', 'Gs4', 'A4', 'As4', 'B4', 'C5', 'Cs5', 'D5', 'Ds5', 'E5'],
  // String 2 (B)
  string2: ['B3', 'C4', 'Cs4', 'D4', 'Ds4', 'E4', 'F4', 'Fs4', 'G4', 'Gs4', 'A4', 'As4', 'B4'],
  // String 3 (G)
  string3: ['G3', 'Gs3', 'A3', 'As3', 'B3', 'C4', 'Cs4', 'D4', 'Ds4', 'E4', 'F4', 'Fs4', 'G4'],
  // String 4 (D)
  string4: ['D3', 'Ds3', 'E3', 'F3', 'Fs3', 'G3', 'Gs3', 'A3', 'As3', 'B3', 'C4', 'Cs4', 'D4'],
  // String 5 (A)
  string5: ['A2', 'As2', 'B2', 'C3', 'Cs3', 'D3', 'Ds3', 'E3', 'F3', 'Fs3', 'G3', 'Gs3', 'A3'],
  // String 6 (Low E) - Visually Top
  string6: ['E2', 'F2', 'Fs2', 'G2', 'Gs2', 'A2', 'As2', 'B2', 'C3', 'Cs3', 'D3', 'Ds3', 'E3']
};
        
const SCALES = {
    major: [0,2,4,5,7,9,11], minor: [0,2,3,5,7,8,10], harmonicMinor: [0,2,3,5,7,8,11], melodicMinor: [0,2,3,5,7,9,11],
    dorian: [0,2,3,5,7,9,10], phrygian: [0,1,3,5,7,8,10], lydian: [0,2,4,6,7,9,11], mixolydian: [0,2,4,5,7,9,10], locrian: [0,1,3,5,6,8,10],
    bebopDominant: [0,2,4,5,7,9,10,11], bebopMajor: [0,2,4,5,7,8,9,11], bebopDorian: [0,2,3,4,5,7,9,10], bebopPhrygian: [0,1,2,3,5,7,8,10],
    altered: [0,1,3,4,6,8,10], lydianDominant: [0,2,4,6,7,9,10],
    diminishedWH: [0,2,3,5,6,8,9,11], diminishedHW: [0,1,3,4,6,7,9,10], wholeTone: [0,2,4,6,8,10],
    pentatonicMajor: [0,2,4,7,9], pentatonicMinor: [0,3,5,7,10], blues: [0,3,5,6,7,10], majorBlues: [0,2,3,4,7,9],
    harmonicMajor: [0,2,4,5,7,8,11], doubleHarmonic: [0,1,4,5,7,8,11],
    enigmatic:[0,1,4,6,8,10,11], persian:[0,1,4,5,6,8,11], arabic:[0,2,4,5,6,8,10], japanese:[0,2,5,7,8], egyptian:[0,2,5,7,10]
};
const TUNINGS = {
    standard: ['E','B','G','D','A','E'], dropD: ['E','B','G','D','A','D'], openG: ['D','B','G','D','G','D'],
    DADGAD: ['D','A','G','D','A','D'], openE: ['E','B','E','Ab','B','E'] // Ab for G#
};
Object.keys(TUNINGS).forEach(key => TUNINGS[key].reverse()); // High E string at index 0

const CHORD_INTERVALS = {
    'maj':[0,4,7],'min':[0,3,7],'dim':[0,3,6],'aug':[0,4,8],'sus4':[0,5,7],'sus2':[0,2,7],
    'maj7':[0,4,7,11],'dom7':[0,4,7,10],'min7':[0,3,7,10],'min7b5':[0,3,6,10],'dim7':[0,3,6,9],
    'maj6':[0,4,7,9],'min6':[0,3,7,9],'dom7b9':[0,4,7,10,13],'dom7#9':[0,4,7,10,15],'dom7b5':[0,4,6,10],
    'alt':[0,4,6,10,13],'dom7sus':[0,5,7,10],'maj9':[0,4,7,11,14],'dom9':[0,4,7,10,14],'min9':[0,3,7,10,14],
    'imaj7':[0,3,7,11],'unknown':[0,4,7,10]
};
const drumSoundSets = [ { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" }, /* ... */ ]; // Keep your drum sets

// State Management
const AppState = {
    isPlaying: false, currentBeat: 0, currentMeasure: 0, tempo: 120, audioInitialized: false,
    intervalId: null, lastTapTime: 0, tapTempoTimestamps: [],
    guideTonesActive: false, loopingActive: false, loopStartMeasure: -1, loopEndMeasure: -1,
    previousChordRootIndex: undefined, // For playChord voice leading
    listeners: [], // For future state management patterns
    updateState(newState){ Object.assign(this,newState); this.notifyListeners(); },
    addListener(cb){ this.listeners.push(cb); }, notifyListeners(){ this.listeners.forEach(cb=>cb(this));}
};
let currentFunctionalProgression = [];
let currentProgressionName = "";
let currentDrumSetIndex = 0;

// UI Management
const UI = {
    elements: {},
    init() {
        this.elements = {
            chordFretboard:document.getElementById('chord-fretboard'), measures:document.getElementById('measures'),
            tempoDisplay:document.getElementById('tempo-display'), startStopButton:document.getElementById('start-stop'),
            progressionSelect:document.getElementById('progression-select'), keySelect:document.getElementById('keySelect'),
            scaleDisplay:document.getElementById('scale-display'), chordTuning:document.getElementById('chord-tuning'),
            timeSignature:document.getElementById('time-signature'), soundType:document.getElementById('sound-type'),
            metronomeVolume:document.getElementById('metronome-volume'), tempo:document.getElementById('tempo'),
            tapTempo:document.getElementById('tap-tempo'), chordFretboardVolume:document.getElementById('chord-fretboard-volume'),
            chordVolume:document.getElementById('chord-volume'), chordsEnabled:document.getElementById('chordsEnabled'),
            fretboardsGrid:document.querySelector('.fretboards-grid'), darkModeToggle:document.getElementById('dark-mode-toggle'),
            accentIntensity:document.getElementById('accent-intensity'), drumSetToggleBtn:document.getElementById('drumSetToggleBtn'),
            reverbDial:document.getElementById('reverb-dial'), reverbDialValue:document.getElementById('reverb-dial-value'),
            currentSongTitle:document.getElementById('current-song-title'), currentSongDescription:document.getElementById('current-song-description'),
            userProgressionSelect:document.getElementById('user-progression-select'), saveProgressionButton:document.getElementById('save-progression-button'),
            deleteUserSongButton:document.getElementById('delete-user-song-button'),
            guideTonesToggle:document.getElementById('guide-tones-toggle'), loopSelectedToggle:document.getElementById('loop-selected-toggle')
        };
        Object.entries(this.elements).forEach(([k,el])=> { if(!el && k!=='reverbDialValue') console.warn(`Missing DOM: ${k}`);});
        log("UI elements cached.");
    }
};

// Audio Management (mostly unchanged from previous, ensure paths are correct)
const AudioContextManager = { /* ... copy your existing AudioContextManager ... */ 
    context: null, soundBuffers: {}, pianoSampleBuffers: {}, reverbNode: null, samplesLoaded: false, reverbAmount: 0.2, currentChordGain: null,
    initialize: async function() { /* ... */ if (this.context && this.context.state !== 'closed') return this.context; try { this.context = new (window.AudioContext || window.webkitAudioContext)(); log("AudioContext created/resumed."); await this.loadSounds(); await this.loadPianoSamples(); await this.setupReverb(); if (this.context.state === 'suspended') { await this.context.resume(); log("AudioContext resumed from suspended state."); } AppState.audioInitialized = true; log("AudioContextManager initialized."); } catch (error) { console.error("Error initializing AudioContextManager:", error); alert("Failed to initialize audio."); throw error; } return this.context; },
    ensureAudioContext: async function() { if (!this.context || this.context.state === 'suspended') { return await this.initialize(); } return this.context; },
    loadSounds: async function() { const sf={'click':'Click.wav','hihat':'HiHat.wav','kick':'Kick.wav','snare':'Snare.wav','woodblock':'woodblock.wav'}; for(let [t,f] of Object.entries(sf)){try{const r=await fetch(`./${f}`);if(!r.ok)throw new Error(`${r.status} for ${f}`);const ab=await r.arrayBuffer();this.soundBuffers[t]=await this.context.decodeAudioData(ab);log(`Loaded ${t} from ${f}`);}catch(e){console.error(`Failed ${f}:`,e);this.soundBuffers[t]=await this.createDrumSound(t);log(`Fallback for ${t}`);}} updateLoadingStatus("Drum sounds loaded/synthesized",true);},
    createDrumSound: async function(t) {const sr=this.context.sampleRate; const d=t==='hihat'?0.05:0.2;const b=this.context.createBuffer(1,sr*d,sr);const data=b.getChannelData(0); switch(t){case 'click':for(let i=0;i<data.length;i++)data[i]=Math.sin(i*0.05)*Math.exp(-i*0.01);break; case 'hihat':for(let i=0;i<data.length;i++)data[i]=(Math.random()*2-1)*Math.exp(-i/(sr*0.01));break; case 'kick':for(let i=0;i<data.length;i++){const x=i/sr;data[i]=Math.sin(2*Math.PI*100*x)*Math.exp(-x*10)*2;}break; case 'snare':for(let i=0;i<data.length;i++){const x=i/sr;data[i]=((Math.random()*2-1)+Math.sin(2*Math.PI*200*x))*Math.exp(-x*10)*2;}break; case 'woodblock':for(let i=0;i<data.length;i++){const x=i/sr;data[i]=Math.sin(2*Math.PI*800*x)*Math.exp(-x*20);}break;} return b;},
    loadPianoSamples: async function() { this.pianoSampleBuffers={}; let lc=0; for(const n of ALL_NOTES_FOR_SAMPLES){for(const o of OCTAVES_FOR_SAMPLES){const fn=getSampleFileName(n,o);const k=`${n}${o}`;try{const r=await fetch(fn);if(!r.ok)throw new Error(`${r.status} for ${fn}`);const ab=await r.arrayBuffer();const aub=await this.context.decodeAudioData(ab);this.pianoSampleBuffers[k]=aub;lc++;}catch(e){console.error(`Failed piano sample: ${fn}`,e);}}} if(lc>0){this.samplesLoaded=true;log(`Loaded ${lc} piano samples.`);}else{console.warn("No piano samples loaded.");this.samplesLoaded=false;} updateLoadingStatus("Piano samples processing complete.",true); },
    setupReverb: async function() { if(!this.context)return; if(!this.reverbNode){this.reverbNode=this.context.createConvolver();const sr=this.context.sampleRate;const l=sr*2.5;const imp=this.context.createBuffer(2,l,sr);for(let ch=0;ch<2;ch++){const cd=imp.getChannelData(ch);for(let i=0;i<l;i++)cd[i]=(Math.random()*2-1)*Math.pow(1-i/l,2.5);}this.reverbNode.buffer=imp;log("Reverb node created.");}}
};
async function ensureAudioInitializedUserInteraction() { if(!AppState.audioInitialized){try{await AudioContextManager.initialize();log("Audio context initialized on user interaction.");}catch(e){console.error('Audio init failed on user interaction:',e);}} }

// CHORD PARSING & MUSIC THEORY (Keep your improved versions)
function getStandardQuality(rawQuality) { /* ... */ if (!rawQuality) return 'maj7'; const q = rawQuality.toLowerCase().trim(); if (q === 'maj7' || q === 'ma7' || q === 'Δ' || q === 'maj') return 'maj7'; if (q === '7' || q === 'dom7' || q === 'dom') return 'dom7'; if (q === 'm7' || q === 'min7' || q === 'mi7' || q === 'min' || q === 'm') return 'min7'; if (q === 'm7b5' || q === 'min7b5' || q === 'ø' || q === 'mi7b5') return 'min7b5'; if (q === 'dim7' || q === '°7') return 'dim7'; if (q === 'maj6' || q === 'ma6' || (q === '6' && !rawQuality.startsWith('m') && !rawQuality.startsWith('M'))) return 'maj6'; if (q === 'm6' || q === 'min6' || q === 'mi6') return 'min6'; if (q === 'dim' || q === '°') return 'dim'; if (q === 'aug' || q === '+') return 'aug'; if (q === 'sus4' || q === 'sus') return 'sus4'; if (q === '7b9' || q === 'dom7b9') return 'dom7b9'; if (q === '7#9' || q === 'dom7#9') return 'dom7#9'; if (q === '7b5' || q === 'dom7b5') return 'dom7b5'; if (q === 'alt' || q === '7alt') return 'alt'; if (q === '7sus' || q === '7sus4') return 'dom7sus'; if (q === 'imaj7' || q === 'm(maj7)' || q === 'minmaj7') return 'imaj7'; if (CHORD_INTERVALS[rawQuality]) return rawQuality; console.warn(`getStandardQuality: Unstandardized "${rawQuality}". Defaulting.`); return 'maj7';}
function parseChord(chordString) { /* ... */ if(typeof chordString !== 'string' || !chordString.trim()) return null; chordString = chordString.trim(); const m = chordString.match(/^([A-G][#b]?)(.*)$/); if(!m) return null; const r = standardizeNoteName(m[1]); const q = m[2].trim(); return { root: r, quality: getStandardQuality(q) }; }
function parseRomanNumeralToAbsoluteChord(romanString, key) { /* ... (your robust version) ... */ const kim = key.includes('m'); const nkr = standardizeNoteName(key.replace('m','')); const kri = NOTES_CHROMATIC.indexOf(nkr); if(kri===-1)return{root:'C',quality:'maj7',originalRoman:romanString}; const rm = romanString.match(/^(b|#)?([IViv]+)(.*)$/); if(!rm){const pa=parseChord(romanString);if(pa&&pa.root){if(!CHORD_INTERVALS[pa.quality])pa.quality='maj7';return{...pa,originalRoman:romanString};}return{root:nkr,quality:'maj7',originalRoman:romanString};} const acc=rm[1];const num=rm[2];let qs=rm[3].trim(); const majSI={'I':0,'II':2,'III':4,'IV':5,'V':7,'VI':9,'VII':11}; const minSI={'i':0,'ii':2,'III':3,'iv':5,'v':7,'VI':8,'VII':10}; let di; const iucn=num===num.toUpperCase(); if(kim){di=minSI[num.toLowerCase()];if(iucn&&num==='V')di=majSI[num];else if(iucn&&num==='IV')di=majSI[num];}else{di=majSI[num.toUpperCase()];} if(di===undefined)return{root:nkr,quality:'maj7',originalRoman:romanString}; let cri=(kri+di)%12;if(acc==='b')cri=(cri-1+12)%12;else if(acc==='#')cri=(cri+1)%12; const cr=NOTES_CHROMATIC[cri]; let fq; if(qs){fq=getStandardQuality(qs);if(qs==="6")fq=iucn?"maj6":"min6";else if(qs==="m6")fq="min6";}else{if(num.toLowerCase()==='v')fq='dom7';else if(num.toLowerCase()==='vii'&&!iucn)fq='min7b5';else if(iucn)fq='maj7';else fq='min7';} if(!CHORD_INTERVALS[fq]){console.warn(`Quality "${fq}" for ${romanString} in ${key} not in CHORD_INTERVALS. Defaulting.`);fq=iucn?'maj7':'min7';} return{root:cr,quality:fq,originalRoman:romanString};}
function getChordNotes(root, quality) { /* ... */ let i=CHORD_INTERVALS[quality];if(!i){console.warn(`Quality "${quality}" for ${root} not found. Defaulting.`);i=CHORD_INTERVALS['dom7'];} const rn=standardizeNoteName(root);const ri=NOTES.indexOf(rn);if(ri===-1){console.error(`Invalid root for getChordNotes: ${root}`);return[rn];} return i.map(iv=>(NOTES[(ri+iv)%12]));}
function suggestScaleForQuality(quality) { /* ... */ const sm={'maj7':'major','maj':'major','maj6':'major','dom7':'mixolydian','dom9':'mixolydian','dom7b9':'diminishedWH','dom7#9':'altered','alt':'altered','dom7sus':'mixolydian','min7':'dorian','min':'dorian','min9':'dorian','min6':'dorian','min7b5':'locrian','dim7':'diminishedWH','imaj7':'melodicMinor'}; return sm[quality]||'major';}

// DOM Utilities
function createKeyOptions(selKey='C'){return NOTES.map(n=>`<option value="${n}"${n===standardizeNoteName(selKey)?' selected':''}>${n}</option>`).join('');}
function createQualityOptions(selQ='maj7'){const Qs=[{v:'maj7',l:'Maj7'},{v:'dom7',l:'7 (Dom)'},{v:'min7',l:'min7'},{v:'min7b5',l:'min7♭5'},{v:'dim7',l:'dim7'},{v:'maj6',l:'Maj6'},{v:'min6',l:'min6'},{v:'dom7b9',l:'7♭9'},{v:'dom7#9',l:'7♯9'},{v:'dom7b5',l:'7♭5'},{v:'alt',l:'Altered'},{v:'dom7sus',l:'7sus4'},{v:'imaj7',l:'m(maj7)'},{v:'maj',l:'Maj(triad)'},{v:'min',l:'min(triad)'},{v:'dim',l:'dim(triad)'},{v:'aug',l:'aug(triad)'},{v:'sus4',l:'sus4(triad)'}]; return Qs.map(q=>`<option value="${q.v}"${q.v===selQ?' selected':''}>${q.l}</option>`).join('');}
function createScaleOptions(selS='major'){return Object.keys(SCALES).map(sn=>{const dn=sn.replace(/([A-Z]+)/g,' $1').replace(/([A-Z][a-z])/g,' $1').split(' ').map(s=>s.charAt(0).toUpperCase()+s.substring(1)).join(' ');return`<option value="${sn}"${sn===selS?' selected':''}>${dn}</option>`;}).join('');}

// Audio Playback
function standardizeNoteNameForSamples(note){const sn=standardizeNoteName(note);return SAMPLE_NOTE_MAP[sn]||sn.toLowerCase();}
function playNote(noteNameWithOctave, volume=0.5, duration=500) { // Default volume reduced
    if (!AudioContextManager.context || !AudioContextManager.samplesLoaded || !noteNameWithOctave) return;
    const m=noteNameWithOctave.match(/^([A-G][b#]?)(\d)$/i); if(!m){console.warn(`Invalid note format: ${noteNameWithOctave}`);return;}
    let [,pc,os]=m; const spc=standardizeNoteNameForSamples(pc);
    const o=Math.max(OCTAVES_FOR_SAMPLES[0],Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length-1],parseInt(os)));
    const sk=`${spc}${o}`; const b=AudioContextManager.pianoSampleBuffers[sk];
    if(!b){console.warn(`No sample for ${sk} (orig: ${noteNameWithOctave})`);return;}
    try{const s=AudioContextManager.context.createBufferSource();s.buffer=b;const gn=AudioContextManager.context.createGain();gn.gain.setValueAtTime(volume,AudioContextManager.context.currentTime);s.connect(gn);gn.connect(AudioContextManager.context.destination);s.start(AudioContextManager.context.currentTime);s.stop(AudioContextManager.context.currentTime+duration/1000);}catch(e){console.error('Error playing note:',e);}
}

async function playChord(root, quality, startTime, duration) {
    if (!UI.elements.chordsEnabled.classList.contains('active') || !AudioContextManager.samplesLoaded) return;
    await AudioContextManager.ensureAudioContext();

    const baseNotes = getChordNotes(root, quality); // e.g., ['C', 'E', 'G', 'B']
    if (!baseNotes || baseNotes.length === 0) return;

    const overallVolume = parseFloat(UI.elements.chordVolume.value) * 0.7;
    if (overallVolume <= 0) return;

    if (AudioContextManager.currentChordGain) {
        AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, startTime);
        AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
    }
    const mainGain = AudioContextManager.context.createGain();
    mainGain.gain.setValueAtTime(0, startTime);
    mainGain.gain.linearRampToValueAtTime(overallVolume, startTime + 0.02);
    mainGain.connect(AudioContextManager.context.destination);
    AudioContextManager.currentChordGain = mainGain;

    if (AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0) {
        const reverbDryWet = AudioContextManager.context.createGain();
        reverbDryWet.gain.value = AudioContextManager.reverbAmount;
        mainGain.connect(reverbDryWet);
        reverbDryWet.connect(AudioContextManager.reverbNode);
        // Reverb node should already be connected to destination elsewhere or connect it here if not
        // AudioContextManager.reverbNode.connect(AudioContextManager.context.destination); // Ensure output
    }

    // Create inversions - Voicing limited to PLAYBACK_OCTAVES (2 and 3)
    let voicing = [...baseNotes];
    const inversion = Math.floor(Math.random() * voicing.length); // 0 to length-1
    for (let i = 0; i < inversion; i++) {
        voicing.push(voicing.shift()); // Rotate notes for inversion
    }

    // Assign octaves within PLAYBACK_OCTAVES trying to keep it somewhat low
    const assignedNotesWithOctaves = voicing.map((noteName, index) => {
        let octave = PLAYBACK_OCTAVES[0]; // Start with lowest allowed octave (e.g., 2)
        // If it's not the root and the note is "lower" alphabetically than the root, might push to next octave
        if (index > 0 && NOTES.indexOf(noteName) < NOTES.indexOf(voicing[0])) {
            octave = PLAYBACK_OCTAVES[1] || PLAYBACK_OCTAVES[0]; // Use higher of allowed, or just lowest if only one
        }
        // Simple spread for remaining notes if more than 2 playback octaves allowed
        if (PLAYBACK_OCTAVES.length > 1 && index > 1) {
             octave = PLAYBACK_OCTAVES[index % PLAYBACK_OCTAVES.length];
        }
        // Ensure octave is within sample range, fallback if not
        if (!OCTAVES_FOR_SAMPLES.includes(octave)) {
            octave = OCTAVES_FOR_SAMPLES.find(o => o >= PLAYBACK_OCTAVES[0]) || OCTAVES_FOR_SAMPLES[0];
        }
        return { name: noteName, octave: octave };
    });


    assignedNotesWithOctaves.forEach(noteObj => {
        const samplePitchClass = standardizeNoteNameForSamples(noteObj.name);
        const sampleKey = `${samplePitchClass}${noteObj.octave}`;
        const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

        if (!buffer) {
            console.warn(`Chord Playback: No sample for ${sampleKey}`);
            return;
        }
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        const noteSpecificGain = AudioContextManager.context.createGain();
        noteSpecificGain.gain.value = 0.8 + Math.random() * 0.2; // Velocity variation
        source.connect(noteSpecificGain);
        noteSpecificGain.connect(mainGain);

        const timeVariation = Math.random() * 0.03; // Strumming
        source.start(startTime + timeVariation);
        source.stop(startTime + duration + timeVariation);
    });
}


async function playMetronomeSound(baseVol) { /* ... (Keep your existing metronome sound logic) ... */ if (!AudioContextManager.context) return; const mov = parseFloat(UI.elements.metronomeVolume.value); const cv = baseVol * mov; if (cv <= 0) return; const st = UI.elements.soundType.value; const be = document.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`); if (!be) return; const sktp = be.dataset.sound.split(','); const iab = parseFloat(be.dataset.baseVolume) >= 1; const ab = parseFloat(UI.elements.accentIntensity?.value || 1.0); let fvfts = cv; if (iab && (sktp.includes('kick') || sktp.includes('snare') || st === 'click' || st === 'woodblock')) { fvfts = Math.min(cv * ab, 1.0); } for (let sk of sktp) { sk = sk.trim(); if (sk === 'silent') continue; let btp; let esk = sk; if (st === 'drums') { const cs = drumSoundSets[currentDrumSetIndex]; let sfn; switch(sk){case 'kick':sfn=cs.kick;break; case 'snare':sfn=cs.snare;break; case 'hihat':sfn=cs.hihat;break; default:esk='click';sfn=null;} if(sfn){try{if(!AudioContextManager.soundBuffers[sfn]){const r=await fetch(`./${sfn}`);if(!r.ok)throw new Error(`${r.status} for ${sfn}`);const aby=await r.arrayBuffer();AudioContextManager.soundBuffers[sfn]=await AudioContextManager.context.decodeAudioData(aby);}btp=AudioContextManager.soundBuffers[sfn];}catch(e){console.error(`Failed drum sample ${sfn}:`,e);btp=AudioContextManager.soundBuffers[sk]||AudioContextManager.soundBuffers['click'];}}else{btp=AudioContextManager.soundBuffers[esk]||AudioContextManager.soundBuffers['click'];}}else{esk=st;btp=AudioContextManager.soundBuffers[st]||AudioContextManager.soundBuffers['click'];} if(!btp)continue;const src=AudioContextManager.context.createBufferSource();src.buffer=btp;const gn=AudioContextManager.context.createGain();let afv=fvfts;if(st==='drums'){if(esk==='hihat'&&sktp.length>1)afv*=0.6;else if(esk==='kick')afv*=1.0;else if(esk==='snare')afv*=0.9;}gn.gain.setValueAtTime(Math.min(afv,1.0),AudioContextManager.context.currentTime);src.connect(gn);gn.connect(AudioContextManager.context.destination);if(st==='drums'&&AudioContextManager.reverbNode){const rg=AudioContextManager.context.createGain();rg.gain.setValueAtTime(0.05,AudioContextManager.context.currentTime);src.connect(rg);rg.connect(AudioContextManager.reverbNode);}src.start(AudioContextManager.context.currentTime);}}
function onMetronomeInstrumentChange(selIns){UI.elements.drumSetToggleBtn.style.display=selIns==="drums"?"inline-block":"none";createBeats();}
      
// Function 1: Creates the basic structure (lines, markers, numbers)
function createFretboard(container, tuningArr) {
    if (!(container instanceof HTMLElement)) { console.error("Invalid container for createFretboard"); return; }
    if (!Array.isArray(tuningArr) || tuningArr.length === 0) { console.error("Invalid tuning array for createFretboard"); return; }

    container.innerHTML = ''; // Clear previous content
    const nf = 12; // Number of frets to display
    const ns = tuningArr.length; // Number of strings

    // --- Create Fret Lines and Numbers ---
    for (let i = 0; i <= nf; i++) { // Fret 0 (nut) to 12
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / nf) * 100}%`;
        container.appendChild(fretLine);
        if (i > 0) {
            const fretNumber = document.createElement('div');
            fretNumber.className = 'fret-number';
            fretNumber.textContent = i;
            fretNumber.style.left = `${((i - 0.5) / nf) * 100}%`;
            container.appendChild(fretNumber);
        }
    }
    const nutLine = document.createElement('div');
    nutLine.className = 'fret-line';
    nutLine.style.left = '0%'; nutLine.style.width = '4px'; nutLine.style.background = '#4A3B31';
    container.appendChild(nutLine);
    // --- End Fret Lines and Numbers ---

    // --- Create String Lines ---
    for (let i = 0; i < ns; i++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        const stringY = 100 - (i / (ns - 1)) * 100; // Corrected position
        stringLine.style.top = `${stringY}%`;
        container.appendChild(stringLine);
    }
    // --- End String Lines ---

    // --- Add Fret Markers (Dots) ---
    const markerPositions = [3, 5, 7, 9, 12];
    markerPositions.forEach(fretPos => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((fretPos - 0.5) / nf) * 100}%`;
        if (fretPos === 12) {
            const topMarker = marker.cloneNode(true);
            const bottomMarker = marker.cloneNode(true);
            const topStringIndex = Math.floor(ns / 2) - 1;
            const bottomStringIndex = Math.floor(ns / 2);
            topMarker.style.top = `${100 - ((topStringIndex + 0.5) / (ns - 1)) * 100}%`; // Corrected position
            bottomMarker.style.top = `${100 - ((bottomStringIndex - 0.5) / (ns - 1)) * 100}%`; // Corrected position
            container.appendChild(topMarker);
            container.appendChild(bottomMarker);
        } else {
            marker.style.top = '50%';
            container.appendChild(marker);
        }
    });
    // --- End Fret Markers ---
}


// Function 2: Adds/Updates the note dots based on scale/tuning
function updateFretboardNotes(fretboardContainer, rootNote, scaleName, tuningArray) {
    // --- Validation & Setup ---
    if (!(fretboardContainer instanceof HTMLElement)) { console.error('Invalid fretboardContainer'); return; }
    const standardizedRoot = standardizeNoteName(rootNote);
    if (!NOTES.includes(standardizedRoot)) { console.error(`Invalid root note: ${rootNote}`); return; }
    const scaleData = SCALES[scaleName];
    if (!scaleData) { console.error(`Invalid scale: ${scaleName}`); return; }
    const isStandardTuning = Array.isArray(tuningArray) && tuningArray.length === 6;
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) { console.error('Invalid tuning array'); return; }
    if (!isStandardTuning) {
         console.warn(`updateFretboardNotes: Tuning array length (${tuningArray.length}) doesn't match 6. Using approximate octaves for note playback.`);
    }
    // --- End Validation ---

    // *** This line belongs HERE ***
    fretboardContainer.querySelectorAll('.note').forEach(el => el.remove()); // Clear previous notes

    // --- Update Scale Display ---
    if (fretboardContainer.id === 'chord-fretboard' && UI.elements.scaleDisplay) {
        const currentMeasureEl = AppState.currentMeasure < UI.elements.measures.children.length ? UI.elements.measures.children[AppState.currentMeasure] : null;
        if (currentMeasureEl) {
            const cr = currentMeasureEl.querySelector('.chord-controls .root-note')?.value;
            const cqRaw = currentMeasureEl.querySelector('.chord-controls .chord-quality')?.value;
            const cqOpt = currentMeasureEl.querySelector(`.chord-controls .chord-quality option[value="${cqRaw}"]`);
            const cqDisp = cqOpt ? cqOpt.textContent : cqRaw;
            const srDisp = currentMeasureEl.querySelector('.scale-controls .second-key')?.value || rootNote;
            const stRaw = currentMeasureEl.querySelector('.scale-controls .scale-select')?.value || scaleName;
            const stOpt = currentMeasureEl.querySelector(`.scale-controls .scale-select option[value="${stRaw}"]`);
            const stDisp = stOpt ? stOpt.textContent : stRaw;
            UI.elements.scaleDisplay.textContent = `${srDisp} ${stDisp} over ${cr} ${cqDisp}`;
        } else {
             UI.elements.scaleDisplay.textContent = `${standardizedRoot} ${scaleName.replace(/([A-Z])/g, ' $1').trim()}`;
        }
    }
    // --- End Update Scale Display ---

    // --- Scale Note Calculation ---
    const rootIdx = NOTES.indexOf(standardizedRoot);
    const notesInScale = scaleData.map(interval => NOTES[(rootIdx + interval) % 12]);
    // --- End Scale Note Calculation ---

    const numStrings = tuningArray.length;
    const numFrets = 12;

    // *** This loop and its contents belong HERE ***
    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) {
        const openStringNote = standardizeNoteName(tuningArray[stringIndex]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);
        if (openStringNoteIndex === -1) continue;
        const stringMapKey = `string${stringIndex + 1}`;

        for (let fret = 0; fret <= numFrets; fret++) {
            const currentNoteIndex = (openStringNoteIndex + fret + 12) % 12;
            const currentNoteName = NOTES[currentNoteIndex];

            if (notesInScale.includes(currentNoteName)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNoteName;

                // Positioning
                if (fret === 0) noteElement.style.left = `1.5%`;
                else noteElement.style.left = `${((fret - 0.5) / numFrets) * 100 + 2}%`;
                const stringY = 100 - (stringIndex / (numStrings - 1)) * 100; // Corrected
                noteElement.style.top = `${stringY}%`;

                // Styling
                if (currentNoteName === standardizedRoot) noteElement.style.backgroundColor = '#BD2031';
                else { const di = notesInScale.indexOf(currentNoteName); noteElement.style.backgroundColor = (di % 2 === 0) ? '#006400' : '#4CAF50'; }

                // Data for Playback
                let noteOctaveForPlayback = `${currentNoteName}3`; // Default
                 if (isStandardTuning && FRETBOARD_NOTES_OCTAVES[stringMapKey] && fret < FRETBOARD_NOTES_OCTAVES[stringMapKey].length) {
                     noteOctaveForPlayback = FRETBOARD_NOTES_OCTAVES[stringMapKey][fret];
                 } else { // Fallback for non-standard tuning
                    let approxOctave = PLAYBACK_OCTAVES[0];
                    if (stringIndex < numStrings / 2) approxOctave = PLAYBACK_OCTAVES[1] || PLAYBACK_OCTAVES[0];
                    if (fret > 7 && approxOctave < OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1]) approxOctave++;
                    approxOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length-1], approxOctave));
                    noteOctaveForPlayback = `${currentNoteName}${approxOctave}`;
                    // Log only once per non-standard update maybe?
                 }
                noteElement.dataset.note = noteOctaveForPlayback;

                // Event Listener
                noteElement.addEventListener('click', async (e) => { e.stopPropagation(); await AudioContextManager.ensureAudioContext(); const noteToPlay = noteElement.dataset.note; const vol = fretboardContainer.id.startsWith('fretflow-fretboard') ? 0.4 : parseFloat(UI.elements.chordFretboardVolume.value); playNote(noteToPlay, vol, 500); noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)'; setTimeout(() => { noteElement.style.transform = 'translate(-50%, -50%) scale(1)'; }, 150); });

                fretboardContainer.appendChild(noteElement);
            }
        }
    }
    // *** END OF MOVED CODE ***

    // --- Guide Tones ---
    if (AppState.guideTonesActive && fretboardContainer.id === 'chord-fretboard') {
        highlightGuideTones();
    }
    // --- End Guide Tones ---
} // --- END OF updateFretboardNotes FUNCTION ---
    
    // Advance beat and measure
    const totalBeatsInDisplay = beatsUI.length;
    AppState.currentBeat = (AppState.currentBeat + 1) % totalBeatsInDisplay;
    
    if (AppState.currentBeat === 0) { // End of displayed beats for the measure
        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            AppState.currentMeasure++;
            if (AppState.currentMeasure > AppState.loopEndMeasure) {
                AppState.currentMeasure = AppState.loopStartMeasure; // Loop back
            }
        } else if (measures.length > 0) {
            AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
        }
    }


async function startPlayback() {
    try {
        await AudioContextManager.ensureAudioContext(); // Ensure audio is ready
        if (AppState.isPlaying) return; // Don't start if already playing

        const measures = UI.elements.measures.children;
        // Note: Removed check for empty measures, playback might just be metronome
        // if (measures.length === 0) {
        //     log('No measures to play.');
        //     // return; // Or allow metronome-only playback
        // }

        const timeSignatureNum = parseInt(UI.elements.timeSignature.value);
        let intervalMs = (60 / AppState.tempo) * 1000;

        // Adjust interval for time signatures where we display subdivisions
        if (timeSignatureNum === 4) { // 4/4 uses 8th note interval if 8 beats displayed
            intervalMs /= 2;
        }
        // Add similar adjustments if needed for 6/8, 12/8 depending on how createBeats works

        AppState.currentBeat = 0; // Always start beat count at 0 for the measure

        // --- Start Logic ---
        // Only reset measure/play first beat immediately if NOT resuming playback
        // (e.g., first time clicking play, or after stopping completely)
        if (!AppState.intervalId) {
            // Determine starting measure (respect loop if active)
            AppState.currentMeasure = (AppState.loopingActive && AppState.loopStartMeasure !== -1)
                                      ? AppState.loopStartMeasure
                                      : 0;

            await playBeat(); // Play the very first beat/chord immediately

            // Advance beat counter *after* playing the first beat,
            // so the first interval waits correctly before playing the *second* beat.
            const totalBeatsInDisplay = document.querySelectorAll('.beat').length;
             if (totalBeatsInDisplay > 0) { // Prevent division by zero if no beats exist
                 AppState.currentBeat = (AppState.currentBeat + 1) % totalBeatsInDisplay;
                  // Advance measure if we wrapped around immediately (e.g., 1 beat time sig?)
                 if (AppState.currentBeat === 0) {
                     if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
                         AppState.currentMeasure++;
                         if (AppState.currentMeasure > AppState.loopEndMeasure) AppState.currentMeasure = AppState.loopStartMeasure;
                     } else if (measures.length > 0) {
                         AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
                     }
                 }
            }
        }
        // --- End Start Logic ---


        // Clear any previous interval and start the main playback loop
        clearInterval(AppState.intervalId);
        AppState.intervalId = setInterval(async () => {
            await playBeat(); // Call the main beat playing logic repeatedly
        }, intervalMs);

        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started.");

    } catch (e) { // Catch errors during startup
        console.error('Failed to start playback:', e);
        stopPlayback(); // Ensure cleanup if start fails
        alert("Error starting playback. Please check console."); // Inform user
    }
}

function stopPlayback() {
    clearInterval(AppState.intervalId); // Stop the interval timer
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false }); // Update state, keep beat/measure for resume

    // Clear active highlights
    document.querySelectorAll('.beat.active').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));

    // Fade out any currently playing chord sound
    if (AudioContextManager.currentChordGain && AudioContextManager.context) {
        try {
            const now = AudioContextManager.context.currentTime;
            // Check if gain node is still valid before manipulating
             if (AudioContextManager.currentChordGain.gain) {
                 AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, now);
                 AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            }
        } catch (rampError) {
            console.warn("Could not ramp down chord gain:", rampError); // Log error if ramp fails
        } finally {
             AudioContextManager.currentChordGain = null; // Allow garbage collection
        }
    }

    UI.elements.startStopButton.textContent = 'Start'; // Reset button text
    log("Playback stopped.");
}

// Progression Management (loadProgression, updateProgressionKey - update for song info)
function loadProgression(progName, overrideKey = null, isUserSong = false) {
    const songTitleEl = UI.elements.currentSongTitle;
    const songDescEl = UI.elements.currentSongDescription;
    let progData;

    if (isUserSong) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        progData = userSongs[progName];
    } else {
        progData = progressions[progName];
    }

    if (!progName || !progData) {
        currentProgressionName = ""; currentFunctionalProgression = [];
        UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
        if(songTitleEl) songTitleEl.textContent = ""; if(songDescEl) songDescEl.textContent = "";
        return;
    }
    currentProgressionName = progName; // Store the key used for lookup (original or user-defined name)
    currentFunctionalProgression = progData.progression; // Array of Roman numerals

    const activeKey = overrideKey || progData.defaultKey || "C";
    if(songTitleEl) songTitleEl.textContent = progData.displayName || progName.replace(/_/g, ' '); // Use displayName if available
    if(songDescEl) songDescEl.textContent = progData.description || "";
    if(UI.elements.keySelect) UI.elements.keySelect.value = activeKey;

    UI.elements.measures.innerHTML = '';
    currentFunctionalProgression.forEach((rcs, idx) => {
        const pc = parseRomanNumeralToAbsoluteChord(rcs, activeKey);
        const md = document.createElement('div'); md.className = 'measure'; md.draggable = true; md.dataset.measureIndex = idx;
        md.innerHTML = `<span class="measure-number" data-measure-idx="${idx}">${idx+1}</span><div class="chord-controls"><select class="root-note">${createKeyOptions(pc.root)}</select><select class="chord-quality">${createQualityOptions(pc.quality)}</select></div><div class="scale-controls"><select class="second-key">${createKeyOptions(pc.root)}</select><select class="scale-select">${createScaleOptions(suggestScaleForQuality(pc.quality))}</select></div>`;
        UI.elements.measures.appendChild(md);
        md.querySelectorAll('select').forEach(sel => sel.addEventListener('change', () => handleMeasureControlChange(md)));
        md.addEventListener('click', () => toggleMeasureLoopSelection(idx)); // For looper
        md.addEventListener('dragstart', dragStart); // For DnD
    });
    updateMeasureNumbers(); addFirstChordListener();
    log(`Loaded ${isUserSong ? 'user song' : 'progression'}: ${progName} in key ${activeKey}`);
}
function updateProgressionKey(newKey) { /* ... (update for song info, keep it if song loaded) ... */ const st=UI.elements.currentSongTitle;const sd=UI.elements.currentSongDescription;if(!currentFunctionalProgression||currentFunctionalProgression.length===0){if(UI.elements.measures.children.length===0){const t=TUNINGS[UI.elements.chordTuning.value];updateFretboardNotes(UI.elements.chordFretboard,newKey,'major',t);if(UI.elements.scaleDisplay)UI.elements.scaleDisplay.textContent=`${newKey} Major`;if(st)st.textContent="";if(sd)sd.textContent="";}return;} Array.from(UI.elements.measures.children).forEach((me,ix)=>{if(ix<currentFunctionalProgression.length){const rcs=currentFunctionalProgression[ix];const pc=parseRomanNumeralToAbsoluteChord(rcs,newKey);const rs=me.querySelector('.root-note');const qs=me.querySelector('.chord-quality');const sks=me.querySelector('.scale-controls .second-key');const ss=me.querySelector('.scale-controls .scale-select');if(rs)rs.value=pc.root;if(qs)qs.value=pc.quality;if(sks)sks.value=pc.root;if(ss)ss.value=suggestScaleForQuality(pc.quality);}});addFirstChordListener();log(`Progression '${currentProgressionName}' re-calculated for key: ${newKey}`);}

// Measure Management (addMeasure, removeMeasure, updateMeasureNumbers - mostly unchanged)
function addMeasure(r='C',q='maj7',sr='C',st='major'){const mc=UI.elements.measures.children.length;const md=document.createElement('div');md.className='measure';md.draggable=true;md.dataset.measureIndex=mc;md.innerHTML=`<span class="measure-number" data-measure-idx="${mc}">${mc+1}</span><div class="chord-controls"><select class="root-note">${createKeyOptions(r)}</select><select class="chord-quality">${createQualityOptions(q)}</select></div><div class="scale-controls"><select class="second-key">${createKeyOptions(sr)}</select><select class="scale-select">${createScaleOptions(st)}</select></div>`;UI.elements.measures.appendChild(md);md.querySelectorAll('select').forEach(sel=>sel.addEventListener('change',()=>handleMeasureControlChange(md)));md.addEventListener('click',()=>toggleMeasureLoopSelection(mc));md.addEventListener('dragstart',dragStart);updateMeasureNumbers();if(mc===0)addFirstChordListener();log(`Added measure ${mc+1}`);}
function removeMeasure(){const m=UI.elements.measures.children;if(m.length>0){const removedIdx = m.length -1; if(AppState.loopStartMeasure === removedIdx || AppState.loopEndMeasure === removedIdx) resetLoop(); m[m.length-1].remove();updateMeasureNumbers();if(m.length>0)addFirstChordListener();else if(UI.elements.scaleDisplay)UI.elements.scaleDisplay.textContent="";log('Removed last measure');}}
function updateMeasureNumbers(){Array.from(UI.elements.measures.children).forEach((m,i)=>{const n=m.querySelector('.measure-number');if(n){n.textContent=i+1; m.dataset.measureIndex = i; n.dataset.measureIdx = i;}});}

// Drag and Drop (dragStart, dragOver, drop, dragEnd - largely unchanged but update dataset.measureIndex)
function dragStart(e){e.dataTransfer.setData('text/plain',e.target.dataset.measureIndex);setTimeout(()=>e.target.classList.add('dragging'),0);}
function dragOver(e){e.preventDefault();}
function drop(e){e.preventDefault();const di=parseInt(e.dataTransfer.getData('text/plain'));const te=e.target.closest('.measure');if(!te)return;const ti=parseInt(te.dataset.measureIndex);if(di===ti||isNaN(di)||isNaN(ti))return;const ma=Array.from(UI.elements.measures.children);const dm=ma[di];if(di<ti)te.after(dm);else te.before(dm);updateMeasureNumbers();if(currentFunctionalProgression.length>0){const mi=currentFunctionalProgression.splice(di,1)[0];currentFunctionalProgression.splice(ti,0,mi);}addFirstChordListener();resetLoop();log(`Moved measure ${di+1} to ${ti+1}`);}
function dragEnd(e){e.target.classList.remove('dragging');}

// FretFlow (initializeFretFlow - Ensure note clicks work)
function initializeFretFlow() { /* ... (Keep existing, ensure updateFretboardNotes is called which adds click listeners) ... */ const fg=UI.elements.fretboardsGrid;if(!fg)return;fg.innerHTML='';fg.style.display='grid';fg.style.gridTemplateColumns='repeat(2,1fr)';fg.style.gap='20px';for(let i=0;i<4;i++){const fs=document.createElement('div');fs.className='fretboard-section';const so=Object.entries(SCALES).map(([sk,_])=>{const dn=sk.replace(/([A-Z])/g,' $1').replace(/^./,s=>s.toUpperCase());return`<option value="${sk}">${dn}</option>`;}).join('');fs.innerHTML=`<div class="fretboard-controls"><div class="control-group"><label for="ffk-${i}">Key:</label><select id="ffk-${i}"class="fretflow-key">${createKeyOptions()}</select></div><div class="control-group"><label for="ffs-${i}">Scale:</label><select id="ffs-${i}"class="fretflow-scale">${so}</select></div><div class="control-group"><label for="fft-${i}">Tuning:</label><select id="fft-${i}"class="tuning-select"><option value="standard">Std</option><option value="dropD">DropD</option><option value="openG">OpG</option><option value="DADGAD">DADGAD</option><option value="openE">OpE</option></select></div></div><div class="scale-display"id="ffsd-${i}"></div><div id="fffb-${i}"class="fretboard"></div>`;fg.appendChild(fs);const fe=fs.querySelector(`#fffb-${i}`);const kse=fs.querySelector(`#ffk-${i}`);const sse=fs.querySelector(`#ffs-${i}`);const tse=fs.querySelector(`#fft-${i}`);const sde=fs.querySelector(`#ffsd-${i}`);function u(){const sk=kse.value;const ss=sse.value;const stv=tse.value;const sta=TUNINGS[stv];if(!sta)return;const dsn=sse.options[sse.selectedIndex].text;sde.textContent=`${sk} ${dsn}`;createFretboard(fe,sta);updateFretboardNotes(fe,sk,ss,sta);}kse.addEventListener('change',u);sse.addEventListener('change',u);tse.addEventListener('change',u);u();}log("FretFlow initialized.");}
      
// Event Handling Helpers
function addFirstChordListener() { /* ... (Keep existing) ... */ const fm=UI.elements.measures.firstElementChild;if(fm){const srs=fm.querySelector('.scale-controls .second-key');const sts=fm.querySelector('.scale-controls .scale-select');const ts=UI.elements.chordTuning;const u=()=>{if(srs&&sts&&ts){const t=TUNINGS[ts.value];updateFretboardNotes(UI.elements.chordFretboard,srs.value,sts.value,t);}};u();}else{const t=TUNINGS[UI.elements.chordTuning.value];updateFretboardNotes(UI.elements.chordFretboard,"C","major",t);if(UI.elements.scaleDisplay)UI.elements.scaleDisplay.textContent="C Major (Default)";}}
function handleMeasureControlChange(me) { /* ... (Keep existing) ... */ const rs=me.querySelector('.chord-controls .root-note');const qs=me.querySelector('.chord-controls .chord-quality');const sks=me.querySelector('.scale-controls .second-key');const ss=me.querySelector('.scale-controls .scale-select');if(rs&&qs&&sks&&ss){sks.value=rs.value;ss.value=suggestScaleForQuality(qs.value);}if(me===UI.elements.measures.firstElementChild)addFirstChordListener();const mix=Array.from(UI.elements.measures.children).indexOf(me);if(AppState.isPlaying&&mix===AppState.currentMeasure){const t=TUNINGS[UI.elements.chordTuning.value];updateFretboardNotes(UI.elements.chordFretboard,sks.value,ss.value,t);}}

// User Progression Save/Load
function saveCurrentProgression() {
    const measures = Array.from(UI.elements.measures.children);
    if (measures.length === 0) { alert("No progression to save!"); return; }

    let progName = prompt("Enter a name for this progression:", currentProgressionName || "My New Song");
    if (!progName || progName.trim() === "") { alert("Save cancelled or invalid name."); return; }
    progName = progName.trim();

    const progressionToSave = measures.map(measure => {
        const root = measure.querySelector('.root-note').value;
        const quality = measure.querySelector('.chord-quality').value;
        // For saving, it's better to save the functional chord if possible, or the absolute chord.
        // Here, we'll save the absolute chord as displayed.
        // If currentFunctionalProgression is available and matches length, prefer that.
        const measureIndex = parseInt(measure.dataset.measureIndex);
        if (currentFunctionalProgression && measureIndex < currentFunctionalProgression.length) {
            return currentFunctionalProgression[measureIndex]; // Save the Roman numeral
        }
        return `${root}${quality}`; // Fallback to absolute chord string
    });

    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    userSongs[progName] = {
        progression: progressionToSave,
        defaultKey: UI.elements.keySelect.value, // Save the key it was in when saved
        description: `User saved on ${new Date().toLocaleDateString()}`, // Simple description
        displayName: progName // For display in dropdown
    };
    localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));
    populateUserSongsDropdown();
    alert(`Progression "${progName}" saved!`);
    log(`Saved progression: ${progName}`);
}

function populateUserSongsDropdown() {
    const selectEl = UI.elements.userProgressionSelect;
    selectEl.innerHTML = '<option value="">-- Select a saved song --</option>'; // Clear existing
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    for (const name in userSongs) {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = userSongs[name].displayName || name;
        selectEl.appendChild(option);
    }
}

function deleteSelectedUserSong() {
    const selectedSongName = UI.elements.userProgressionSelect.value;
    if (!selectedSongName) { alert("Please select a song to delete."); return; }

    if (confirm(`Are you sure you want to delete "${selectedSongName}"? This cannot be undone.`)) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        delete userSongs[selectedSongName];
        localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));
        populateUserSongsDropdown();
        // If the deleted song was loaded, clear the measures
        if (currentProgressionName === selectedSongName) {
            UI.elements.measures.innerHTML = '';
            UI.elements.currentSongTitle.textContent = '';
            UI.elements.currentSongDescription.textContent = '';
            currentProgressionName = "";
            currentFunctionalProgression = [];
        }
        alert(`Song "${selectedSongName}" deleted.`);
        log(`Deleted user song: ${selectedSongName}`);
    }
}

// Looper Functionality
function toggleMeasureLoopSelection(measureIndex) {
    if (!AppState.loopingActive) return; // Only allow selection if looping mode is on

    const measureEl = UI.elements.measures.children[measureIndex];
    if (!measureEl) return;

    measureEl.classList.toggle('loop-selected');
    
    // Update loopStartMeasure and loopEndMeasure
    const selectedIndices = Array.from(UI.elements.measures.children)
        .map((m, idx) => m.classList.contains('loop-selected') ? idx : -1)
        .filter(idx => idx !== -1)
        .sort((a,b) => a - b); // Ensure they are sorted

    if (selectedIndices.length > 0) {
        AppState.loopStartMeasure = selectedIndices[0];
        AppState.loopEndMeasure = selectedIndices[selectedIndices.length - 1];
        // Ensure continuity: select all measures between the new min and max
        for (let i = AppState.loopStartMeasure; i <= AppState.loopEndMeasure; i++) {
            UI.elements.measures.children[i].classList.add('loop-selected');
        }
    } else {
        resetLoop();
    }
    log(`Loop selection: ${AppState.loopStartMeasure} to ${AppState.loopEndMeasure}`);
}
function resetLoop() {
    AppState.loopStartMeasure = -1;
    AppState.loopEndMeasure = -1;
    Array.from(UI.elements.measures.children).forEach(m => m.classList.remove('loop-selected'));
}
function toggleLoopingMode() {
    AppState.loopingActive = !AppState.loopingActive;
    UI.elements.loopSelectedToggle.textContent = AppState.loopingActive ? "Looping ON" : "Looping Off";
    UI.elements.loopSelectedToggle.classList.toggle('active', AppState.loopingActive);
    if (!AppState.loopingActive) {
        resetLoop(); // Clear selections when turning looping off
    } else {
        alert("Looping enabled. Click on measures to select a loop range. Playback will loop the selected measures.");
    }
    log(`Looping mode: ${AppState.loopingActive}`);
}

// Guide Tones Functionality
function toggleGuideTones() {
    AppState.guideTonesActive = !AppState.guideTonesActive;
    UI.elements.guideTonesToggle.textContent = AppState.guideTonesActive ? "Guide Tones ON" : "Guide Tones Off";
    UI.elements.guideTonesToggle.classList.toggle('active', AppState.guideTonesActive);
    if (AppState.guideTonesActive) {
        highlightGuideTones();
    } else {
        clearGuideToneHighlights();
    }
    log(`Guide tones: ${AppState.guideTonesActive}`);
}

function highlightGuideTones() {
    clearGuideToneHighlights();
    if (!AppState.guideTonesActive || AppState.currentMeasure < 0 || !UI.elements.measures.children[AppState.currentMeasure]) return;

    const measures = UI.elements.measures.children;
    const currentMeasureEl = measures[AppState.currentMeasure];
    const nextMeasureIndex = (AppState.currentMeasure + 1) % measures.length; // Naive next, doesn't handle loops well yet
    const nextMeasureEl = measures[nextMeasureIndex];

    if (!currentMeasureEl || !nextMeasureEl) return;

    const currentRoot = currentMeasureEl.querySelector('.root-note').value;
    const currentQuality = currentMeasureEl.querySelector('.chord-quality').value;
    const nextRoot = nextMeasureEl.querySelector('.root-note').value;
    const nextQuality = nextMeasureEl.querySelector('.chord-quality').value;

    const currentChordNotes = getChordNotes(currentRoot, currentQuality);
    const nextChordNotes = getChordNotes(nextRoot, nextQuality);

    if (currentChordNotes.length < 4 || nextChordNotes.length < 2) return; // Need at least 7th and 3rd

    // Get 7th of current chord (typically 4th note in a 4-note voicing like [R,3,5,7])
    // CHORD_INTERVALS['dom7'] = [0, 4, 7, 10]. 10 is the 7th.
    // CHORD_INTERVALS['maj7'] = [0, 4, 7, 11]. 11 is the 7th.
    // CHORD_INTERVALS['min7'] = [0, 3, 7, 10]. 10 is the 7th.
    let seventhInterval;
    if (currentQuality.includes('7') || currentQuality.includes('6')) { // Simplified check
        const intervals = CHORD_INTERVALS[currentQuality];
        seventhInterval = intervals.find(i => i === 10 || i === 11 || i === 9); // 10 (b7), 11 (M7), 9 (6th as guide tone)
    }
    if (seventhInterval === undefined) return;
    const current7th = NOTES[(NOTES.indexOf(standardizeNoteName(currentRoot)) + seventhInterval) % 12];

    // Get 3rd of next chord
    // CHORD_INTERVALS['maj7'] = [0, 4, ...]. 4 is the 3rd.
    // CHORD_INTERVALS['min7'] = [0, 3, ...]. 3 is the 3rd.
    let thirdInterval;
    if (nextQuality.includes('maj') || nextQuality.includes('dom') || nextQuality.includes('aug')) thirdInterval = 4;
    else if (nextQuality.includes('min') || nextQuality.includes('dim')) thirdInterval = 3;
    
    if (thirdInterval === undefined) return;
    const next3rd = NOTES[(NOTES.indexOf(standardizeNoteName(nextRoot)) + thirdInterval) % 12];

    // Check for resolution (half or whole step)
    const dist = Math.abs(NOTES.indexOf(current7th) - NOTES.indexOf(next3rd));
    const isResolution = dist === 1 || dist === 2 || dist === 11 || dist === 10; // Half/whole step (11/10 for wraparound)

    if (isResolution) {
        const fretboardNotes = UI.elements.chordFretboard.querySelectorAll('.note');
        fretboardNotes.forEach(noteEl => {
            if (noteEl.textContent === current7th || noteEl.textContent === next3rd) {
                noteEl.classList.add('guide-tone-highlight');
            }
        });
    }
}

function clearGuideToneHighlights() {
    UI.elements.chordFretboard.querySelectorAll('.note.guide-tone-highlight')
        .forEach(n => n.classList.remove('guide-tone-highlight'));
}


// Event Listeners Setup
function setupEventListeners() {
    document.body.addEventListener('click', ensureAudioInitializedUserInteraction, { once: true });
    UI.elements.startStopButton.addEventListener('click', () => { if (AppState.isPlaying) stopPlayback(); else startPlayback(); });
    if (UI.elements.drumSetToggleBtn) { UI.elements.drumSetToggleBtn.addEventListener('click', () => { currentDrumSetIndex=(currentDrumSetIndex+1)%drumSoundSets.length; UI.elements.drumSetToggleBtn.textContent=drumSoundSets[currentDrumSetIndex].name; log(`Switched to drum set: ${drumSoundSets[currentDrumSetIndex].name}`); }); }
    if (UI.elements.soundType) { UI.elements.soundType.addEventListener('change', (e)=>onMetronomeInstrumentChange(e.target.value)); onMetronomeInstrumentChange(UI.elements.soundType.value); } // Initialize visibility based on current value

    let colorMode=0; UI.elements.darkModeToggle.addEventListener('click',()=>{colorMode=(colorMode+1)%4;document.body.classList.remove('dark-mode','dark-mode-2','dark-mode-3');UI.elements.darkModeToggle.classList.remove('active','active-2','active-3');const m=['','dark-mode','dark-mode-2','dark-mode-3'];const ac=['','active','active-2','active-3'];if(colorMode>0){document.body.classList.add(m[colorMode]);UI.elements.darkModeToggle.classList.add(ac[colorMode]);} log(`Color mode: ${m[colorMode]||'Light'}`);});

    UI.elements.chordsEnabled.addEventListener('click',()=>{const iA=UI.elements.chordsEnabled.classList.toggle('active');UI.elements.chordsEnabled.textContent=iA?'Chords Enabled':'Chords Disabled'; log(`Chords ${iA ? 'enabled' : 'disabled'}`); });
    UI.elements.tempo.addEventListener('input',()=>{AppState.tempo=parseInt(UI.elements.tempo.value);UI.elements.tempoDisplay.textContent=`${AppState.tempo} BPM`;if(AppState.isPlaying){stopPlayback();startPlayback();}});
    UI.elements.tapTempo.addEventListener('click',()=>{const n=Date.now();AppState.tapTempoTimestamps.push(n);if(AppState.tapTempoTimestamps.length>4)AppState.tapTempoTimestamps.shift();if(AppState.tapTempoTimestamps.length>1){let ti=0;for(let i=1;i<AppState.tapTempoTimestamps.length;i++)ti+=AppState.tapTempoTimestamps[i]-AppState.tapTempoTimestamps[i-1];const ai=ti/(AppState.tapTempoTimestamps.length-1);if(ai>0&&ai<3000){const bpm=Math.round(60000/ai);AppState.tempo=Math.max(40,Math.min(220,bpm));UI.elements.tempo.value=AppState.tempo;UI.elements.tempoDisplay.textContent=`${AppState.tempo} BPM`;if(AppState.isPlaying){stopPlayback();startPlayback();}}} setTimeout(()=>{if(AppState.tapTempoTimestamps.length>0&&Date.now()-AppState.tapTempoTimestamps[AppState.tapTempoTimestamps.length-1]>3000)AppState.tapTempoTimestamps=[];},3100);});
    UI.elements.timeSignature.addEventListener('change',()=>{createBeats();if(AppState.isPlaying){stopPlayback();startPlayback();}});

    if(UI.elements.reverbDial&&UI.elements.reverbDialValue){UI.elements.reverbDial.addEventListener('input',function(e){const v=parseInt(e.target.value,10);AudioContextManager.reverbAmount=v/100;UI.elements.reverbDialValue.textContent=v; log(`Reverb amount set to: ${AudioContextManager.reverbAmount}`);});}

    // Listener for standard progression selection
    UI.elements.progressionSelect.addEventListener('change', (e) => {
        const selectedSong = e.target.value;
        // --- CORRECTED PART ---
        // Load the selected song using its default key (pass null for overrideKey)
        loadProgression(selectedSong, null, false);
        // --- END CORRECTION ---

        // Deselect any user song if a standard progression is chosen
        if (selectedSong && UI.elements.userProgressionSelect) {
            UI.elements.userProgressionSelect.value = "";
        }
    });

    // Listener for user-saved progression selection
    if (UI.elements.userProgressionSelect) {
        UI.elements.userProgressionSelect.addEventListener('change', (e) => {
            const selectedUserSong = e.target.value;
            if (selectedUserSong) { // Only proceed if a valid user song is selected
                const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
                const userSongData = userSongs[selectedUserSong];
                // Use the user song's saved default key, or fallback if needed
                const keyToLoad = userSongData?.defaultKey || UI.elements.keySelect.value;
                loadProgression(selectedUserSong, keyToLoad, true);
                // Deselect any standard song if a user progression is chosen
                if (UI.elements.progressionSelect) UI.elements.progressionSelect.value = "";
            }
        });
    }

    // Listener for changing the key (transposing the currently loaded song)
    UI.elements.keySelect.addEventListener('change', (e) => {
        updateProgressionKey(e.target.value);
    });

    // Listener for changing the tuning
    UI.elements.chordTuning.addEventListener('change', () => {
        addFirstChordListener(); // Update main fretboard display
        initializeFretFlow(); // Reinitialize FretFlow boards
    });

    // Listeners for user song management buttons
    if (UI.elements.saveProgressionButton) UI.elements.saveProgressionButton.addEventListener('click', saveCurrentProgression);
    if (UI.elements.deleteUserSongButton) UI.elements.deleteUserSongButton.addEventListener('click', deleteSelectedUserSong);

    // Listeners for toggle buttons
    if (UI.elements.guideTonesToggle) UI.elements.guideTonesToggle.addEventListener('click', toggleGuideTones);
    if (UI.elements.loopSelectedToggle) UI.elements.loopSelectedToggle.addEventListener('click', toggleLoopingMode);

    // Listeners for drag and drop on the measures container
    UI.elements.measures.addEventListener('dragover', dragOver);
    UI.elements.measures.addEventListener('drop', drop);
    // Note: dragstart/dragend listeners are added to individual measures when they are created

    log("Event listeners set up.");
}

// Initialize App
async function initializeApp() {
    UI.init();
    try { await AudioContextManager.initialize(); } catch (e) { updateLoadingStatus("Audio init failed. Click to try.", true); }
    createBeats();
    const initTuning = TUNINGS[UI.elements.chordTuning.value] || TUNINGS.standard;
    createFretboard(UI.elements.chordFretboard, initTuning);
    
    populateUserSongsDropdown(); // Load user songs first
    const initProg = UI.elements.progressionSelect.value || Object.keys(progressions)[0];
    const initKey = UI.elements.keySelect.value || progressions[initProg]?.defaultKey || "C";
    loadProgression(initProg, initKey, false); 
    
    initializeFretFlow();
    setupEventListeners();
    updateLoadingStatus("Application initialized", false); // Hide after a delay
    setTimeout(() => updateLoadingStatus("", false), 1000);
    log("Application initialized.");
}

document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(e => { console.error("App init failed:", e); updateLoadingStatus("Initialization Error!", true); });
});

    </script>
</body>
</html>
