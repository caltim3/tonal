<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bebop Blueprint</title>
    <link rel="icon" type="image/png" href="jazzmaster.png">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Lato', sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--bg-color, #f0f0f0); /* Lighter default background */
        color: var(--text-color, #333);

        /* Light Theme (Default) Guide Tone Colors */
        --guide-tone-bg-color: #007bff;       /* Bright Blue */
        --guide-tone-text-color: white;
        --guide-tone-border-color: #0056b3;    /* Darker Blue */
        --root-highlight-border-color: #c82333; /* Default for root highlight border */

        /* Item 1: Song Title Color */
        --song-title-fretboard-color: #0056b3; /* Darker blue for light mode */
    }
    .app-section {
        background: var(--section-bg-color, white);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        color: var(--section-text-color, inherit);
    }
    .fretboards-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin-bottom: 30px;
    }
    .fretboard-container {
        background: var(--fretboard-container-bg, white);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        border: 1px solid var(--fretboard-container-border, transparent);
    }
    /* Song Info Display Styling (Item 1) */
    #song-info-display-fretboard {
        margin-bottom: 10px; /* Space before scale display */
    }
    #song-info-display-fretboard #current-song-title-fretboard {
        text-align: left;
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 1.3em; /* Slightly larger */
        font-weight: bold; /* Bolder */
        color: var(--song-title-fretboard-color); /* Themed color */
    }
    #song-info-display-fretboard p {
        text-align: left;
        margin-top: 0;
        margin-bottom: 5px;
        font-size: 0.9em;
        color: var(--song-info-p-color, #555);
        font-style: italic;
    }

    .scale-display {
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
        margin-bottom: 5px; /* Reduced margin */
        color: var(--scale-display-color, #333);
        min-height: 1.5em; /* Reserve space */
    }
    /* Next Chord Display Styling */
    .next-chord-display {
        font-size: 0.95em; /* Slightly smaller than scale display */
        font-style: italic;
        text-align: center;
        color: var(--next-chord-color, #6c757d); /* Muted gray color */
        margin-top: -5px; /* Pull it up slightly */
        margin-bottom: 15px; /* Space below before controls */
        height: auto; /* Allow multiple lines */
        min-height: 1.2em; /* Reserve space to prevent layout shift for single line */
        line-height: 1.2em;
    }
    .controls, .top-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
        align-items: center;
    }
    .controls-container { display: flex; gap: 20px; margin-bottom: 20px; }
    .control-group { display: flex; align-items: center; gap: 10px; }
    .control-group label { font-weight: bold; }
    .control-group select { padding: 5px; border-radius: 4px; border: 1px solid #ccc; }

    .fretboard {
        position: relative;
        height: 200px;
        background-color: var(--fretboard-bg, #FFCF79);
        border-radius: 5px;
        margin-bottom: 30px;
        border: 2px solid var(--fretboard-border, #4A3B31);
        overflow: visible;
    }
    .fret-line { position: absolute; top: 0; height: 100%; width: 2px; background: #A0A0A0; border-right: 1px solid rgba(0,0,0,0.1); z-index: 1; }
    .string-line { position: absolute; left: 0; width: 100%; height: 1px; background: #C0C0C0; border-bottom: 1px solid rgba(0,0,0,0.1); z-index: 0; }
    .fret-number { position: absolute; bottom: -25px; font-size: 14px; color: #555; transform: translateX(-50%); font-weight: bold; z-index: 2; width: 20px; text-align: center; }
    .fret-marker { position: absolute; width: 10px; height: 10px; background-color: #5A4F46; border-radius: 50%; transform: translate(-50%, -50%); z-index: 1; }
    
    .note {
        position: absolute;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: var(--note-text-color, white); /* Default note text color */
        z-index: 3;
        cursor: pointer;
        transform: translate(-50%, -50%);
        transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.2s ease, color 0.2s ease, outline 0.2s ease;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        /* background-color is set by JS for regular notes */
    }

    /* UPDATED GUIDE TONE STYLING (Item 3) */
    .note.guide-tone-highlight, .note.root-highlight-for-guides {
        outline: 3px solid var(--guide-tone-border-color) !important;
        box-shadow: 0 0 8px 2px var(--guide-tone-border-color) !important;
        transform: translate(-50%, -50%) scale(0.95) !important; /* Make them slightly smaller */
        z-index: 10 !important;
        font-weight: bold !important;
        border-radius: 50%;
    }
    .note.guide-tone-highlight {
        background-color: var(--guide-tone-bg-color) !important;
        color: var(--guide-tone-text-color) !important;
    }
    .note.root-highlight-for-guides {
        /* Retains its original background and text color from the scale drawing logic */
        /* Specific border for root if needed, defaults to guide tone border */
         outline-color: var(--root-highlight-border-color) !important;
         box-shadow: 0 0 8px 2px var(--root-highlight-border-color) !important;
    }

    .note:hover {
        transform: translate(-50%, -50%) scale(1.2);
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .note.guide-tone-highlight:hover, .note.root-highlight-for-guides:hover {
        transform: translate(-50%, -50%) scale(1.1) !important; /* Slightly larger hover for highlighted notes */
    }


    .beat { width: 40px; height: 80px; background: #9E9E9E; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s ease; font-size: 14px; margin: 0 2px; }
    .beats-container { display: flex; justify-content: center; gap: 8px; margin: 20px 0; flex-wrap: nowrap; overflow-x: auto; }
    .beat.active { transform: translateY(-10px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    #measures { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
    
    .measure { 
        position: relative; 
        background-color: var(--measure-bg, #e9ecef); 
        padding: 10px; /* Reduced padding slightly */
        border-radius: 4px; 
        transition: opacity 0.2s ease, background-color 0.2s ease, border 0.2s ease; 
        border: 2px solid transparent; 
        cursor: pointer; 
        color: var(--measure-text-color, #333); 
        display: flex; /* For split measure layout */
        flex-direction: column; /* Default: Stack parts or part + button */
        gap: 8px; /* Gap between parts or part and button */
    }
    .measure.split-active {
        /* Styles for when measure is split, parts might go side-by-side */
        flex-direction: row; /* Arrange parts side by side */
        align-items: flex-start; /* Align items at the top */
    }
    .measure-part {
        flex: 1; /* Each part takes equal space if side-by-side */
        display: flex;
        flex-direction: column;
        gap: 5px; /* Gap between controls within a part */
        padding: 5px;
        border: 1px dashed var(--measure-part-border-color, #ccc);
        border-radius: 3px;
    }
    .measure.split-active .measure-part {
        min-width: 120px; /* Ensure controls don't get too squished */
    }

    .measure-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
    }
    .measure-number { 
        font-size: 12px; 
        color: var(--measure-text-color, #333);
        background-color: rgba(255,255,255,0.7); 
        padding: 2px 4px; 
        border-radius: 3px; 
    }
    .split-measure-button {
        padding: 3px 6px;
        font-size: 0.8em;
        align-self: flex-end; /* Position button appropriately */
        margin-top: 5px;
    }
    .measure.split-active .split-measure-button {
        /* Adjust button position if measure content is row-based */
        /* This might need to be outside the measure-part flow */
    }
     .measure-footer { /* Container for buttons at the bottom of a measure */
        display: flex;
        justify-content: flex-end; /* Align button to the right */
        margin-top: auto; /* Pushes to the bottom if measure is flex-column */
    }
     .measure.split-active .measure-footer {
        width: 100%; /* Make footer span across if measure becomes row for parts */
        justify-content: center; /* Center button if parts are side-by-side */
        padding-top: 10px;
    }


    .measure.loop-selected { border: 2px solid var(--measure-loop-border, #007bff); background-color: var(--measure-loop-bg, #e6f2ff); }
    .measure.active .measure-part.part-active { background-color: var(--measure-active-bg, #c3e6cb); border: 1px solid var(--measure-active-border, #28a745); }
    .measure.active .measure-part:not(.part-active) { /* Slightly dim inactive part */
        opacity: 0.7;
    }


    .chord-controls, .scale-controls { display: flex; gap: 5px; margin-bottom: 5px; flex-wrap: wrap;}
    .chord-controls select, .scale-controls select { flex: 1; min-width: 60px; }


    .fretboard-section { border: 1px solid #ccc; padding: 15px; border-radius: 8px; background-color: #f9f9f9; }
    body.dark-mode .fretboard-section { background-color: #3a441e; border-color: #606c38; color: #fefae0; }
    body.dark-mode-2 .fretboard-section { background-color: #001f54; border-color: #1282a2; color: #fefcfb; }
    body.dark-mode-3 .fretboard-section { background-color: #a5a58d; border-color: #cb997e; color: #ffe8d6; }
    .fretboard-controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; }
    
    .volume-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 5px 0;
        color: var(--volume-control-text-color, inherit);
    }
    #metronome-volume-controls-stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-width: 400px;
        margin: 15px auto 20px auto;
    }
    #metronome-volume-controls-stack .volume-control {
        width: 100%;
        justify-content: space-between; 
    }
    #metronome-volume-controls-stack .volume-control label,
    #metronome-volume-controls-stack .volume-control span {
        margin-right: 10px;
        white-space: nowrap;
        flex-shrink: 0; 
    }
    #metronome-volume-controls-stack .volume-control input[type="range"] {
        flex-grow: 1;
        min-width: 150px;
        max-width: 250px;
    }

    button, .button-like { padding: 10px 15px; border: none; border-radius: 5px; background: var(--button-bg, #4CAF50); color: var(--button-text-color, white); cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
    button:hover, .button-like:hover { background: var(--button-hover-bg, #45a049); }
    button.secondary { background-color: var(--button-secondary-bg, #007bff); }
    button.secondary:hover { background-color: var(--button-secondary-hover-bg, #0056b3); }
    button.danger { background-color: var(--button-danger-bg, #6b705c); }
    button.danger:hover { background-color: var(--button-danger-hover-bg, #c82333); }
    select { padding: 8px 10px; margin: 5px; border-radius: 5px; border: 1px solid var(--select-border-color, #ddd); background-color: var(--select-bg-color, white); color: var(--select-text-color, inherit); }
    #tempo-display { font-size: 1.2em; font-weight: bold; margin: 0 10px; min-width: 70px; text-align: center; }
    #loading-indicator { position: fixed; top: 20px; right: 20px; padding: 10px 15px; background: rgba(0,0,0,0.8); color: white; border-radius: 5px; z-index: 1000; font-size: 0.9em; display: none; }
    .checkbox-wrapper { margin-top: 10px; margin-left: 0; display: flex; align-items: center; }
    .control-button { padding: 8px 12px; font-size: 0.9em; }
    #chordsEnabled { margin-bottom: 10px; }

    #start-stop {
        padding: 12px 25px !important;
        font-size: 1.1em !important;
        font-weight: bold !important;
        background-color: var(--start-stop-bg, #28a745) !important;
        border: 2px solid var(--start-stop-border, #1e7e34) !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        color: var(--start-stop-text-color, white) !important;
    }
    #start-stop:hover {
        background-color: var(--start-stop-hover-bg, #218838) !important;
        border-color: var(--start-stop-hover-border, #1c6c2e) !important;
    }

    /* --- Dark Mode 1 --- */
    body.dark-mode {
        --bg-color: #283618;
        --text-color: #fefae0;
        --section-bg-color: linear-gradient(145deg, #283618, #606c38);
        --section-text-color: #fefae0;
        --fretboard-container-bg: #606c38;
        --fretboard-container-border: #dda15e;
        /* Item 1 */ --song-title-fretboard-color: #dda15e; /* Goldish for DM1 */
        --song-info-h4-color: #fefae0;
        --song-info-p-color: #e0daca;
        --fretboard-bg: #dda15e;
        --fretboard-border: #4b4b4b;
        --note-text-color: #283618; /* Note text on fretboard */
        --scale-display-color: #fefae0;
        --button-bg: #dda15e;
        --button-text-color: #283618;
        --button-hover-bg: #bc6c25;
        --button-secondary-bg: #a17d40;
        --button-secondary-hover-bg: #8a6930;
        --button-danger-bg: #6b705c;
        --button-danger-hover-bg: #d73744;
        --start-stop-bg: #fca311;
        --start-stop-border: #e79002;
        --start-stop-text-color: #283618;
        --start-stop-hover-bg: #e79002;
        --start-stop-hover-border: #c87800;
        --select-bg-color: #dda15e;
        --select-text-color: #283618;
        --select-border-color: #bc6c25;
        --measure-bg: #606c38;
        --measure-text-color: #fefae0;
        --measure-border: #dda15e; /* Default border for measure */
        --measure-active-bg: #dda15e;
        --measure-active-border: #bc6c25;
        --measure-loop-bg: #7d6830;
        --measure-loop-border: #ffc107;
        --beat-bg: #dda15e;
        --beat-text-color: #283618;
        --beat-active-bg: #bc6c25;
        --volume-control-text-color: #fefae0;
        --next-chord-color: #fefae0;
        --measure-part-border-color: #dda15e;


        /* Dark Mode 1 Guide Tone Colors */
        --guide-tone-bg-color: #61dafb;      /* Light Cyan/Aqua */
        --guide-tone-text-color: #0a1128;    /* Very Dark Blue/Black */
        --guide-tone-border-color: #4ac9e8;   /* Slightly Darker Cyan */
        --root-highlight-border-color: #ffc107; /* Gold for root highlight */
    }
    .dark-mode .app-section { box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
    .dark-mode .scale-display { text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
    .dark-mode .beat.active { transform: translateY(-5px); }
    #dark-mode-toggle.active { background-color: #283618; color: #fefae0; border: 1px solid #dda15e; }

    /* --- Dark Mode 2 --- */
    body.dark-mode-2 {
        --bg-color: #0a1128;
        --text-color: #fefcfb;
        --section-bg-color: linear-gradient(145deg, #001f54, #034078);
        --section-text-color: #fefcfb;
        --fretboard-container-bg: #034078;
        --fretboard-container-border: #1282a2;
        /* Item 1 */ --song-title-fretboard-color: #61dafb; /* Cyan for DM2 */
        --song-info-h4-color: #fefcfb;
        --song-info-p-color: #e0e0df;
        --fretboard-bg: #001f54;
        --fretboard-border: #1282a2;
        --note-text-color: #fefcfb; /* Note text on fretboard */
        --scale-display-color: #fefcfb;
        --button-bg: #1282a2;
        --button-text-color: #fefcfb;
        --button-hover-bg: #0e6c89;
        --button-secondary-bg: #0c5f7d;
        --button-secondary-hover-bg: #094b61;
        --button-danger-bg: #6b705c;
        --button-danger-hover-bg: #e83838;
        --start-stop-bg: #61dafb;
        --start-stop-border: #4ac9e8;
        --start-stop-text-color: #0a1128;
        --start-stop-hover-bg: #4ac9e8;
        --start-stop-hover-border: #32b6d4;
        --select-bg-color: #034078;
        --select-text-color: #fefcfb;
        --select-border-color: #1282a2;
        --measure-bg: #034078;
        --measure-text-color: #fefcfb;
        --measure-border: #1282a2;
        --measure-active-bg: #1282a2;
        --measure-active-border: #fefcfb;
        --measure-loop-bg: #01325A;
        --measure-loop-border: #61dafb;
        --beat-bg: #1282a2;
        --beat-text-color: #fefcfb;
        --beat-active-bg: #034078;
        --volume-control-text-color: #fefcfb;
        --next-chord-color: #fefcfb;
        --measure-part-border-color: #1282a2;

        /* Dark Mode 2 Guide Tone Colors */
        --guide-tone-bg-color: #fca311;      /* Bright Orange/Yellow */
        --guide-tone-text-color: #001f54;    /* Dark Blue (contrasts with bg) */
        --guide-tone-border-color: #e79002;   /* Darker Orange */
        --root-highlight-border-color: #61dafb; /* Cyan for root highlight */
    }
    #dark-mode-toggle.active-2 { background-color: #1282a2; color: #fefcfb; border: 1px solid #034078; }

    /* --- Dark Mode 3 --- */
    body.dark-mode-3 {
        --bg-color: #6b705c;
        --text-color: #ffe8d6;
        --section-bg-color: linear-gradient(145deg, #6b705c, #a5a58d);
        --section-text-color: #ffe8d6;
        --fretboard-container-bg: #a5a58d;
        --fretboard-container-border: #cb997e;
        /* Item 1 */ --song-title-fretboard-color: #e7ad99; /* Peach for DM3 */
        --song-info-h4-color: #ffe8d6;
        --song-info-p-color: #f0d8c6;
        --fretboard-bg: #cb997e;
        --fretboard-border: #6b705c;
        --note-text-color: #6b705c; /* Note text on fretboard */
        --scale-display-color: #ffe8d6;
        --button-bg: #cb997e;
        --button-text-color: #6b705c;
        --button-hover-bg: #b2856c;
        --button-secondary-bg: #b18f7a;
        --button-secondary-hover-bg: #9a7860;
        --button-danger-bg: #6b705c;
        --button-danger-text-color: white; /* Specific for this button */
        --button-danger-hover-bg: #c24a4a;
        --start-stop-bg: #e7ad99;
        --start-stop-border: #d09882;
        --start-stop-text-color: #6b705c;
        --start-stop-hover-bg: #d09882;
        --start-stop-hover-border: #b9836c;
        --select-bg-color: #ddbea9;
        --select-text-color: #6b705c;
        --select-border-color: #cb997e;
        --measure-bg: #a5a58d;
        --measure-text-color: #ffe8d6;
        --measure-border: #cb997e;
        --measure-active-bg: #ddbea9;
        --measure-active-border: #cb997e;
        --measure-loop-bg: #BDA290;
        --measure-loop-border: #e7ad99;
        --beat-bg: #ddbea9;
        --beat-text-color: #6b705c;
        --beat-active-bg: #cb997e;
        --volume-control-text-color: #ffe8d6;
        --next-chord-color: #ffe8d6;
        --measure-part-border-color: #cb997e;

        /* Dark Mode 3 Guide Tone Colors */
        --guide-tone-bg-color: #EF233C;      /* Bright Red/Pink */
        --guide-tone-text-color: #ffe8d6;    /* Light Peach (theme text color) */
        --guide-tone-border-color: #D90429;   /* Darker Red */
        --root-highlight-border-color: #e7ad99; /* Peach for root highlight */
    }
    .dark-mode-3 button.danger { color: var(--button-danger-text-color, white); } /* Ensure text color is applied */
    #dark-mode-toggle.active-3 { background-color: #cb997e; color: #ffe8d6; border: 1px solid #6b705c; }

    /* Fretflow Section Theming (ensure these are after main theme blocks if they don't use vars from body) */
    .dark-mode #fretflow-section { background: linear-gradient(145deg, #283618, #606c38); color: #fefae0; }
    .dark-mode-2 #fretflow-section { background: linear-gradient(145deg, #001f54, #034078); color: #fefcfb; }
    .dark-mode-3 #fretflow-section { background: linear-gradient(145deg, #6b705c, #a5a58d); color: #ffe8d6; }

    .toggle-button { padding: 8px 12px; border: none; border-radius: 5px; color: white; cursor: pointer; transition: background-color 0.3s ease; font-size: 0.9em; }
    .toggle-button.active { background: #4CAF50; }
    .toggle-button:not(.active) { background: #9E9E9E; }

    #user-songs-section { margin-top: 15px; }
    #user-songs-section label { margin-right: 5px; }

    /* Media Queries (keep at the end) */
    @media (max-width: 1200px) { /* #measures grid-template-columns already responsive */ }
    @media (max-width: 768px) {
        .measure.split-active {
            flex-direction: column; /* Stack parts on smaller screens */
        }
        .measure.split-active .measure-part {
            min-width: unset; /* Allow full width when stacked */
        }
    }
    @media (max-width: 600px) { /* #measures grid-template-columns already responsive */ }

    </style>
</head>
<body>
    <div class="top-controls app-section">
        <button id="dark-mode-toggle" aria-label="Toggle dark mode">Dark Mode</button>
        <!-- Guide Tones & Loop buttons moved -->
    </div>

    <div class="app-section" id="chord-fretboard-section">
        <h1>BEBOP BLUEPRINT</h1>
        <h3>Fretflow - Dynamic Fretboard with Scales that Move with the Chord Progression</h3>
        <div class="volume-control">
            <span>Fretboard Volume:</span>
            <input type="range" id="chord-fretboard-volume" min="0" max="1" step="0.1" value="0.3">
        </div>
        <div class="fretboard-container">
            <!-- Song Info Moved Here (Item 1) -->
            <div id="song-info-display-fretboard">
                <h4 id="current-song-title-fretboard"></h4>
                <p id="current-song-description-fretboard"></p>
            </div>
            <div class="scale-display" id="scale-display">Select a progression and key.</div>
            <div class="next-chord-display" id="next-chord-display"></div>
            <div class="controls">
                <select class="tuning-select" id="chord-tuning" aria-label="Select guitar tuning">
                    <option value="standard">Standard (EADGBE)</option>
                    <option value="dropD">Drop D (DADGBE)</option>
                    <option value="openG">Open G (DGDGBD)</option>
                    <option value="DADGAD">DADGAD</option>
                    <option value="openE">Open E (EBEG#BE)</option>
                </select>
                <!-- Guide Tones Button Moved Here (Item 6) -->
                <button id="guide-tones-toggle" class="toggle-button" aria-label="Toggle guide tones">Guide Tones Off</button>
            </div>
            <div id="chord-fretboard" class="fretboard"></div>
        </div>
    </div>

    <div class="app-section" id="metronome-section">
        <h2>BeatForge Metronome</h2>
        <h3>Click to accent strong beats</h3>
        <div class="controls"> <!-- Main controls row -->
            <select id="time-signature" aria-label="Select time signature">
                <option value="2">2/4</option> <option value="3">3/4</option> <option value="4" selected>4/4</option>
                <option value="6">6/8</option> <option value="7">7/8</option> <option value="8">8/8</option> <option value="12">12/8</option>
            </select>
            <select id="sound-type" aria-label="Select metronome sound">
                <option value="click">Click</option> <option value="woodblock">Woodblock</option> <option value="drums">Drums</option>
            </select>
            <button id="drumSetToggleBtn" class="control-button" style="display: none;">Drums</button> <!-- Initially hidden, shown by JS -->
            <!-- Tempo controls remain here -->
            <input type="range" id="tempo" min="40" max="220" value="120" aria-label="Tempo">
            <span id="tempo-display">120 BPM</span>
            <button id="tap-tempo" aria-label="Tap tempo">Tap Tempo</button>
            <button id="start-stop" aria-label="Start or stop metronome">Start</button>
        </div>

        <!-- Vertically stacked volume controls -->
        <div id="metronome-volume-controls-stack">
            <div class="volume-control" id="metronome-master-volume-container">
                <span>Metronome Volume:</span>
                <input type="range" id="metronome-volume" min="0" max="1" step="0.1" value="0.25" aria-label="Metronome volume">
            </div>
            <div class="volume-control" id="kick-volume-container" style="display: none;">
                <label for="kick-volume">Kick Volume:</label>
                <input type="range" id="kick-volume" min="0" max="1" step="0.05" value="1.0" aria-label="Kick volume">
            </div>
            <div class="volume-control" id="snare-volume-container" style="display: none;">
                <label for="snare-volume">Snare Volume:</label>
                <input type="range" id="snare-volume" min="0" max="1" step="0.05" value="0.7" aria-label="Snare volume">
            </div>
            <div class="volume-control" id="hihat-volume-container" style="display: none;">
                <label for="hihat-volume">Hi-hat Volume:</label>
                <input type="range" id="hihat-volume" min="0" max="1" step="0.05" value="0.8" aria-label="Hi-hat volume">
            </div>
            <div class="volume-control" id="accent-intensity-container">
                <label for="accent-intensity">Accent Intensity:</label>
                <input type="range" id="accent-intensity" min="1" max="2" step="0.1" value="1.5" aria-label="Accent intensity">
            </div>
        </div>

        <div class="beats-container"></div>
    </div>

    <div class="app-section" id="chord-progression-section">
        <h2>Chord Progression Practice</h2>
        <!-- Original song info display location - content will be managed by JS to appear in fretboard section -->
        <div id="song-info-display" style="display: none;">
            <h4 id="current-song-title"></h4>
            <p id="current-song-description"></p>
        </div>
        <h3>Create a progression or pick one from the dropdown. Choose which key and scale to go with it.</h3>
        <div class="controls">
            <label for="progression-select">Select Progression:</label>
           <select id="progression-select" aria-label="Select chord progression">
                <option value="I V7">I-V7</option>
                <option value="jazz_blues">Jazz Blues</option>
                <option value="minor_blues">Minor Blues</option>
                <option value="rhythm_changes">Rhythm Changes (Standard)</option>
                <option value="rhythm_changes_bebop">Rhythm Changes (Bebop)</option>
                <option value="2_5_1">II-V-I</option>
                <option value="6_2_5_1">VI-II-V-I</option>
                <option value="minor_2_5_1">Minor iim-V7-im</option>
                <option value="dark_eyes">Dark Eyes</option>
                <option value="ill_see_you_in_my_dreams">I'll See You In My Dreams (Django)</option>
                <option value="ill_see_you_in_my_dreams_alternate">I'll See You In My Dreams (Django Alt.)</option>
                <option value="rose_room">Rose Room (Traditional)</option>
                <option value="rose_room_django">Rose Room (Django)</option>
                <option value="black_orpheus">Black Orpheus (Manh√£ de Carnaval)</option>
                <option value="all_the_things_you_are">All The Things You Are</option>
                <option value="all_of_me">All of Me</option>
                <option value="stella_by_starlight">Stella By Starlight</option>
                <option value="autumn_leaves">Autumn Leaves</option>
                <option value="summertime">Summertime</option>
                <option value="girl_from_ipanema">Girl From Ipanema (Authentic Bossa)</option>
                <option value="girl_from_ipanema_jazz">Girl From Ipanema (Jazz Variant)</option>
                <option value="coltrane_changes">Coltrane Changes (Giant Steps Cycle)</option>
                <option value="bird_blues">Bird Blues (Parker Blues)</option>
                <option value="just_friends">Just Friends</option>
                <option value="blue_bossa">Blue Bossa</option>
                <option value="on_green_dolphin_street">On Green Dolphin Street</option>
                <option value="solar">Solar</option>
                <option value="misty">Misty</option>
                <option value="days_of_wine_and_roses">Days of Wine and Roses</option>
                <option value="cherokee">Cherokee</option>
                <option value="caravan">Caravan</option>
                <option value="nows_the_time">Now's The Time (Parker F Blues)</option>
                <option value="tenor_madness">Tenor Madness (Rollins Bb Blues)</option>
            </select>
            <label for="keySelect">Select Key:</label>
            <select id="keySelect" aria-label="Select key">
              <option value="C">C</option> <option value="Cm">Cm</option> <option value="Db">Db</option> <option value="Dbm">Dbm</option> <option value="D">D</option> <option value="Dm">Dm</option> <option value="Eb">Eb</option> <option value="Ebm">Ebm</option> <option value="E">E</option> <option value="Em">Em</option> <option value="F">F</option> <option value="Fm">Fm</option> <option value="Gb">Gb</option> <option value="Gbm">Gbm</option> <option value="G">G</option> <option value="Gm">Gm</option> <option value="Ab">Ab</option> <option value="Abm">Abm</option> <option value="A">A</option> <option value="Am">Am</option> <option value="Bb">Bb</option> <option value="Bbm">Bbm</option> <option value="B">B</option> <option value="Bm">Bm</option>
            </select>
            <!-- Looping Button Moved Here (Item 5) -->
            <button id="loop-selected-toggle" class="toggle-button" aria-label="Toggle measure looping">Looping Off</button>
        </div>
        <div id="user-songs-section" class="controls">
            <label for="user-progression-select">Your Saved Songs:</label>
            <select id="user-progression-select" aria-label="Select your saved chord progression">
                <option value="">-- Select a saved song --</option>
            </select>
            <button id="delete-user-song-button" class="danger">Delete Selected Song</button>
        </div>

        <div id="measures"></div>

        <div class="controls">
            <button onclick="addMeasure()" aria-label="Add measure">Add Measure</button>
            <button onclick="removeMeasure()" aria-label="Remove measure">Remove Last Measure</button>
            <button id="save-progression-button" class="secondary" aria-label="Save current progression">Save Current Progression</button>
            <button id="chordsEnabled" class="toggle-button active">Chords Enabled</button>
        </div>
        <div class="volume-control">
            <label for="chord-volume">Chord Volume:</label>
            <input type="range" id="chord-volume" min="0" max="1" step="0.1" value="0.5" aria-label="Chord volume">
        </div>
        <div class="control-group">
              <label for="reverb-dial">Reverb</label>
              <input type="range" id="reverb-dial" min="0" max="100" value="20" style="width: 120px;">
              <span id="reverb-dial-value">20</span>%
         </div>
    </div>

<div class="app-section" id="fretflow-section">
    <h2>FretFlow</h2>
    <h3>Multiple scale workout</h3>
    <div class="fretboards-grid"></div>
</div>
    <div id="loading-indicator"></div> <!-- Added loading indicator div -->
    <script>
// ==================================
// === UTILITY FUNCTIONS ==========
// ==================================

/**
 * Logs a message to the console with a prefix.
 * @param {string} message - The message to log.
 */
function log(message) {
    console.log(`[Bebop Blueprint Debug] ${message}`);
}

/**
 * Updates and shows/hides a loading indicator.
 * @param {string} message - The message to display in the indicator.
 * @param {boolean} [isVisible=true] - Whether the indicator should be visible.
 */
function updateLoadingStatus(message, isVisible = true) {
    let i = document.getElementById('loading-indicator');
    if (!i) {
        i = document.createElement('div');
        i.id = 'loading-indicator';
        document.body.appendChild(i);
    }
    i.textContent = message;
    i.style.display = isVisible ? 'block' : 'none';
}

// ==================================
// === MUSICAL CONSTANTS ==========
// ==================================

const NOTES = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
const NOTES_CHROMATIC = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
const ALL_NOTES_FOR_SAMPLES = ["a", "as", "b", "c", "cs", "d", "ds", "e", "f", "fs", "g", "gs"];
const OCTAVES_FOR_SAMPLES = [2, 3, 4, 5];
const PLAYBACK_OCTAVES = [3, 4]; // Preferred octaves for chord playback
const FILE_FORMAT = "wav";

const SAMPLE_NOTE_MAP = {
  C: "c", Db: "cs", "C#": "cs", D: "d", Eb: "ds", "D#": "ds", E: "e", F: "f",
  Gb: "fs", "F#": "fs", G: "g", Ab: "gs", "G#": "gs", A: "a", Bb: "as", "A#": "as", B: "b",
  CS: "cs", DS: "ds", FS: "fs", GS: "gs", AS: "as",
};

const FRETBOARD_NOTES_OCTAVES = {
  string1: ["E4", "F4", "Fs4", "G4", "Gs4", "A4", "As4", "B4", "C5", "Cs5", "D5", "Ds5", "E5"],
  string2: ["B3", "C4", "Cs4", "D4", "Ds4", "E4", "F4", "Fs4", "G4", "Gs4", "A4", "As4", "B4"],
  string3: ["G3", "Gs3", "A3", "As3", "B3", "C4", "Cs4", "D4", "Ds4", "E4", "F4", "Fs4", "G4"],
  string4: ["D3", "Ds3", "E3", "F3", "Fs3", "G3", "Gs3", "A3", "As3", "B3", "C4", "Cs4", "D4"],
  string5: ["A2", "As2", "B2", "C3", "Cs3", "D3", "Ds3", "E3", "F3", "Fs3", "G3", "Gs3", "A3"],
  string6: ["E2", "F2", "Fs2", "G2", "Gs2", "A2", "As2", "B2", "C3", "Cs3", "D3", "Ds3", "E3"],
};

const SCALES = {
  major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10],
  harmonicMinor: [0, 2, 3, 5, 7, 8, 11], melodicMinor: [0, 2, 3, 5, 7, 9, 11],
  dorian: [0, 2, 3, 5, 7, 9, 10], phrygian: [0, 1, 3, 5, 7, 8, 10],
  lydian: [0, 2, 4, 6, 7, 9, 11], mixolydian: [0, 2, 4, 5, 7, 9, 10],
  locrian: [0, 1, 3, 5, 6, 8, 10], bebopDominant: [0, 2, 4, 5, 7, 9, 10, 11],
  bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11], bebopDorian: [0, 2, 3, 4, 5, 7, 9, 10],
  bebopPhrygian: [0, 1, 2, 3, 5, 7, 8, 10], altered: [0, 1, 3, 4, 6, 8, 10],
  lydianDominant: [0, 2, 4, 6, 7, 9, 10], diminishedWH: [0, 2, 3, 5, 6, 8, 9, 11],
  diminishedHW: [0, 1, 3, 4, 6, 7, 9, 10], wholeTone: [0, 2, 4, 6, 8, 10],
  pentatonicMajor: [0, 2, 4, 7, 9], pentatonicMinor: [0, 3, 5, 7, 10],
  blues: [0, 3, 5, 6, 7, 10], majorBlues: [0, 2, 3, 4, 7, 9],
  harmonicMajor: [0, 2, 4, 5, 7, 8, 11], doubleHarmonic: [0, 1, 4, 5, 7, 8, 11],
  enigmatic: [0, 1, 4, 6, 8, 10, 11], persian: [0, 1, 4, 5, 6, 8, 11],
  arabic: [0, 2, 4, 5, 6, 8, 10], japanese: [0, 2, 5, 7, 8],
  egyptian: [0, 2, 5, 7, 10],
};

const TUNINGS = {
  standard: ["E", "A", "D", "G", "B", "E"], // Low E to High E
  dropD:    ["D", "A", "D", "G", "B", "E"],
  openG:    ["D", "G", "D", "G", "B", "D"],
  DADGAD:   ["D", "A", "D", "G", "A", "D"],
  openE:    ["E", "B", "E", "Ab", "B", "E"],
};
// Note: TUNINGS were reversed in original code. For clarity, I'm keeping them low to high here
// and will adjust indexing in createFretboard/updateFretboard if needed, or reverse there.
// Let's stick to the convention of string 0 = low E for processing, string N-1 = high E.
// The `tuningArray[stringIndex]` will be used directly.

const CHORD_INTERVALS = {
  maj: [0, 4, 7], min: [0, 3, 7], dim: [0, 3, 6], aug: [0, 4, 8],
  sus4: [0, 5, 7], sus2: [0, 2, 7],
  maj7: [0, 4, 7, 11], dom7: [0, 4, 7, 10], min7: [0, 3, 7, 10],
  min7b5: [0, 3, 6, 10], dim7: [0, 3, 6, 9],
  maj6: [0, 4, 7, 9], min6: [0, 3, 7, 9],
  dom7b9: [0, 4, 7, 10, 1], // b9 is 1 semitone above root (e.g. C for C7b9 -> Db)
  "dom7#9": [0, 4, 7, 10, 3], // #9 is 3 semitones above root (e.g. C for C7#9 -> D#) - simplified
  dom7b5: [0, 4, 6, 10],
  alt: [0, 4, 1, 6, 10], // Common alt: Root, M3, b9, b5 (#11), b7. Simplified for now.
  dom7sus: [0, 5, 7, 10],
  maj9: [0, 4, 7, 11, 2], // M9 is 2 semitones (14-12) above root
  dom9: [0, 4, 7, 10, 2],
  min9: [0, 3, 7, 10, 2],
  imaj7: [0, 3, 7, 11],
  // Added for better parsing from progressions object if these exact strings are used
  "6": [0, 4, 7, 9], // Assume Maj6 if just "6"
  "m6": [0, 3, 7, 9], // Same as min6
  "6/9": [0, 4, 7, 9, 2], // Maj6 with added 9
  "7#11": [0, 4, 7, 10, 6], // Dom7 with #11 (6 semitones above root)
  "maj7#11": [0, 4, 7, 11, 6],
  "7b13": [0, 4, 7, 10, 8], // Dom7 with b13 (8 semitones above root)
  unknown: [0, 4, 7, 10],
};

const drumSoundSets = [
  { name: "Drums", snare: "Snare.wav", hihat: "HiHat.wav", kick: "Kick.wav" },
  { name: "Makaya", snare: "Snare2.wav", hihat: "HiHat2.wav", kick: "Kick2.wav" },
  { name: "PhillyJoe", kick: "jazzkick.wav", snare: "jazzsnare.wav", hihat: "jazzhat.wav" },
];

const progressions = { // From previous step, already includes user's specific versions
  "I V7": {
    defaultKey: "C",
    progression: ["Imaj7", "V7"],
    description: "A classic two-chord progression often used in jazz standards for a simple, elegant harmonic resolution.",
  },
  jazz_blues: {
    defaultKey: "Bb",
    progression: [
      "Bb7", "Eb7", "Bb7", "Bb7",
      "Eb7", "Eb7", "Bb7", "G7",
      "Cm7", "F7", "Bb7", "F7"
    ],
    description: "A swinging 12-bar blues with jazzy substitutions, perfect for improvisation and soulful melodies.",
  },
  minor_blues: {
    defaultKey: "Cm",
    progression: [
      "Cm7", "Cm7", "Cm7", "Cm7",
      "Fm7", "Fm7", "Cm7", "Cm7",
      "G7alt", "G7alt", "Cm7", "G7alt"
    ],
    description: "A moody minor blues progression with a melancholic vibe, ideal for expressive solos.",
  },
  rhythm_changes: { 
    defaultKey: "Bb",
    progression: [
      "Bbmaj7", "G7",    "Cm7",    "F7", "Bbmaj7", "G7",    "Cm7",    "F7",
      "Bbmaj7", "G7",    "Cm7",    "F7", "Bbmaj7", "Bb7",   "Ebmaj7", "Edim7",
      "Dm7",    "G7",    "Cm7",    "F7", "Bbmaj7", "F7", // Corrected progression from user (Cm7 F7, not Gm7 C7 -> Cm7 F7 F7 F7)
      "Bbmaj7", "G7",    "Cm7",    "F7", "Bbmaj7", "G7",    "Cm7",    "F7"
    ],
    description: "A fast-paced, iconic jazz structure based on Gershwin's 'I Got Rhythm,' great for bebop. This is the standard 32-bar AABA form with traditional changes."
  },
  rhythm_changes_bebop: { 
    defaultKey: "Bb",
    progression: [
      "Bbmaj7", "Bdim7", "Cm7",    "F7", "Dm7",    "G7",    "Cm7",    "F7",
      "Bbmaj7", "Bdim7", "Cm7",    "F7", "Dm7",    "Db7",   "Cm7",    "F7",
      "D7",     "D7",    "G7",     "G7", "C7",     "C7",    "F7",     "F7",
      "Bbmaj7", "Bdim7", "Cm7",    "F7", "Dm7",    "G7",    "Cm7",    "F7"
    ],
    description: "A bebop-oriented variation of Rhythm Changes with more sophisticated substitutions and a dominant cycle bridge, commonly used in jam sessions and bebop performances."
  },
  "2_5_1": {
    defaultKey: "C",
    progression: ["iim7", "V7", "Imaj7", "Imaj7"],
    description: "The quintessential jazz turnaround, providing a smooth and satisfying resolution.",
  },
  "6_2_5_1": {
    defaultKey: "C",
    progression: ["vim7", "iim7", "V7", "Imaj7"],
    description: "An extended version of the 2-5-1, starting on the vi minor for a richer harmonic journey.",
  },
  minor_2_5_1: {
    defaultKey: "Cm",
    progression: ["iim7b5", "V7alt", "imaj7"],
    description: "A dramatic minor key progression, often used for intense and emotional resolutions.",
  },
  dark_eyes: { 
    defaultKey: "Dm",
    progression: [
      "Dm", "Dm", "A7", "A7", "A7", "A7", "Dm", "Dm",
      "Gm", "Gm", "Dm", "Dm", "A7", "A7", "Dm", "Dm"
    ],
    description: "A passionate, Gypsy jazz-inspired progression with a fiery, Eastern European flair.",
  },
  ill_see_you_in_my_dreams: { 
    defaultKey: "Bb",
    progression: [
      "Bbmaj6", "Bbmaj6", "Bbmin6", "Bbmin6", "Fmaj6",  "E7",     "Fmaj6",  "Fmaj6",
      "F7",     "F7",     "Bb7",    "Bb7",    "Eb7",    "Eb7",    "Ab7",    "Ab7",
      "Bbmaj6", "Bbmaj6", "Bbmin6", "Bbmin6", "Fmaj6",  "E7",     "Bbmaj6", "G7",
      "Cm7",    "F7",     "Bbmaj6", "Bbmaj6", "Eb7",    "D7",     "Gm7",    "C7",
      "Fmaj6",  "F7",     "Bbmaj6", "Bbmaj6"
    ],
    description: "The authentic Django Reinhardt / Gypsy Jazz arrangement of this classic, featuring characteristic 6th chords, dominant sequences, and the traditional Bb key favored by Django."
  },
  ill_see_you_in_my_dreams_alternate: { 
    defaultKey: "Bb",
    progression: [
      "Bbmaj6", "G7",     "Cm7",    "F7",     "Bbmaj6", "Bbmin6", "Fmaj6",  "F7",
      "Bbmaj6", "D7",     "Gm7",    "C7",     "Fmaj6",  "F#dim7", "Bbmaj6", "F7",
      "Bbmaj6", "G7",     "Cm7",    "F7",     "Bbmaj6", "Bbmin6", "Fmaj6",  "F7",
      "Bbmaj6", "D7",     "Gm7",    "C7",     "Fmaj6",  "F7",     "Bbmaj6", "Bbmaj6"
    ],
    description: "An alternate Django-style arrangement featuring both the characteristic 6th chords and the passing diminished chords often used in Gypsy jazz interpretations."
  },
  rose_room: { 
    defaultKey: "Bb",
    progression: [
      "Bb7",    "Eb7",    "Abmaj7", "Abmaj7", "Bb7",    "Eb7",    "Abmaj7", "Abmaj7",
      "Bb7",    "Eb7",    "Abmaj7", "Abmaj7", "Cm7",    "F7",     "Bbmaj7", "Bbmaj7",
      "Dbmaj7", "Dbmaj7", "Abmaj7", "Abmaj7", "Bbm7",   "Eb7",    "Abmaj7", "Abmaj7",
      "Bb7",    "Eb7",    "Abmaj7", "Fm7",    "Bbm7",   "Eb7",    "Abmaj7", "Eb7"
    ],
    description: "The authentic 'Rose Room' progression featuring the classic I-IV-I pattern that opens the tune, with the traditional harmonization favored by swing and early jazz players."
  },
  rose_room_django: { 
    defaultKey: "Bb",
    progression: [
      "Bb7",    "Eb7",    "Abmaj6", "Abmaj6", "Bb7",    "Eb7",    "Abmaj6", "Abmaj6",
      "Bb7",    "Eb7",    "Abmaj6", "F7",     "Bb7",    "Eb7",    "Abmaj6", "Eb7",
      "Dbmaj6", "Abdim7", "Abmaj6", "F7",     "Bb7",    "Eb7",    "Abmaj6", "Eb7",
      "Bb7",    "Eb7",    "Abmaj6", "F7",     "Bb7",    "Eb7",    "Abmaj6", "Abmaj6"
    ],
    description: "A Django Reinhardt-influenced version of 'Rose Room' with characteristic Gypsy jazz voicings and substitutions that Django often employed."
  },
  black_orpheus: { 
    defaultKey: "Am",
    progression: [
      "Am6",  "Am6/G", "F#m7b5","B7b9", "Em7",  "A7",    "Dm7",   "G7",
      "Cmaj7","Fmaj7", "Bm7b5", "E7alt","Am6",  "E7alt", "Am6",   "A7",
      "Dm7",  "G7",    "Cmaj7", "Fmaj7","Bm7b5","E7alt", "Am6",   "Am6"
    ],
    description: "A bossa nova classic with a haunting minor key, inspired by Brazilian rhythms."
  },
  all_the_things_you_are: { 
    defaultKey: "Ab",
    progression: [
      "Fm7",    "Bbm7",   "Eb7",    "Abmaj7", "Dbmaj7", "G7",     "Cmaj7",  "Cmaj7",
      "Cm7",    "Fm7",    "Bb7",    "Ebmaj7", "Abmaj7", "D7",     "Gmaj7",  "Gmaj7",
      "Am7",    "D7",     "Gmaj7",  "Gmaj7",  "F#m7",   "B7",     "Emaj7",  "C7alt",
      "Fm7",    "Bbm7",   "Eb7",    "Abmaj7", "Dbmaj7", "Gb7",    "Cmaj7",  "Bm7 E7"
    ],
    description: "A harmonically complex standard with shifting keys, beloved in jazz for its beauty.",
  },
  all_of_me: { 
    defaultKey: "C",
    progression: [
      "Cmaj7", "E7",    "A7",    "Dm7",    "E7",    "Am7",   "D7",    "Dm7 G7",
      "Cmaj7", "E7",    "A7",    "Dm7",    "Fmaj7", "Fm6",   "Cmaj7", "A7",
      "Dm7",   "G7",    "Cmaj7", "(G7)"
    ],
    description: "A cheerful, upbeat standard with a catchy progression, great for vocal jazz.",
  },
  stella_by_starlight: { 
    defaultKey: "Bb",
    progression: [
      "Em7b5", "A7alt",  "Cm7",    "F7",     "Fm7",   "Bb7",    "Ebmaj7", "Abmaj7",
      "Dm7b5", "G7alt",  "Cmaj7",  "Cmaj7",  "Em7b5", "A7alt",  "Dm7",    "Dm7",
      "Dm7b5", "G7alt",  "Cm7",    "F7",     "Bbmaj7","Bbmaj7", "Em7b5",  "A7alt",
      "Dm7",   "G7alt",  "Cmaj7",  "F#7alt", "Fm7",   "Bb7",    "Ebmaj7", "Ebmaj7"
    ],
    description: "A lush, cinematic progression with a romantic and introspective feel. This is the complete 32-bar form used in most Real Books.",
  },
  autumn_leaves: { 
    defaultKey: "Bb",
    progression: [
      "Cm7",   "F7",    "Bbmaj7", "Ebmaj7", "Am7b5", "D7alt", "Gm7",    "Gm7",
      "Cm7",   "F7",    "Bbmaj7", "Ebmaj7", "Am7b5", "D7alt", "Gm7",    "G7alt",
      "Cm7",   "F7",    "Bbmaj7", "Ebmaj7", "Am7b5", "D7alt", "Gm7",    "Gm7"
    ],
    description: "A melancholic jazz standard evoking falling leaves and wistful nostalgia."
  },
  summertime: { 
    defaultKey: "Am",
    progression: [
      "Am7", "Am7", "E7",  "E7",  "Am7", "Am7", "Dm7", "Am7",
      "Dm7", "Am7", "E7",  "Am7", "E7"
    ],
    description: "A sultry, soulful progression from Gershwin's opera, perfect for laid-back grooves.",
  },
  girl_from_ipanema: { 
    defaultKey: "F",
    progression: [
      "Fmaj7",  "Fmaj7",  "G7#11", "G7#11",  "Gm7",    "Gb7",    "Fmaj7", "Fmaj7",
      "Fmaj7",  "Fmaj7",  "G7#11", "G7#11",  "Gm7",    "C7",     "Am7",   "D7b9",
      "Gbmaj7", "Gbmaj7", "A7",    "A7",     "Abm7",   "Db7",    "Gbmaj7","E7b13",
      "Fmaj7",  "Fmaj7",  "G7#11", "G7#11",  "Gm7",    "C7",     "Fmaj7", "F6/9"
    ],
    description: "The authentic bossa nova classic by Antonio Carlos Jobim with the traditional modulation and voicings used in professional performances."
  },
  girl_from_ipanema_jazz: { 
    defaultKey: "F",
    progression: [
      "Fmaj7",  "D7alt",  "Gm9",    "C13",    "Am9",    "D7b9",   "Gm9",    "C13",
      "Fmaj7",  "D7alt",  "Gm9",    "C13",    "Am9",    "D7b9",   "Gm9",    "C13",
      "F#maj7", "F#maj7", "B13",    "B13",    "C#m9",   "F#13",   "Bmaj7",  "E7alt",
      "Fmaj7",  "D7alt",  "Gm9",    "C13",    "Am9",    "D7b9",   "Gm9",    "C13",
      "Fmaj7",  "Bb9",    "Em7b5",  "A7alt",  "Dm9",    "G13",    "Fmaj7",  "F6/9"
    ],
    description: "A jazzier interpretation of 'Girl From Ipanema' with extended harmonies and additional substitutions commonly used by jazz musicians."
  },
  coltrane_changes: { 
    defaultKey: "C",
    progression: [
      "Cmaj7",  "Eb7",   "Abmaj7", "Db7",  "Gbmaj7", "A7",    "Dmaj7",  "F#7",
      "Bmaj7",  "D7",    "Gmaj7",  "Bb7",  "Ebmaj7", "Gb7",   "Cbmaj7", "E7"
    ],
    description: "A challenging, innovative progression from John Coltrane, with rapid key shifts.",
  },
  bird_blues: { 
    defaultKey: "F",
    progression: [
      "Fmaj7",  "Em7b5 A7alt", "Dm7 G7alt", "Cm7 F7",       "Bbmaj7", "Bbm7 Eb7",
      "Am7 D7alt", "Abm7 Db7",  "Gm7",    "C7alt",       "Fmaj7 D7alt", "Gm7 C7alt"
    ],
    description: "A bebop blues progression inspired by Charlie Parker, full of energy and drive.",
  },
  just_friends: { 
    defaultKey: "G",
    progression: [
      "Gmaj7", "B7",    "Em7", "A7",  "Am7",   "D7",    "Gmaj7", "D7",
      "Gmaj7", "B7",    "Em7", "A7",  "Am7",   "D7",    "Gmaj7", "Gmaj7",
      "Cmaj7", "Cm7",   "Gmaj7", "E7",  "Am7",   "D7",    "Gmaj7", "D7",
      "Gmaj7", "B7",    "Em7", "A7",  "Am7",   "D7",    "Gmaj7", "Gmaj7"
    ],
    description: "A lively, upbeat standard with a playful harmonic structure, great for swing.",
  },
  blue_bossa: { 
    defaultKey: "Cm",
    progression: [
      "Cm7",  "Cm7",  "Fm7",  "Fm7",   "Dm7b5","G7alt","Cm7",  "Cm7",
      "Ebm7", "Ab7",  "Dbmaj7","Dbmaj7","Dm7b5","G7alt","Cm7",  "(G7alt)"
    ],
    description: "A cool, Latin-jazz progression with a relaxed yet groovy bossa nova feel.",
  },
  on_green_dolphin_street: { 
    defaultKey: "C",
    progression: [
      "Cmaj7", "Cmaj7", "Cm7",   "F7",     "Bbmaj7","Bbmaj7","Am7b5", "D7alt",
      "Gm7",   "Gm7",   "Gbm7",  "B7",     "Emaj7", "Emaj7", "Dm7",   "G7alt",
      "Cmaj7"
    ],
    description: "A modal, cinematic progression with a mysterious and captivating atmosphere.",
  },
  solar: { 
    defaultKey: "Cm",
    progression: [
      "Cm(maj7)", "Cm(maj7)", "Gm7b5", "C7alt", "Fmaj7",    "Fmaj7",    "Fm7",   "Bb7",
      "Ebmaj7",   "Ebmaj7",   "Am7b5", "D7alt", "Gm7",      "C7alt",    "Fmaj7"
    ],
    description: "A contemplative, Miles Davis original with a flowing, introspective harmonic line.",
  },
  misty: { 
    defaultKey: "Eb",
    progression: [
      "Ebmaj7", "Bbm7",  "Eb7",   "Abmaj7", "Abm7",   "Db7",   "Ebmaj7","Cm7",
      "Fm7",    "Bb7",   "Gm7",   "C7alt",  "Fm7",    "Bb7",   "Ebmaj7","(Fm7 Bb7)"
    ],
    description: "A tender, romantic ballad progression, evoking misty-eyed sentimentality.",
  },
  days_of_wine_and_roses: { 
    defaultKey: "F",
    progression: [
      "Fmaj7", "Dm7",  "Gm7",   "C7",     "Am7",   "Dm7",  "Gm7",   "C7",
      "Fmaj7", "Dm7",  "Gm7",   "C7",     "Am7",   "Dm7",  "Gm7",   "C7",
      "Fmaj7", "Ab7",  "Gm7",   "C7",     "Am7",   "D7",   "Gm7",   "C7",
      "Dm7",   "G7",   "Cm7",   "F7",     "Bbmaj7","Bbm6", "Fmaj7", "C7"
    ],
    description: "A bittersweet, elegant progression with a waltzing, reflective quality."
  },
  cherokee: { 
    defaultKey: "Bb",
    progression: [ 
      "Bbmaj7", "Bbmaj7","Bbmaj7", "Bbmaj7", "Cm7",    "F7",    "Bbmaj7", "Bbmaj7",
      "Bbmaj7", "Bbmaj7","Bbmaj7", "Bbmaj7", "Cm7",    "F7",    "Bbmaj7", "Bbmaj7",
      "Bmaj7",  "Bmaj7", "Emaj7",  "Emaj7",  "Amaj7",  "Amaj7", "Dmaj7",  "Dmaj7",
      "Gmaj7",  "Gmaj7", "Cmaj7",  "Cmaj7",  "Fmaj7",  "Fmaj7", "Bb7",    "Bb7",
      "Bbmaj7", "Bbmaj7","Bbmaj7", "Bbmaj7", "Cm7",    "F7",    "Bbmaj7", "Bbmaj7"
    ],
    description: "A high-energy bebop standard with a fast-moving, adventurous harmonic structure.",
  },
  caravan: { 
    defaultKey: "Fm",
    progression: [ 
      "Fm7", "Fm7", "Fm7", "C7b9", "Fm7", "Fm7", "C7b9","Fm7",
      "Abmaj7","Abmaj7","Dbmaj7","Dbmaj7","Gm7b5", "C7b9",  "Fm7",   "Fm7"
    ],
    description: "An exotic, Latin-tinged progression with a hypnotic, caravan-like rhythm.",
  },
  nows_the_time: { 
    defaultKey: "F",
    progression: [ 
      "F7", "Bb7", "F7", "F7", "Bb7","Bb7", "F7", "D7alt",
      "Gm7","C7",  "F7", "(Gm7 C7)"
    ],
    description: "A gritty, straightforward blues progression by Charlie Parker, full of soul.",
  },
  tenor_madness: { 
    defaultKey: "Bb",
    progression: [ 
      "Bb7", "Eb7", "Bb7", "Bb7", "Eb7", "Eb7", "Bb7", "G7alt",
      "Cm7", "F7",  "Bb7", "(Cm7 F7)"
    ],
    description: "A hard-swinging blues progression, ideal for fiery tenor sax battles.",
  },
};

// ==================================
// === APPLICATION STATE ==========
// ==================================
const AppState = {
    isPlaying: false,
    currentBeat: 0,
    currentMeasure: 0,
    tempo: 120,
    audioInitialized: false,
    intervalId: null,
    lastTapTime: 0,
    tapTempoTimestamps: [],
    guideTonesActive: false,
    loopingActive: false,
    loopStartMeasure: -1,
    loopEndMeasure: -1,
    listeners: [], // For potential future state listeners

    /**
     * Updates the application state and notifies listeners.
     * @param {object} newState - An object containing new state properties.
     */
    updateState(newState) {
        Object.assign(this, newState);
        this.notifyListeners();
    },

    /**
     * Adds a listener callback to be notified of state changes.
     * @param {function} callback - The callback function.
     */
    addListener(callback) {
        this.listeners.push(callback);
    },

    /**
     * Notifies all registered listeners of a state change.
     */
    notifyListeners() {
        this.listeners.forEach(callback => callback(this));
    }
};

let currentFunctionalProgression = []; // Stores the raw progression strings (Roman or absolute) for the current song
let currentProgressionName = "";       // Name/key of the currently loaded song
let currentDrumSetIndex = 0;

// ==================================
// === UI MANAGEMENT & DOM ELEMENTS ===
// ==================================
const UI = {
    elements: {}, // To be populated by UI.init()

    /**
     * Caches references to frequently used DOM elements.
     */
    init() {
        this.elements = {
            // Main Sections & Containers
            chordFretboardSection: document.getElementById('chord-fretboard-section'),
            metronomeSection: document.getElementById('metronome-section'),
            chordProgressionSection: document.getElementById('chord-progression-section'),
            fretflowSection: document.getElementById('fretflow-section'),
            measures: document.getElementById('measures'),
            fretboardsGrid: document.querySelector('.fretboards-grid'),
            
            // Chord Fretboard Area
            chordFretboard: document.getElementById('chord-fretboard'),
            chordFretboardVolume: document.getElementById('chord-fretboard-volume'),
            chordTuning: document.getElementById('chord-tuning'),
            scaleDisplay: document.getElementById('scale-display'),
            nextChordDisplay: document.getElementById('next-chord-display'),
            currentSongTitleFretboard: document.getElementById('current-song-title-fretboard'),
            currentSongDescriptionFretboard: document.getElementById('current-song-description-fretboard'),
            guideTonesToggle: document.getElementById('guide-tones-toggle'),

            // Metronome Area
            timeSignature: document.getElementById('time-signature'),
            soundType: document.getElementById('sound-type'),
            drumSetToggleBtn: document.getElementById('drumSetToggleBtn'),
            tempo: document.getElementById('tempo'),
            tempoDisplay: document.getElementById('tempo-display'),
            tapTempo: document.getElementById('tap-tempo'),
            startStopButton: document.getElementById('start-stop'),
            metronomeVolumeControlsStack: document.getElementById('metronome-volume-controls-stack'),
            metronomeVolume: document.getElementById('metronome-volume'),
            kickVolumeContainer: document.getElementById('kick-volume-container'),
            kickVolume: document.getElementById('kick-volume'),
            snareVolumeContainer: document.getElementById('snare-volume-container'),
            snareVolume: document.getElementById('snare-volume'),
            hihatVolumeContainer: document.getElementById('hihat-volume-container'),
            hihatVolume: document.getElementById('hihat-volume'),
            accentIntensity: document.getElementById('accent-intensity'),
            beatsContainer: document.querySelector('.beats-container'),

            // Chord Progression Area
            progressionSelect: document.getElementById('progression-select'),
            keySelect: document.getElementById('keySelect'),
            loopSelectedToggle: document.getElementById('loop-selected-toggle'),
            userProgressionSelect: document.getElementById('user-progression-select'),
            deleteUserSongButton: document.getElementById('delete-user-song-button'),
            saveProgressionButton: document.getElementById('save-progression-button'),
            chordsEnabled: document.getElementById('chordsEnabled'),
            chordVolume: document.getElementById('chord-volume'),
            reverbDial: document.getElementById('reverb-dial'),
            reverbDialValue: document.getElementById('reverb-dial-value'),
            // Original song info (kept for potential internal logic, but hidden from main display)
            // currentSongTitle: document.getElementById('current-song-title'),
            // currentSongDescription: document.getElementById('current-song-description'),

            // General UI
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            loadingIndicator: document.getElementById('loading-indicator'),
        };

        // Verify all elements were found (optional, for debugging)
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element && key !== 'currentSongTitle' && key !== 'currentSongDescription') { // Allow these to be missing if truly removed from HTML
                 console.warn(`[UI Init] Missing DOM element: ${key}`);
            }
        });
        log("UI elements cached.");
    }
};

// ==================================
// === MUSIC THEORY HELPERS =======
// ==================================

/**
 * Standardizes a note name (e.g., C#, Db, Dbb).
 * @param {string} note - The note name string.
 * @returns {string} The standardized note name (e.g., Db).
 */
function standardizeNoteName(note) {
    if (!note || typeof note !== 'string') return '';
    let standardized = note.toUpperCase().trim().replace('‚ô≠', 'b').replace('‚ôØ', '#');
    
    // Handle double flats/sharps first by reducing them
    while (standardized.includes("BB")) standardized = standardized.replace("BB", "A"); // Bbb -> A
    while (standardized.includes("E##")) standardized = standardized.replace("E##", "F#"); // E## -> F# -> Gb
    while (standardized.includes("B##")) standardized = standardized.replace("B##", "C#"); // B## -> C# -> Db
    // Add more double sharp/flat to single equivalent if needed.

    const sharpToFlatMap = { 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb' };
    if (sharpToFlatMap[standardized]) {
        return sharpToFlatMap[standardized];
    }
    // Ensure it's one of the 12 canonical flat/natural names if possible
    const foundNote = NOTES.find(n => n.toUpperCase() === standardized.toUpperCase());
    return foundNote || standardized; // Fallback to input if not found (e.g. already standard or complex like "Fb")
}

/**
 * Converts a musical note name to the format used for audio samples.
 * @param {string} note - The musical note name (e.g., "Db", "C#").
 * @returns {string} The note name for sample lookup (e.g., "cs").
 */
function standardizeNoteNameForSamples(note) {
    const stdNote = standardizeNoteName(note);
    return SAMPLE_NOTE_MAP[stdNote] || SAMPLE_NOTE_MAP[note.toUpperCase()] || note.toLowerCase();
}

/**
 * Parses a raw chord quality string and returns a standardized quality string.
 * Attempts to identify base qualities even if extensions are present.
 * @param {string} rawQualityInput - The raw quality string (e.g., "m7", "7b9", "maj7#11", "6/9").
 * @returns {string} The standardized quality string (e.g., "min7", "dom7b9", "maj7", "maj6").
 */
function getStandardQuality(rawQualityInput) {
    if (!rawQualityInput || typeof rawQualityInput !== 'string') return 'maj7'; // Default quality

    let quality = rawQualityInput.toLowerCase().trim();
    quality = quality.split('/')[0].trim(); // Remove slash chord bass note for quality parsing (e.g., "m6/G" -> "m6")

    // Prioritize specific extended/altered chords that have dedicated entries
    if (quality === 'alt' || quality === '7alt') return 'alt';
    if (quality === '7b9' || quality === 'dom7b9') return 'dom7b9';
    if (quality === '7#9' || quality === 'dom7#9') return 'dom7#9';
    if (quality === '7b5' || quality === 'dom7b5') return 'dom7b5';
    if (quality === '7sus' || quality === '7sus4' || quality === 'dom7sus') return 'dom7sus';
    if (quality === 'imaj7' || quality === 'm(maj7)' || quality === 'minmaj7' || quality === 'mmaj7') return 'imaj7';
    
    // Check for common 7th chord qualities (maj7, 7 (dom), m7, m7b5, dim7)
    if (quality === 'maj7' || quality === 'ma7' || quality === 'Œî' || quality.startsWith('maj7') || quality.startsWith('ma7')) return 'maj7';
    if (quality === '7' || quality === 'dom7' || quality === 'dom' || (quality.startsWith('7') && !quality.startsWith('7b') && !quality.startsWith('7#') && !quality.startsWith('7s'))) return 'dom7';
    if (quality === 'm7' || quality === 'min7' || quality === 'mi7' || quality.startsWith('m7') || quality.startsWith('min7')) return 'min7';
    if (quality === 'm7b5' || quality === 'min7b5' || quality === '√∏' || quality === 'mi7b5' || quality.startsWith('m7b5')) return 'min7b5';
    if (quality === 'dim7' || quality === '¬∞7' || (quality.startsWith('dim') && quality.includes('7'))) return 'dim7';
    
    // Check for 6th chords (maj6, m6, 6/9)
    if (quality === 'maj6' || quality === 'ma6' || quality === '6' || quality.startsWith('maj6') || quality.startsWith('ma6')) return 'maj6'; // "6" defaults to maj6
    if (quality === 'm6' || quality === 'min6' || quality === 'mi6' || quality.startsWith('m6') || quality.startsWith('min6')) return 'min6';
    if (quality === '6/9' || quality.startsWith('6/9')) return 'maj6'; // Play as maj6, 9th is an extension for voicing

    // Check for basic triads (maj, min, dim, aug, sus)
    if (quality === 'maj' || quality === '') return 'maj'; // Empty quality implies major triad
    if (quality === 'm' || quality === 'min' || quality === 'mi') return 'min';
    if (quality === 'dim' || quality === '¬∞') return 'dim';
    if (quality === 'aug' || quality === '+') return 'aug';
    if (quality === 'sus4' || quality === 'sus') return 'sus4';
    if (quality === 'sus2') return 'sus2';

    // Fallback if complex or already a direct key in CHORD_INTERVALS
    if (CHORD_INTERVALS[rawQualityInput]) return rawQualityInput; // E.g. if "dom9" was passed
    if (CHORD_INTERVALS[quality]) return quality; // E.g. if "dom9" resulted after lowercasing

    console.warn(`getStandardQuality: Unstandardized quality "${rawQualityInput}". Defaulting to 'maj7'.`);
    return 'maj7';
}


/**
 * Parses a chord string (e.g., "Cmaj7", "F#m7b5") into its root and quality.
 * @param {string} chordString - The chord string to parse.
 * @returns {object|null} An object {root, quality, originalString} or null if parsing fails.
 */
function parseChord(chordString) {
    if (typeof chordString !== 'string' || !chordString.trim()) {
        return null;
    }
    chordString = chordString.trim();
    // Regex to capture root note (A-G with optional # or b) and the rest as quality string.
    // It's greedy for the quality part.
    const match = chordString.match(/^([A-G][#b]?)(.*)$/);
    if (!match) {
        return null;
    }
    const root = standardizeNoteName(match[1]);
    const qualityString = match[2].trim(); // e.g., "maj7", "m7b5", "7#11", "6/9"
    const quality = getStandardQuality(qualityString); // Let getStandardQuality figure out the base playable quality

    return { root: root, quality: quality, originalString: chordString };
}

/**
 * Parses a Roman numeral string (or an absolute chord string) in a given key
 * into an absolute chord (root and quality).
 * @param {string} romanString - The Roman numeral string (e.g., "Im7", "V7/ii") or an absolute chord ("Cmaj7").
 * @param {string} key - The current key (e.g., "C", "Gm").
 * @returns {object} An object {root, quality, originalRoman}.
 */
function parseRomanNumeralToAbsoluteChord(romanString, key) {
    const isMinorKey = key.includes('m');
    const normalizedKeyRoot = standardizeNoteName(key.replace('m', ''));
    const keyRootIndex = NOTES_CHROMATIC.indexOf(normalizedKeyRoot);

    if (keyRootIndex === -1) {
        console.error(`Invalid key for Roman numeral parsing: ${key}`);
        return { root: 'C', quality: 'maj7', originalRoman: romanString }; // Fallback
    }

    const firstChordInSplit = romanString.split('/')[0].trim(); // Handle "Cmaj7/G7" -> "Cmaj7"
    const absoluteChordAttempt = parseChord(firstChordInSplit);

    if (absoluteChordAttempt && absoluteChordAttempt.root && CHORD_INTERVALS[absoluteChordAttempt.quality]) {
        return { ...absoluteChordAttempt, originalRoman: romanString };
    }

    const romanMatch = firstChordInSplit.match(/^(b|#)?([IViv]+)(.*)$/);
    if (!romanMatch) {
        console.warn(`Could not parse Roman numeral or absolute chord: "${firstChordInSplit}" in key ${key}. Assuming Imaj7 of key.`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }

    const accidental = romanMatch[1];
    const numeral = romanMatch[2];
    let qualitySuffix = romanMatch[3].trim();

    const majorScaleIntervals = { 'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11 };
    const minorScaleIntervals = { 'i': 0, 'ii': 2, 'III': 3, 'iv': 5, 'v': 7, 'VI': 8, 'VII': 10 };

    let degreeInterval;
    const isUpperCaseNumeral = numeral === numeral.toUpperCase();

    if (isMinorKey) {
        degreeInterval = minorScaleIntervals[numeral.toLowerCase()];
        if (isUpperCaseNumeral && numeral.toLowerCase() === 'v') degreeInterval = majorScaleIntervals['V'];
        if (isUpperCaseNumeral && numeral.toLowerCase() === 'iv') degreeInterval = majorScaleIntervals['IV'];
    } else {
        degreeInterval = majorScaleIntervals[numeral.toUpperCase()];
    }

    if (degreeInterval === undefined) {
        console.warn(`Unknown Roman numeral base: ${numeral} in "${firstChordInSplit}". Assuming I of key.`);
        return { root: normalizedKeyRoot, quality: 'maj7', originalRoman: romanString };
    }

    let chordRootIndex = (keyRootIndex + degreeInterval) % 12;
    if (accidental === 'b') chordRootIndex = (chordRootIndex - 1 + 12) % 12;
    else if (accidental === '#') chordRootIndex = (chordRootIndex + 1) % 12;
    
    const chordRoot = NOTES_CHROMATIC[chordRootIndex];
    let finalQuality = getStandardQuality(qualitySuffix); // Try to parse suffix first

    if (!qualitySuffix) { // If no suffix, infer from numeral case and key type
        if (numeral.toLowerCase() === 'v' && (isMinorKey || !qualitySuffix)) {
            finalQuality = 'dom7';
        } else if (numeral.toLowerCase() === 'vii' && !isUpperCaseNumeral) {
            finalQuality = 'min7b5';
        } else {
            finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7';
        }
    } else if (!CHORD_INTERVALS[finalQuality]) { // Suffix was present but not fully parsed by getStandardQuality
         // This case should be less frequent if getStandardQuality is robust
        console.warn(`Quality suffix "${qualitySuffix}" for Roman ${firstChordInSplit} not fully resolved. Defaulting based on numeral.`);
        finalQuality = isUpperCaseNumeral ? 'maj7' : 'min7';
    }


    return { root: chordRoot, quality: finalQuality, originalRoman: romanString };
}

/**
 * Gets the constituent notes of a chord.
 * @param {string} root - The root note of the chord.
 * @param {string} quality - The quality of the chord (e.g., "maj7", "min7").
 * @returns {string[]} An array of note names in the chord.
 */
function getChordNotes(root, quality) {
    let intervals = CHORD_INTERVALS[quality];
    if (!intervals) {
        console.warn(`Quality "${quality}" for root "${root}" not found. Defaulting to dom7 intervals.`);
        intervals = CHORD_INTERVALS['dom7'];
    }
    const standardizedRoot = standardizeNoteName(root);
    const rootIndex = NOTES.indexOf(standardizedRoot);
    if (rootIndex === -1) {
        console.error(`Invalid root note for getChordNotes: ${root}`);
        return [standardizedRoot];
    }
    // Ensure intervals are taken from root 0
    return intervals.map(interval => NOTES[(rootIndex + interval + 12) % 12]);
}

/**
 * Suggests a scale for a given chord quality.
 * @param {string} quality - The chord quality.
 * @returns {string} The name of the suggested scale.
 */
function suggestScaleForQuality(quality) {
    const scaleMap = {
        'maj7': 'major', 'maj': 'major', 'maj6': 'major', 'maj9': 'major',
        'dom7': 'mixolydian', 'dom9': 'mixolydian', 'dom7b9': 'diminishedWH',
        'dom7#9': 'altered', 'alt': 'altered', 'dom7sus': 'mixolydian',
        'min7': 'dorian', 'min': 'dorian', 'min9': 'dorian', 'min6': 'dorian',
        'min7b5': 'locrian', 'dim7': 'diminishedWH',
        'imaj7': 'melodicMinor',
    };
    return scaleMap[quality] || 'major'; // Default to major
}

// ==================================
// === CHORD VOICING HELPERS ======
// ==================================

/**
 * Generates various inversions for a given set of chord notes.
 * @param {string[]} baseNotes - Array of note names in root position.
 * @returns {string[][]} An array of voicings.
 */
function generateInversions(baseNotes) {
    const voicings = [];
    voicings.push([...baseNotes]); 
    for (let i = 1; i < baseNotes.length; i++) {
        voicings.push([...baseNotes.slice(i), ...baseNotes.slice(0, i)]);
    }
    return voicings;
}

/**
 * Attempts to create a drop 2 voicing for a 4-note chord.
 * @param {string[]} rootPositionNotes - Chord notes in root position.
 * @returns {string[]|null} The drop 2 voiced notes, or null if not applicable.
 */
function generateDrop2Voicing(rootPositionNotes) {
    if (rootPositionNotes.length !== 4) return null;
    return [ rootPositionNotes[0], rootPositionNotes[2], rootPositionNotes[3], rootPositionNotes[1] ];
}

/**
 * Selects a voicing for the chord.
 * @param {string[]} baseNotesInRootPosition - Chord notes in root position.
 * @param {string} quality - The chord quality.
 * @returns {string[]} The selected array of note names for the voicing.
 */
function getChordVoicing(baseNotesInRootPosition, quality) {
    let potentialVoicings = [];
    const simpleInversions = generateInversions(baseNotesInRootPosition);
    potentialVoicings.push(...simpleInversions);

    if (baseNotesInRootPosition.length === 4) {
        if (Math.random() < 0.25) { // 25% chance for drop 2
            const drop2 = generateDrop2Voicing(baseNotesInRootPosition);
            if (drop2) potentialVoicings.push(drop2);
        }
        if (Math.random() < 0.10) { // 10% chance for "wide" voicing
            potentialVoicings.push([ baseNotesInRootPosition[0], baseNotesInRootPosition[3], baseNotesInRootPosition[1], baseNotesInRootPosition[2] ]);
        }
    }
    return potentialVoicings[Math.floor(Math.random() * potentialVoicings.length)];
}

// ==================================
// === DOM UTILITIES & UI UPDATERS ==
// ==================================

/**
 * Creates HTML option elements for keys.
 * @param {string} [selectedKey='C'] - The key to be pre-selected.
 * @returns {string} HTML string of option elements.
 */
function createKeyOptions(selectedKey = 'C') {
    return NOTES.map(note =>
        `<option value="${note}"${note === standardizeNoteName(selectedKey) ? ' selected' : ''}>${note}</option>`
    ).join('');
}

/**
 * Creates HTML option elements for chord qualities.
 * @param {string} [selectedQuality='maj7'] - The quality to be pre-selected.
 * @returns {string} HTML string of option elements.
 */
function createQualityOptions(selectedQuality = 'maj7') {
    const qualityDisplayOrder = [
        { value: 'maj7', label: 'maj7' }, { value: 'dom7', label: '7' }, { value: 'min7', label: 'm7' },
        { value: 'min7b5', label: 'm7b5' }, { value: 'dim7', label: 'dim7' }, { value: 'maj6', label: 'maj6' },
        { value: 'min6', label: 'm6' }, { value: 'dom7b9', label: '7b9' }, { value: 'dom7#9', label: '7#9' },
        { value: 'dom7b5', label: '7b5' }, { value: 'alt', label: 'alt' }, { value: 'dom7sus', label: '7sus' },
        { value: 'imaj7', label: 'm(maj7)' }, { value: 'maj', label: 'maj' }, { value: 'min', label: 'min' },
        { value: 'dim', label: 'dim' }, { value: 'aug', label: 'aug' }, { value: 'sus4', label: 'sus4' },
        { value: 'sus2', label: 'sus2' }
    ];
    return qualityDisplayOrder.map(q =>
        `<option value="${q.value}"${q.value === selectedQuality ? ' selected' : ''}>${q.label}</option>`
    ).join('');
}

/**
 * Creates HTML option elements for scales.
 * @param {string} [selectedScale='major'] - The scale to be pre-selected.
 * @returns {string} HTML string of option elements.
 */
function createScaleOptions(selectedScale = 'major') {
    return Object.keys(SCALES).map(scaleName => {
        const displayName = scaleName.replace(/([A-Z]+)/g, ' $1').replace(/([A-Z][a-z])/g, ' $1')
                                   .split(' ').map(s => s.charAt(0).toUpperCase() + s.substring(1)).join(' ').trim();
        return `<option value="${scaleName}"${scaleName === selectedScale ? ' selected' : ''}>${displayName}</option>`;
    }).join('');
}


// ==================================
// === AUDIO MANAGEMENT ===========
// ==================================
const AudioContextManager = { /* ... (AudioContextManager object remains the same as in index (98).html) ... */ };
// For brevity, I'm assuming AudioContextManager is unchanged from your file.
// Copy the full AudioContextManager object from your index (98).html here.
// Make sure it includes initialize, ensureAudioContext, loadInitialSounds,
// loadSecondarySounds, loadSingleSound, loadPianoSamplesSpecific,
// createDrumSound, and setupReverb.

// PASTE FULL AudioContextManager OBJECT HERE...
// (It's too long to repeat, assume it's the same as file index (98))
// Make sure it's the one with the fixed createDrumSound for 'woodblock' etc.
AudioContextManager.context = null;
AudioContextManager.soundBuffers = {};
AudioContextManager.pianoSampleBuffers = {};
AudioContextManager.reverbNode = null;
AudioContextManager.samplesLoaded = false;
AudioContextManager.reverbAmount = 0.2;
AudioContextManager.currentChordGain = null;
AudioContextManager.secondaryLoadStarted = false;
AudioContextManager.reverbNodeConnected = false;

AudioContextManager.initialize = async function() { /* ... */ };
AudioContextManager.ensureAudioContext = async function() { /* ... */ };
AudioContextManager.loadInitialSounds = async function() { /* ... */ };
AudioContextManager.loadSecondarySounds = async function() { /* ... */ };
AudioContextManager.loadSingleSound = async function(type, filename) { /* ... */ };
AudioContextManager.loadPianoSamplesSpecific = async function(octavesToLoad) { /* ... */ };
AudioContextManager.createDrumSound = async function(type) { /* ... */ };
AudioContextManager.setupReverb = async function() { /* ... */ };
// ... (End of placeholder for AudioContextManager)
// --- MAKE SURE TO PASTE THE FULL OBJECT FROM THE PREVIOUS FILE ---
// The placeholder above will not work, it's just to indicate where it goes.
// I will re-paste the actual AudioContextManager from the provided file to be safe.

AudioContextManager.initialize = async function() {
    if (this.context && this.context.state !== 'closed') {
        return this.context;
    }
    try {
        this.context = new (window.AudioContext || window.webkitAudioContext)();
        log("AudioContext created/resumed.");
        updateLoadingStatus("Loading essential sounds...", true);
        await this.loadInitialSounds(); 
        AppState.audioInitialized = true;
        log("AudioContextManager initial sounds loaded.");
        await this.setupReverb();

        if (this.context.state === 'suspended') {
            await this.context.resume(); 
            log("AudioContext resumed from suspended state.");
        }
        setTimeout(() => this.loadSecondarySounds(), 100);

    } catch (error) {
        console.error("Error initializing AudioContextManager:", error);
        alert("Failed to initialize audio. Please ensure your browser supports Web Audio API and allow autoplay if prompted.");
        AppState.audioInitialized = false;
        throw error; 
    }
    return this.context;
};
AudioContextManager.ensureAudioContext = async function() {
    if (!this.context || this.context.state === 'suspended') {
        return await this.initialize();
    }
    if (this.context.state === 'closed') {
        console.warn("AudioContext was closed, attempting to re-initialize.");
        return await this.initialize();
    }
    return this.context;
};
AudioContextManager.loadInitialSounds = async function() {
    try {
        const response = await fetch('./Click.wav');
        if (!response.ok) throw new Error(`HTTP error ${response.status} for Click.wav`);
        const arrayBuffer = await response.arrayBuffer();
        this.soundBuffers['click'] = await this.context.decodeAudioData(arrayBuffer);
        log("Successfully loaded Click.wav");
    } catch (e) {
        console.error("Failed to load Click.wav:", e);
        this.soundBuffers['click'] = await this.createDrumSound('click'); 
        log("Using synthetic fallback for click sound.");
    }
    await this.loadPianoSamplesSpecific(PLAYBACK_OCTAVES);
    this.samplesLoaded = Object.keys(this.pianoSampleBuffers).length > 0;
    if (this.samplesLoaded) {
        log(`Initial piano samples (Octaves ${PLAYBACK_OCTAVES.join(',')}) loaded.`);
    } else {
        console.warn(`Initial piano samples (Octaves ${PLAYBACK_OCTAVES.join(',')}) failed to load any samples.`);
    }
};
AudioContextManager.loadSecondarySounds = async function() {
    if (this.secondaryLoadStarted) return;
    this.secondaryLoadStarted = true;
    log("Starting secondary background sound loading...");
    updateLoadingStatus("Loading additional sounds...", true);

    const loadPromises = [];
    const soundsToLoad = {
        'woodblock': 'woodblock.wav', 'hihat': 'HiHat.wav', 
        'kick': 'Kick.wav', 'snare': 'Snare.wav'
    };
    for (let [type, filename] of Object.entries(soundsToLoad)) {
        if (!this.soundBuffers[type]) { 
            loadPromises.push(this.loadSingleSound(type, filename));
        }
    }
    const remainingOctaves = OCTAVES_FOR_SAMPLES.filter(o => !PLAYBACK_OCTAVES.includes(o));
    if (remainingOctaves.length > 0) {
        loadPromises.push(this.loadPianoSamplesSpecific(remainingOctaves));
    }
    await Promise.allSettled(loadPromises);
    log("Secondary background sound loading complete.");
    updateLoadingStatus("All sounds loaded.", true);
    setTimeout(() => updateLoadingStatus("", false), 1500);
};
AudioContextManager.loadSingleSound = async function(type, filename) {
    try {
        const response = await fetch(`./${filename}`);
        if (!response.ok) throw new Error(`HTTP error ${response.status} for ${filename}`);
        const arrayBuffer = await response.arrayBuffer();
        this.soundBuffers[type] = await this.context.decodeAudioData(arrayBuffer);
        log(`Successfully loaded secondary sound: ${filename}`);
    } catch (e) {
        console.error(`Failed to load secondary sound ${filename}:`, e);
        this.soundBuffers[type] = await this.createDrumSound(type); 
        log(`Using synthetic fallback for secondary sound: ${type}`);
    }
};
AudioContextManager.loadPianoSamplesSpecific = async function(octavesToLoad) {
    let loadedCount = 0;
    const promises = [];
    for (const note of ALL_NOTES_FOR_SAMPLES) { 
        for (const octave of octavesToLoad) {
            if (!OCTAVES_FOR_SAMPLES.includes(octave)) continue; 
            const sampleKey = `${note}${octave}`;
            if (this.pianoSampleBuffers[sampleKey]) continue; 

            const filename = getSampleFileName(note, octave);
            promises.push(
                fetch(filename)
                    .then(response => {
                        if (!response.ok) return Promise.reject(new Error(`HTTP error ${response.status} for ${filename}`));
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => this.context.decodeAudioData(arrayBuffer))
                    .then(buffer => {
                        this.pianoSampleBuffers[sampleKey] = buffer;
                        loadedCount++;
                    })
                    .catch(error => { /* console.warn(`Failed to load piano sample: ${filename}`, error.message); */ })
            );
        }
    }
    await Promise.allSettled(promises);
    if (loadedCount > 0) {
        log(`Loaded ${loadedCount} new piano samples for octaves: [${octavesToLoad.join(', ')}]`);
    }
    this.samplesLoaded = Object.keys(this.pianoSampleBuffers).length > 0;
};
AudioContextManager.createDrumSound = async function(type) { 
    const sampleRate = this.context.sampleRate;
    const duration = type === 'hihat' ? 0.05 : 0.2; 
    const buffer = this.context.createBuffer(1, sampleRate * duration, sampleRate);
    const data = buffer.getChannelData(0);
    let x;
    switch (type) {
        case 'click': 
            for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
            break;
        case 'hihat': 
            for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.01));
            break;
        case 'kick': 
            for (let i = 0; i < data.length; i++) {
                x = i / sampleRate;
                data[i] = Math.sin(2 * Math.PI * 100 * Math.exp(-x * 5) * x) * Math.exp(-x * 10) * 2; 
            }
            break;
        case 'snare': 
             for (let i = 0; i < data.length; i++) {
                x = i / sampleRate;
                data[i] = ((Math.random() * 2 - 1) + Math.sin(2 * Math.PI * 200 * x)) * Math.exp(-x * 10) * 1.5;
            }
            break;
        case 'woodblock': 
            for (let i = 0; i < data.length; i++) {
                x = i / sampleRate;
                data[i] = Math.sin(2 * Math.PI * 800 * x) * Math.exp(-x * 20);
            }
            break;
        default: 
            for (let i = 0; i < data.length; i++) data[i] = Math.sin(i * 0.05) * Math.exp(-i * 0.01);
    }
    return buffer;
};
AudioContextManager.setupReverb = async function() {
    if (!this.context) return;
    if (!this.reverbNode) {
        try {
            this.reverbNode = this.context.createConvolver();
            const sampleRate = this.context.sampleRate;
            const length = sampleRate * 2.5; 
            const impulse = this.context.createBuffer(2, length, sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5); 
                }
            }
            this.reverbNode.buffer = impulse;
            log("Reverb node created with synthetic impulse response.");

            if (this.context.destination && !this.reverbNodeConnected) {
                 this.reverbNode.connect(this.context.destination);
                 this.reverbNodeConnected = true;
                 log("Reverb node connected to destination.");
            }
        } catch (e) {
            console.error("Failed to create reverb node:", e);
            this.reverbNode = null; 
        }
    }
};


/**
 * Ensures audio context is initialized, typically on user interaction.
 */
async function ensureAudioInitializedUserInteraction() {
    if (!AppState.audioInitialized) {
        try {
            await AudioContextManager.initialize();
            log("Audio context initialized on user interaction.");
        } catch (e) {
            console.error('Audio initialization failed on user interaction:', e);
        }
    }
}

// ==================================
// === AUDIO PLAYBACK =============
// ==================================

/**
 * Plays a single note sample.
 * @param {string} noteNameWithOctave - e.g., "C4", "Db3".
 * @param {number} [volume=0.5] - Volume from 0 to 1.
 * @param {number} [duration=500] - Duration in milliseconds.
 */
function playNote(noteNameWithOctave, volume = 0.5, duration = 500) {
    if (!AudioContextManager.context || !AudioContextManager.samplesLoaded || !noteNameWithOctave) {
        return;
    }
    const match = noteNameWithOctave.match(/^([A-G][#bs]?)(\d)$/i);
    if (!match) {
        console.warn(`Invalid note format for playback: ${noteNameWithOctave}`);
        return;
    }
    let [, pitchClass, octaveStr] = match;
    const samplePitchClass = standardizeNoteNameForSamples(pitchClass);
    const octave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], parseInt(octaveStr)));
    const sampleKey = `${samplePitchClass}${octave}`;
    const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];

    if (!buffer) return;

    try {
        const source = AudioContextManager.context.createBufferSource();
        source.buffer = buffer;
        const gainNode = AudioContextManager.context.createGain();
        gainNode.gain.setValueAtTime(volume, AudioContextManager.context.currentTime);
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);
        source.start(AudioContextManager.context.currentTime);
        source.stop(AudioContextManager.context.currentTime + duration / 1000);
    } catch (e) {
        console.error('Error playing note:', e);
    }
}

/**
 * Plays a chord, potentially with two "hits" for longer durations.
 * @param {string} root - The root note of the chord.
 * @param {string} quality - The quality of the chord.
 * @param {number} startTime - The AudioContext time to start playback.
 * @param {number} duration - The total duration for this chord symbol.
 */
async function playChord(root, quality, startTime, duration) {
    if (!UI.elements.chordsEnabled.classList.contains('active') || !AudioContextManager.samplesLoaded) {
        return;
    }
    await AudioContextManager.ensureAudioContext();

    const baseNotesInRootPosition = getChordNotes(root, quality);
    if (!baseNotesInRootPosition || baseNotesInRootPosition.length === 0) {
        console.warn(`Cannot play chord for ${root}${quality}: No notes found.`);
        return;
    }

    const overallVolume = parseFloat(UI.elements.chordVolume.value) * 0.7;
    if (overallVolume <= 0) return;

    const firstVoicingNotes = getChordVoicing([...baseNotesInRootPosition], quality);
    
    if (AudioContextManager.currentChordGain) {
        try {
            AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, startTime);
            AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
        } catch (e) { console.warn("Error fading out previous chord gain:", e); }
    }

    const chordMasterGain = AudioContextManager.context.createGain();
    chordMasterGain.gain.setValueAtTime(0, startTime);
    chordMasterGain.gain.linearRampToValueAtTime(overallVolume, startTime + 0.02);
    chordMasterGain.connect(AudioContextManager.context.destination);
    AudioContextManager.currentChordGain = chordMasterGain;

    if (AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0) {
        const reverbDryWet = AudioContextManager.context.createGain();
        reverbDryWet.gain.value = AudioContextManager.reverbAmount;
        chordMasterGain.connect(reverbDryWet);
        reverbDryWet.connect(AudioContextManager.reverbNode);
        if (!AudioContextManager.reverbNodeConnected && AudioContextManager.context.destination) {
            AudioContextManager.reverbNode.connect(AudioContextManager.context.destination);
            AudioContextManager.reverbNodeConnected = true;
        }
    }

    /** Plays a single "hit" of the chord. */
    function playChordInstance(voicingNotes, instanceStartTime, instanceDuration, connectToGainNode) {
        const assignedNotesWithOctaves = voicingNotes.map((noteName, index) => {
            let octave = PLAYBACK_OCTAVES[0];
            if (index > 0 && PLAYBACK_OCTAVES.length > 1) {
                octave = PLAYBACK_OCTAVES[index % PLAYBACK_OCTAVES.length];
            }
            if (index > 0 && NOTES.indexOf(standardizeNoteName(noteName)) < NOTES.indexOf(standardizeNoteName(voicingNotes[0])) && PLAYBACK_OCTAVES.length > 1) {
                if (octave !== PLAYBACK_OCTAVES[PLAYBACK_OCTAVES.length - 1]) {
                    octave = PLAYBACK_OCTAVES[1] || PLAYBACK_OCTAVES[0];
                }
            }
            if (!OCTAVES_FOR_SAMPLES.includes(octave)) {
                octave = OCTAVES_FOR_SAMPLES.find(o => o >= PLAYBACK_OCTAVES[0]) || OCTAVES_FOR_SAMPLES[0];
            }
            octave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], octave));
            return { name: noteName, octave: octave };
        });

        assignedNotesWithOctaves.forEach(noteObj => {
            const samplePitchClass = standardizeNoteNameForSamples(noteObj.name);
            const finalSampleOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], noteObj.octave));
            const sampleKey = `${samplePitchClass}${finalSampleOctave}`;
            const buffer = AudioContextManager.pianoSampleBuffers[sampleKey];
            if (!buffer) return;

            const source = AudioContextManager.context.createBufferSource();
            source.buffer = buffer;
            source.connect(connectToGainNode);
            const timingVariance = Math.random() * 0.03;
            source.start(instanceStartTime + timingVariance);
            source.stop(instanceStartTime + instanceDuration + timingVariance);
        });
    }

    playChordInstance(firstVoicingNotes, startTime, duration / 2, chordMasterGain);

    const beatDurationSec = 60 / AppState.tempo;
    const timeSigNum = parseInt(UI.elements.timeSignature.value);
    const isLikelyFullMeasureChord = (timeSigNum === 4 && duration > (beatDurationSec * 2.5)) || (timeSigNum !== 4 && duration > (beatDurationSec * (timeSigNum / 2 + 0.5)));

    if (isLikelyFullMeasureChord) {
        const secondVoicingNotes = getChordVoicing([...baseNotesInRootPosition], quality);
        const secondHitStartTime = startTime + duration / 2;
        playChordInstance(secondVoicingNotes, secondHitStartTime, duration / 2, chordMasterGain);
    }
}
        
/**
 * Plays the metronome sound for the current beat.
 * @param {number} baseVolume - The base volume factor for this beat.
 */
async function playMetronomeSound(baseVolume) { 
    if (!AudioContextManager.context) return;

    const metronomeOverallVolume = parseFloat(UI.elements.metronomeVolume.value);
    const soundTypeSetting = UI.elements.soundType.value;
    const beatElement = UI.elements.beatsContainer.querySelector(`.beat[data-beat="${AppState.currentBeat}"]`);
    if (!beatElement) return;

    const soundsToPlayThisBeat = beatElement.dataset.sound.split(',');
    const beatSpecificVolumeFactor = parseFloat(beatElement.dataset.volume); 
    const isStrongBeatForAccent = parseFloat(beatElement.dataset.baseVolume) >= 0.9; 
    const accentMultiplier = isStrongBeatForAccent ? parseFloat(UI.elements.accentIntensity?.value || 1.0) : 1.0;

    for (let soundKey of soundsToPlayThisBeat) {
        soundKey = soundKey.trim();
        if (soundKey === 'silent') continue;

        let bufferToPlay;
        let effectiveSoundKey = soundKey;
        let soundSpecificMixLevel = 1.0;

        if (soundTypeSetting === 'drums') {
            const currentDrumSet = drumSoundSets[currentDrumSetIndex];
            let soundFilename;
            switch (soundKey) {
                case 'kick':
                    soundFilename = currentDrumSet.kick;
                    if (UI.elements.kickVolume) soundSpecificMixLevel = parseFloat(UI.elements.kickVolume.value);
                    break;
                case 'snare':
                    soundFilename = currentDrumSet.snare;
                    if (UI.elements.snareVolume) soundSpecificMixLevel = parseFloat(UI.elements.snareVolume.value);
                    break;
                case 'hihat':
                    soundFilename = currentDrumSet.hihat;
                    if (UI.elements.hihatVolume) soundSpecificMixLevel = parseFloat(UI.elements.hihatVolume.value);
                    break;
                default: 
                    effectiveSoundKey = 'click';
                    soundFilename = null; 
                    soundSpecificMixLevel = 1.0; 
                    break;
            }

            if (soundFilename) { 
                effectiveSoundKey = soundFilename; 
                if (!AudioContextManager.soundBuffers[soundFilename]) {
                    try {
                        const response = await fetch(`./${soundFilename}`);
                        if (!response.ok) throw new Error(`HTTP ${response.status} for ${soundFilename}`);
                        const arrayBuffer = await response.arrayBuffer();
                        AudioContextManager.soundBuffers[soundFilename] = await AudioContextManager.context.decodeAudioData(arrayBuffer);
                    } catch (e) {
                        console.error(`Failed to load drum sample ${soundFilename} on-the-fly:`, e);
                        bufferToPlay = AudioContextManager.soundBuffers[soundKey] || AudioContextManager.soundBuffers['click'];
                        effectiveSoundKey = soundKey; 
                    }
                }
                bufferToPlay = AudioContextManager.soundBuffers[soundFilename];
            } else { 
                 bufferToPlay = AudioContextManager.soundBuffers[effectiveSoundKey] || AudioContextManager.soundBuffers['click'];
            }
        } else { 
            effectiveSoundKey = soundTypeSetting; 
            bufferToPlay = AudioContextManager.soundBuffers[soundTypeSetting] || AudioContextManager.soundBuffers['click'];
            soundSpecificMixLevel = 1.0; 
        }

        if (!bufferToPlay) continue;

        let actualFinalVolume = metronomeOverallVolume * beatSpecificVolumeFactor * soundSpecificMixLevel * accentMultiplier;
        actualFinalVolume = Math.min(actualFinalVolume, 1.0); 

        if (actualFinalVolume <= 0.001) continue; 

        const source = AudioContextManager.context.createBufferSource();
        source.buffer = bufferToPlay;
        const gainNode = AudioContextManager.context.createGain();

        gainNode.gain.setValueAtTime(actualFinalVolume, AudioContextManager.context.currentTime);
        source.connect(gainNode);
        gainNode.connect(AudioContextManager.context.destination);

        if (soundTypeSetting === 'drums' && AudioContextManager.reverbNode && AudioContextManager.reverbAmount > 0.01) {
            const reverbSendGain = AudioContextManager.context.createGain();
            reverbSendGain.gain.setValueAtTime(0.05 * AudioContextManager.reverbAmount, AudioContextManager.context.currentTime); 
            gainNode.connect(reverbSendGain); 
            reverbSendGain.connect(AudioContextManager.reverbNode);
        }
        source.start(AudioContextManager.context.currentTime);
    }
}

// ==================================
// === FRETBOARD UI ===============
// ==================================

/**
 * Creates the basic structure of a fretboard (frets, strings, markers).
 * @param {HTMLElement} fretboardContainer - The div element to draw the fretboard in.
 * @param {string[]} tuningArray - Array of open string notes (low E to high E).
 */
function createFretboard(fretboardContainer, tuningArray) {
    if (!(fretboardContainer instanceof HTMLElement)) {
        console.error("Invalid fretboard container provided to createFretboard.");
        return;
    }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) {
        console.error("Invalid or empty tuning array provided to createFretboard.");
        return;
    }

    fretboardContainer.innerHTML = '';
    const numFrets = 12;
    const numStrings = tuningArray.length;

    const nutElement = document.createElement('div');
    nutElement.className = 'fret-line';
    nutElement.style.left = '0%';
    nutElement.style.width = '4px';
    nutElement.style.backgroundColor = '#4A3B31';
    nutElement.style.zIndex = '1';
    fretboardContainer.appendChild(nutElement);

    for (let i = 1; i <= numFrets; i++) {
        const fretLine = document.createElement('div');
        fretLine.className = 'fret-line';
        fretLine.style.left = `${(i / numFrets) * 100}%`;
        fretboardContainer.appendChild(fretLine);

        const fretNumber = document.createElement('div');
        fretNumber.className = 'fret-number';
        fretNumber.textContent = i;
        fretNumber.style.left = `${((i - 0.5) / numFrets) * 100}%`;
        fretboardContainer.appendChild(fretNumber);
    }

    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) {
        const stringLine = document.createElement('div');
        stringLine.className = 'string-line';
        // Low E (string 0) is visually at the bottom for typical diagrams.
        // High E (string numStrings-1) is visually at the top.
        const stringYPosition = (((numStrings - 1 - stringIndex) / (numStrings - 1)) * 96) + 2;
        stringLine.style.top = `${stringYPosition}%`;
        fretboardContainer.appendChild(stringLine);
    }

    const markerPositions = [3, 5, 7, 9, 12];
    markerPositions.forEach(fretPos => {
        const marker = document.createElement('div');
        marker.className = 'fret-marker';
        marker.style.left = `${((fretPos - 0.5) / numFrets) * 100}%`;
        if (fretPos === 12) {
            const topMarker = marker.cloneNode(true);
            topMarker.style.top = `33%`;
            fretboardContainer.appendChild(topMarker);
            marker.style.top = `67%`; // Bottom marker for 12th
        } else {
            marker.style.top = '50%';
        }
        fretboardContainer.appendChild(marker);
    });
}

/**
 * Updates the notes displayed on a fretboard based on a scale and tuning.
 * @param {HTMLElement} fretboardContainer - The fretboard div to update.
 * @param {string} rootNote - The root note of the scale.
 * @param {string} scaleName - The name of the scale.
 * @param {string[]} tuningArray - Array of open string notes (low E to high E).
 * @param {HTMLElement|null} [measureContext=null] - The specific measure or measure part providing context.
 */
function updateFretboardNotes(fretboardContainer, rootNote, scaleName, tuningArray, measureContext = null) {
    if (!(fretboardContainer instanceof HTMLElement)) { console.error('Invalid fretboardContainer'); return; }
    const standardizedRoot = standardizeNoteName(rootNote);
    if (!NOTES.includes(standardizedRoot)) { console.error(`Invalid scale root: ${rootNote}`); return; }
    const scaleData = SCALES[scaleName];
    if (!scaleData) { console.error(`Invalid scale: ${scaleName}`); return; }
    if (!Array.isArray(tuningArray) || tuningArray.length === 0) { console.error('Invalid tuning array'); return; }

    clearGuideToneHighlights();
    fretboardContainer.querySelectorAll('.note').forEach(el => el.remove());

    if (fretboardContainer.id === 'chord-fretboard' && UI.elements.scaleDisplay) {
        let displayScaleTypeName = scaleName;
        const tempScaleSelect = document.createElement('select');
        tempScaleSelect.innerHTML = createScaleOptions(scaleName);
        const selectedOptionEl = tempScaleSelect.querySelector(`option[value="${scaleName}"]`);
        displayScaleTypeName = selectedOptionEl ? selectedOptionEl.textContent : scaleName.replace(/([A-Z])/g, ' $1').split(' ').map(s => s.charAt(0).toUpperCase() + s.substring(1)).join(' ').trim();

        let chordRootForDisplay = "", chordQualityTextForDisplay = "";
        let actualMeasurePartContext = measureContext;
        if (measureContext && measureContext.classList.contains('measure')) {
            actualMeasurePartContext = measureContext.querySelector('.measure-part.part-active') || measureContext.querySelector('.measure-part');
        }

        if (actualMeasurePartContext) {
            chordRootForDisplay = actualMeasurePartContext.querySelector('.chord-controls .root-note')?.value;
            const chordQualityRaw = actualMeasurePartContext.querySelector('.chord-controls .chord-quality')?.value;
            const qualityOption = actualMeasurePartContext.querySelector(`.chord-controls .chord-quality option[value="${chordQualityRaw}"]`);
            chordQualityTextForDisplay = qualityOption ? qualityOption.textContent : (chordQualityRaw || "");
        } else {
            const firstMeasurePart = UI.elements.measures.children[0]?.querySelector('.measure-part');
            if (firstMeasurePart) {
                chordRootForDisplay = firstMeasurePart.querySelector('.chord-controls .root-note')?.value;
                const chordQualityRaw = firstMeasurePart.querySelector('.chord-controls .chord-quality')?.value;
                const qualityOption = firstMeasurePart.querySelector(`.chord-controls .chord-quality option[value="${chordQualityRaw}"]`);
                chordQualityTextForDisplay = qualityOption ? qualityOption.textContent : (chordQualityRaw || "");
            }
        }
        UI.elements.scaleDisplay.textContent = chordRootForDisplay && chordQualityTextForDisplay ?
            `${standardizedRoot} ${displayScaleTypeName} over ${chordRootForDisplay}${chordQualityTextForDisplay}` :
            `${standardizedRoot} ${displayScaleTypeName}`;
    }

    const rootIndex = NOTES.indexOf(standardizedRoot); 
    const notesInScale = scaleData.map(interval => NOTES[(rootIndex + interval) % 12]); 
    const numStrings = tuningArray.length;
    const numFrets = 12; 

    for (let stringIndex = 0; stringIndex < numStrings; stringIndex++) { // stringIndex 0 is low E
        const openStringNote = standardizeNoteName(tuningArray[stringIndex]);
        const openStringNoteIndex = NOTES.indexOf(openStringNote);
        if (openStringNoteIndex === -1) { console.warn(`Invalid open string: ${tuningArray[stringIndex]}`); continue; }

        const FNO_Key = `string${numStrings - stringIndex}`; // string6 for low E (stringIndex 0)

        for (let fret = 0; fret <= numFrets; fret++) {
            const currentNoteNameOnString = NOTES[(openStringNoteIndex + fret + 12) % 12];
            if (notesInScale.includes(currentNoteNameOnString)) {
                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                noteElement.textContent = currentNoteNameOnString;
                noteElement.style.left = (fret === 0) ? `-2%` : `${((fret - 0.5) / numFrets) * 100}%`;
                
                // Higher string index = higher visual position (lower number)
                const stringYPosition = (((numStrings - 1 - stringIndex) / (numStrings - 1)) * 96) + 2;
                noteElement.style.top = `${stringYPosition}%`;

                noteElement.style.backgroundColor = (currentNoteNameOnString === standardizedRoot) ? '#BD2031' : 
                    (notesInScale.indexOf(currentNoteNameOnString) % 2 === 0) ? '#006400' : '#4CAF50';
                
                let noteOctaveForPlayback = `${currentNoteNameOnString}3`;
                const isStandardGuitarTuning = tuningArray.length === 6 && tuningArray.join('') === "EADGBE"; // Assuming standard low to high
                if (isStandardGuitarTuning && FRETBOARD_NOTES_OCTAVES[FNO_Key] && fret < FRETBOARD_NOTES_OCTAVES[FNO_Key].length) {
                    noteOctaveForPlayback = FRETBOARD_NOTES_OCTAVES[FNO_Key][fret];
                } else {
                    let approxOctave = PLAYBACK_OCTAVES[0];
                    if (stringIndex >= numStrings * 2/3 ) approxOctave = PLAYBACK_OCTAVES[PLAYBACK_OCTAVES.length -1]; // Higher strings
                    else if (stringIndex >= numStrings / 3) approxOctave = PLAYBACK_OCTAVES[Math.floor(PLAYBACK_OCTAVES.length / 2)];
                    if (fret > 7 && approxOctave < OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1]) {
                        approxOctave = Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], approxOctave + 1);
                    }
                    approxOctave = Math.max(OCTAVES_FOR_SAMPLES[0], Math.min(OCTAVES_FOR_SAMPLES[OCTAVES_FOR_SAMPLES.length - 1], approxOctave));
                    noteOctaveForPlayback = `${currentNoteNameOnString}${approxOctave}`;
                }
                noteElement.dataset.note = noteOctaveForPlayback;

                noteElement.addEventListener('click', async (event) => {
                    event.stopPropagation(); 
                    await AudioContextManager.ensureAudioContext();
                    const volume = fretboardContainer.id.startsWith('fretflow-fretboard') ? 0.4 : parseFloat(UI.elements.chordFretboardVolume.value);
                    playNote(noteElement.dataset.note, volume, 500); 
                    noteElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                    setTimeout(() => {
                        const isHighlighted = noteElement.classList.contains('guide-tone-highlight') || noteElement.classList.contains('root-highlight-for-guides');
                        noteElement.style.transform = `translate(-50%, -50%) scale(${isHighlighted ? 0.95 : 1})`;
                    }, 150);
                });
                fretboardContainer.appendChild(noteElement);
            }
        }
    }
    if (AppState.guideTonesActive && fretboardContainer.id === 'chord-fretboard') {
        highlightGuideTones(measureContext);
    }
}

// ==================================
// === METRONOME UI & LOGIC =======
// ==================================

/**
 * Creates or recreates the metronome beat display elements.
 */
function createBeats() {
    const beatsContainer = UI.elements.beatsContainer;
    if (!beatsContainer) { console.error("Beats container not found"); return; }
    beatsContainer.innerHTML = '';

    const timeSignatureNum = parseInt(UI.elements.timeSignature.value);
    const soundType = UI.elements.soundType.value;
    let beatsToDisplay = timeSignatureNum;
    let subdivisionFactor = 1;

    if (timeSignatureNum === 4) {
        beatsToDisplay = 8; subdivisionFactor = 2;
    } else if ([2,3,6,7,8,12].includes(timeSignatureNum)) {
        subdivisionFactor = (timeSignatureNum === 6 || timeSignatureNum === 12) ? 3 : 1; // Typically 6/8 and 12/8 are felt in larger pulses
        beatsToDisplay = timeSignatureNum; // Display main beats, or subdivisions for compound if desired later
    }

    for (let i = 0; i < beatsToDisplay; i++) {
        const beatDiv = document.createElement('div');
        beatDiv.className = 'beat';
        beatDiv.dataset.beat = i;

        let beatLabel = `${Math.floor(i / subdivisionFactor) + 1}`;
        if (subdivisionFactor > 1 && (i % subdivisionFactor !== 0)) { // For 4/4, subdivisionFactor is 2
            if (timeSignatureNum === 4 && subdivisionFactor === 2) beatLabel += "&";
            // Add more specific labeling for compound meters if needed
        }
        beatDiv.innerHTML = beatLabel;

        let defaultSound = soundType === 'drums' ? 'hihat' : soundType;
        let baseVolume = 0.3;
        let color = '#4CAF50';

        // Default beat patterns
        if (timeSignatureNum === 4 && beatsToDisplay === 8) { // 4/4 with 8th notes
            if (i === 0 || i === 4) { baseVolume = 1.0; color = '#1F618D'; if (soundType === 'drums') defaultSound = 'kick,hihat'; }
            else if (i === 2 || i === 6) { baseVolume = 0.8; color = '#D9534F'; if (soundType === 'drums') defaultSound = 'snare,hihat'; }
            else { baseVolume = 0.2; color = '#9E9E9E'; if (soundType === 'drums') defaultSound = 'hihat'; else defaultSound = 'silent';}
        } else { // Other time signatures
            if (i === 0) { baseVolume = 1.0; color = '#1F618D'; if (soundType === 'drums') defaultSound = 'kick,hihat'; }
            else if ((timeSignatureNum === 6 && i === 3) || (timeSignatureNum === 12 && (i === 3 || i === 6 || i === 9))) {
                 baseVolume = 0.8; color = '#2ECC71'; if (soundType === 'drums') defaultSound = 'kick,hihat';
            }
            else { baseVolume = 0.3; color = '#9E9E9E'; if (soundType === 'drums') defaultSound = 'hihat'; }
        }

        beatDiv.dataset.sound = defaultSound;
        beatDiv.dataset.baseVolume = baseVolume;
        beatDiv.dataset.volume = baseVolume;
        beatDiv.style.backgroundColor = color;
        beatDiv.addEventListener('click', () => toggleBeatAccent(beatDiv, soundType, subdivisionFactor > 1 && (i % subdivisionFactor !== 0)));
        beatsContainer.appendChild(beatDiv);
    }
}

/**
 * Toggles the accent (sound and volume) of a metronome beat element.
 * @param {HTMLElement} beatElement - The beat div element.
 * @param {string} currentSoundType - The current global sound type ('click', 'drums', etc.).
 * @param {boolean} isSubdivision - Whether this beat is a subdivision (e.g., an '&' beat).
 */
function toggleBeatAccent(beatElement, currentSoundType, isSubdivision) {
    const currentVolume = parseFloat(beatElement.dataset.volume);
    let newVolume, newSound, newColor;

    if (currentSoundType === 'drums') {
        const drumCycle = [
            { sound: 'silent',      volume: 0,   color: '#666' },
            { sound: 'hihat',       volume: 0.3, color: '#9E9E9E' },
            { sound: 'snare,hihat', volume: 0.8, color: '#D9534F' },
            { sound: 'kick,hihat',  volume: 1.0, color: '#1F618D' }
        ];
        let currentIndex = drumCycle.findIndex(s => s.sound === beatElement.dataset.sound && Math.abs(s.volume - currentVolume) < 0.01);
        if (currentIndex === -1) currentIndex = 1; // Default to hihat if not found

        let nextIndex = (currentIndex + 1) % drumCycle.length;
        if (isSubdivision) {
            const currentIsHeavy = beatElement.dataset.sound.includes('kick') || beatElement.dataset.sound.includes('snare');
            let nextIsHeavy = drumCycle[nextIndex].sound.includes('kick') || drumCycle[nextIndex].sound.includes('snare');
            if (nextIsHeavy && !currentIsHeavy) { // Prevent adding kick/snare to light subdivision
                nextIndex = drumCycle.findIndex(s => s.sound === 'hihat') ?? 1;
            }
        }
        newSound = drumCycle[nextIndex].sound; newVolume = drumCycle[nextIndex].volume; newColor = drumCycle[nextIndex].color;
    } else {
        const simpleCycle = [
            { volume: 0,   sound: 'silent',         color: '#666' },
            { volume: 0.3, sound: currentSoundType, color: '#9E9E9E' },
            { volume: 1.0, sound: currentSoundType, color: '#1F618D' }
        ];
        let currentIndex = simpleCycle.findIndex(s => Math.abs(s.volume - currentVolume) < 0.01 && (s.sound === beatElement.dataset.sound || (s.sound === 'silent' && currentVolume === 0)));
        if (currentIndex === -1) currentIndex = (currentVolume > 0.5) ? 2 : (currentVolume > 0) ? 1 : 0;
        
        const nextState = simpleCycle[(currentIndex + 1) % simpleCycle.length];
        newVolume = nextState.volume; newSound = nextState.sound; newColor = nextState.color;
    }
    beatElement.dataset.volume = newVolume;
    beatElement.dataset.sound = newSound;
    beatElement.dataset.baseVolume = newVolume;
    beatElement.style.backgroundColor = newColor;
}

/**
 * Handles changes to the metronome instrument type selection.
 * @param {string} selectedInstrument - The newly selected instrument type.
 */
function onMetronomeInstrumentChange(selectedInstrument) {
    const showDrumsUI = selectedInstrument === "drums";
    if (UI.elements.drumSetToggleBtn) UI.elements.drumSetToggleBtn.style.display = showDrumsUI ? "inline-block" : "none";
    if (UI.elements.kickVolumeContainer) UI.elements.kickVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    if (UI.elements.snareVolumeContainer) UI.elements.snareVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    if (UI.elements.hihatVolumeContainer) UI.elements.hihatVolumeContainer.style.display = showDrumsUI ? "flex" : "none";
    createBeats();
}

// ==================================
// === PLAYBACK ENGINE ============
// ==================================

/**
 * Handles playback of a single beat, including metronome and chord.
 */
async function playBeat() {
    const beatsUI = UI.elements.beatsContainer.querySelectorAll('.beat');
    const measures = UI.elements.measures.children;
    if (beatsUI.length === 0) return;

    let measureToPlayIndex = AppState.currentMeasure;
    if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
        if (AppState.currentMeasure < AppState.loopStartMeasure || AppState.currentMeasure > AppState.loopEndMeasure) {
            AppState.currentMeasure = AppState.loopStartMeasure;
        }
        measureToPlayIndex = AppState.currentMeasure;
    }

    beatsUI.forEach(b => b.classList.remove('active'));
    const currentBeatElement = beatsUI[AppState.currentBeat];
    if (currentBeatElement) {
        currentBeatElement.classList.add('active');
        const volume = parseFloat(currentBeatElement.dataset.volume); 
        if (volume > 0 || (UI.elements.soundType.value === 'drums' && currentBeatElement.dataset.sound !== 'silent') ) { 
            await playMetronomeSound(volume); 
        }
    }

    if (measures.length > 0 && measureToPlayIndex < measures.length) {
        const currentMeasureElement = measures[measureToPlayIndex];
        Array.from(measures).forEach((m, idx) => m.classList.toggle('active', idx === measureToPlayIndex));
        
        const timeSigNum = parseInt(UI.elements.timeSignature.value);
        const isSplitMeasure = currentMeasureElement.dataset.isSplit === 'true';
        const is44Time = timeSigNum === 4;
        const numDisplayedBeats = beatsUI.length;

        let activePartIndex = 0;
        let playChordOnThisBeat = AppState.currentBeat === 0;

        if (is44Time && isSplitMeasure && numDisplayedBeats === 8) {
            activePartIndex = (AppState.currentBeat < 4) ? 0 : 1;
            playChordOnThisBeat = (AppState.currentBeat === 0 || AppState.currentBeat === 4);
        }
        
        currentMeasureElement.querySelectorAll('.measure-part').forEach((part, idx) => {
            part.classList.toggle('part-active', idx === activePartIndex);
        });

        const activeMeasurePart = currentMeasureElement.querySelectorAll('.measure-part')[activePartIndex];
        if (activeMeasurePart) {
            const root = activeMeasurePart.querySelector('.root-note')?.value;
            const quality = activeMeasurePart.querySelector('.chord-quality')?.value;
            const scaleRoot = activeMeasurePart.querySelector('.second-key')?.value;
            const scaleType = activeMeasurePart.querySelector('.scale-select')?.value;

            if (root && quality && scaleRoot && scaleType) {
                const tuning = TUNINGS[UI.elements.chordTuning.value];
                if (playChordOnThisBeat || (is44Time && isSplitMeasure && (AppState.currentBeat === 0 || AppState.currentBeat === 4))) {
                    updateFretboardNotes(UI.elements.chordFretboard, scaleRoot, scaleType, tuning, activeMeasurePart);
                    if (AppState.guideTonesActive) highlightGuideTones(activeMeasurePart);
                }

                if (playChordOnThisBeat) {
                    const beatDurationSec = 60 / AppState.tempo;
                    let chordPlayDurationSec = beatDurationSec * timeSigNum;
                    if (is44Time && numDisplayedBeats === 8) {
                         chordPlayDurationSec = beatDurationSec * (isSplitMeasure ? 2 : 4); 
                    }
                    await playChord(root, quality, AudioContextManager.context.currentTime, chordPlayDurationSec);
                }
            }
        }
    }

    AppState.currentBeat = (AppState.currentBeat + 1) % beatsUI.length;
    if (AppState.currentBeat === 0) { // End of displayed beats for the measure/subdivision
        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            AppState.currentMeasure = (AppState.currentMeasure >= AppState.loopEndMeasure) ? AppState.loopStartMeasure : AppState.currentMeasure + 1;
        } else if (measures.length > 0) {
            AppState.currentMeasure = (AppState.currentMeasure + 1) % measures.length;
        }
        updateNextChordDisplay();
    }
}

/**
 * Starts the metronome and chord playback.
 */
async function startPlayback() {
    try {
        await AudioContextManager.ensureAudioContext();
        if (AppState.isPlaying) return;

        const timeSignatureNumerator = parseInt(UI.elements.timeSignature.value);
        let intervalMs = (60 / AppState.tempo) * 1000;
        if (timeSignatureNumerator === 4 && UI.elements.beatsContainer.querySelectorAll('.beat').length === 8) {
            intervalMs /= 2;
        }

        AppState.currentBeat = 0;
        if (!AppState.intervalId) { // If starting fresh
            AppState.currentMeasure = (AppState.loopingActive && AppState.loopStartMeasure !== -1) ? AppState.loopStartMeasure : 0;
        }
        
        await playBeat(); // Play first beat immediately
        clearInterval(AppState.intervalId); // Clear any existing interval
        AppState.intervalId = setInterval(async () => { await playBeat(); }, intervalMs);

        AppState.updateState({ isPlaying: true });
        UI.elements.startStopButton.textContent = 'Stop';
        log("Playback started.");
    } catch (e) {
        console.error('Failed to start playback:', e);
        stopPlayback();
        alert("Error starting playback. Audio system might not be available.");
    }
}

/**
 * Stops the metronome and chord playback.
 */
function stopPlayback() {
    clearInterval(AppState.intervalId);
    AppState.intervalId = null;
    AppState.updateState({ isPlaying: false });

    UI.elements.beatsContainer.querySelectorAll('.beat.active').forEach(b => b.classList.remove('active'));
    UI.elements.measures.querySelectorAll('.measure.active').forEach(m => m.classList.remove('active'));
    UI.elements.measures.querySelectorAll('.measure-part.part-active').forEach(p => p.classList.remove('part-active'));

    if (AudioContextManager.currentChordGain && AudioContextManager.context) {
        try {
            const now = AudioContextManager.context.currentTime;
            if (AudioContextManager.currentChordGain.gain) {
                AudioContextManager.currentChordGain.gain.setValueAtTime(AudioContextManager.currentChordGain.gain.value, now);
                AudioContextManager.currentChordGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            }
        } catch (rampError) { console.warn("Gain ramp error on stop:", rampError.message); }
        finally { AudioContextManager.currentChordGain = null; }
    }
    if (UI.elements.nextChordDisplay) UI.elements.nextChordDisplay.textContent = "";
    UI.elements.startStopButton.textContent = 'Start';
    log("Playback stopped.");
}

// ==================================
// === PROGRESSION MANAGEMENT =====
// ==================================

/**
 * Updates the "Next Chord" display with up to 4 upcoming chords.
 * @param {number} [currentMeasureIndex=AppState.currentMeasure] - The index of the current measure.
 */
function updateNextChordDisplay(currentMeasureIndex = AppState.currentMeasure) {
    const nextChordDisplayElement = UI.elements.nextChordDisplay;
    if (!nextChordDisplayElement) return;

    const measures = UI.elements.measures.children;
    if (measures.length === 0) {
        nextChordDisplayElement.textContent = ""; return;
    }

    let upcomingChords = [];
    let displayCount = 0;
    let tempMeasureIdx = currentMeasureIndex;
    let tempPartIdx = 0;
    const displayedBeats = UI.elements.beatsContainer.querySelectorAll('.beat'); // Query DOM here

    const currentMeasureEl = measures[currentMeasureIndex];
    if (currentMeasureEl && currentMeasureEl.dataset.isSplit === 'true' && parseInt(UI.elements.timeSignature.value) === 4 && displayedBeats.length === 8) {
        if (AppState.currentBeat < 4) { // In first half of current split measure
            tempPartIdx = 1; // Next is second part of current measure
        } else { // In second half, so next is next measure's first part
            tempMeasureIdx = (currentMeasureIndex + 1);
            tempPartIdx = 0;
        }
    } else { // Not split, or not 4/4, or not 8th note display; advance to next measure
        tempMeasureIdx = (currentMeasureIndex + 1);
        tempPartIdx = 0;
    }

    while (displayCount < 4) {
        // Handle looping or wrapping around progression
        if (AppState.loopingActive && AppState.loopStartMeasure !== -1 && AppState.loopEndMeasure !== -1) {
            if (tempMeasureIdx > AppState.loopEndMeasure || tempMeasureIdx < AppState.loopStartMeasure) {
                tempMeasureIdx = AppState.loopStartMeasure;
                tempPartIdx = 0;
            }
        } else {
            if (tempMeasureIdx >= measures.length) {
                if (measures.length === 0) break; 
                tempMeasureIdx = 0; 
                tempPartIdx = 0;
            }
        }
        
        if (tempMeasureIdx >= measures.length) break; 

        const measureElement = measures[tempMeasureIdx];
        if (!measureElement) break;

        const measureParts = measureElement.querySelectorAll('.measure-part');
        const isSplit = measureElement.dataset.isSplit === 'true' && parseInt(UI.elements.timeSignature.value) === 4;

        for (let pIdx = tempPartIdx; pIdx < (isSplit ? 2 : 1) && displayCount < 4; pIdx++) {
            const partElement = measureParts[pIdx];
            if (!partElement) continue;

            const root = partElement.querySelector('.root-note')?.value;
            const qualityRaw = partElement.querySelector('.chord-quality')?.value;

            if (root && qualityRaw) {
                const qualityOption = partElement.querySelector(`.chord-quality option[value="${qualityRaw}"]`);
                const qualityDisplay = qualityOption ? qualityOption.textContent : qualityRaw;
                upcomingChords.push(`${root}${qualityDisplay}`);
                displayCount++;
            }
        }
        
        tempMeasureIdx++; // Advance to next measure index
        tempPartIdx = 0;  // Reset part index for the next measure

        // Break conditions
        if (displayCount >= 4) break;
        if (measures.length > 0 && tempMeasureIdx === currentMeasureIndex && !AppState.loopingActive && measures.length > 1 && upcomingChords.length >= measures.length * (isSplit ? 2:1) ) break; 
        if (AppState.loopingActive && tempMeasureIdx > AppState.loopEndMeasure && AppState.loopStartMeasure === AppState.loopEndMeasure && upcomingChords.length > 0) break;
    }

    nextChordDisplayElement.textContent = upcomingChords.length > 0 ? `Next: ${upcomingChords.join(', ')}` : "";
}

/**
 * Loads a selected chord progression into the measures display.
 * @param {string} progressionName - The key of the progression in the `progressions` object.
 * @param {string|null} [overrideKey=null] - An optional key to override the default.
 * @param {boolean} [isUserSong=false] - Whether this is a user-saved song.
 */
function loadProgression(progressionName, overrideKey = null, isUserSong = false) {
    const songTitleElem = UI.elements.currentSongTitleFretboard;
    const songDescElem = UI.elements.currentSongDescriptionFretboard;

    let progressionData;
    if (isUserSong) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        progressionData = userSongs[progressionName];
    } else {
        progressionData = progressions[progressionName];
    }

    if (!progressionName || !progressionData) {
        currentProgressionName = ""; currentFunctionalProgression = [];
        UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
        if (songTitleElem) songTitleElem.textContent = "";
        if (songDescElem) songDescElem.textContent = "";
        return;
    }

    currentProgressionName = progressionName;
    currentFunctionalProgression = progressionData.progression; // Raw strings from data
    const activeKey = overrideKey || progressionData.defaultKey || "C";

    if (songTitleElem) songTitleElem.textContent = progressionData.displayName || progressionName.replace(/_/g, ' ');
    if (songDescElem) songDescElem.textContent = progressionData.description || "";
    if (UI.elements.keySelect) UI.elements.keySelect.value = activeKey;

    UI.elements.measures.innerHTML = '';
    resetLoop();

    currentFunctionalProgression.forEach((rawChordString, index) => {
        const isSplitFromData = (isUserSong && progressionData.splitStatus && progressionData.splitStatus[index]) ||
                                (!isUserSong && rawChordString.includes('/')); // Stock songs imply split with '/'

        let partsData = [];
        if (isSplitFromData && rawChordString.includes('/')) {
            const partStrings = rawChordString.split('/');
            partStrings.forEach(partStr => {
                const parsed = parseRomanNumeralToAbsoluteChord(partStr.trim(), activeKey);
                partsData.push({ root: parsed.root, quality: parsed.quality, scaleRoot: parsed.root, scaleType: suggestScaleForQuality(parsed.quality) });
            });
        } else if (isUserSong && isSplitFromData && progressionData.parts && progressionData.parts[index]) {
            // User song saved with detailed parts structure
            progressionData.parts[index].forEach(pData => {
                 const parsed = parseRomanNumeralToAbsoluteChord(`${pData.root}${pData.quality}`, activeKey); // Re-parse for key
                 partsData.push({ root: parsed.root, quality: parsed.quality, scaleRoot: pData.scaleRoot, scaleType: pData.scaleType });
            });
        } else { // Single chord or non-split user song part
            const parsed = parseRomanNumeralToAbsoluteChord(rawChordString, activeKey);
            partsData.push({ root: parsed.root, quality: parsed.quality, scaleRoot: parsed.root, scaleType: suggestScaleForQuality(parsed.quality) });
            if (isSplitFromData && partsData.length === 1) { // Was marked split but only one part found, duplicate
                partsData.push({...partsData[0]});
            }
        }
        addMeasure(partsData[0].root, partsData[0].quality, partsData[0].scaleRoot, partsData[0].scaleType, isSplitFromData, partsData[1]);
    });

    updateMeasureNumbers();
    addFirstChordListener();
    updateNextChordDisplay(0);
    log(`Loaded ${isUserSong ? 'user song' : 'standard progression'}: ${progressionName} in key ${activeKey}`);
}

/**
 * Updates the entire progression when the key is changed.
 * @param {string} newKey - The new key to apply.
 */
function updateProgressionKey(newKey) {
    if (!currentFunctionalProgression || currentFunctionalProgression.length === 0) {
        if (UI.elements.measures.children.length === 0) { // No measures, just update default fretboard
            const tuning = TUNINGS[UI.elements.chordTuning.value];
            updateFretboardNotes(UI.elements.chordFretboard, newKey, 'major', tuning);
            if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = `${newKey} Major`;
        }
        return;
    }
    
    Array.from(UI.elements.measures.children).forEach((measureElement, measureIndex) => {
        if (measureIndex < currentFunctionalProgression.length) {
            const originalRawChordString = currentFunctionalProgression[measureIndex];
            const measurePartsUI = measureElement.querySelectorAll('.measure-part');
            const isSplit = measureElement.dataset.isSplit === 'true';
            const rawPartsStrings = isSplit && originalRawChordString.includes('/') ? 
                                    originalRawChordString.split('/').map(s => s.trim()) : [originalRawChordString];

            measurePartsUI.forEach((partElement, partIndex) => {
                let partOriginalString = rawPartsStrings[partIndex] || rawPartsStrings[0]; // Fallback
                // For user songs, if 'parts' data exists, use its originalRoman for re-parsing
                const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
                if (isUserSongCurrentlyLoaded() && userSongs[currentProgressionName]?.parts?.[measureIndex]?.[partIndex]?.originalRoman) {
                    partOriginalString = userSongs[currentProgressionName].parts[measureIndex][partIndex].originalRoman;
                }

                const parsedChord = parseRomanNumeralToAbsoluteChord(partOriginalString, newKey);
                partElement.querySelector('.root-note').value = parsedChord.root;
                partElement.querySelector('.chord-quality').value = parsedChord.quality;
                partElement.querySelector('.second-key').value = parsedChord.root;
                partElement.querySelector('.scale-select').value = suggestScaleForQuality(parsedChord.quality);
            });
        }
    });
    addFirstChordListener();
    updateNextChordDisplay();
    log(`Progression '${currentProgressionName}' re-keyed to: ${newKey}`);
}

// --- MEASURE MANIPULATION (ADD, REMOVE, SPLIT) ---

/**
 * Creates the HTML for a single part (half) of a measure.
 * @param {object} data - Chord and scale data for the part.
 * @param {number} [partIndex=0] - Index of the part (0 or 1).
 * @returns {string} HTML string for the measure part.
 */
function createMeasurePartHTML(data, partIndex = 0) {
    return `
        <div class="measure-part" data-part-index="${partIndex}">
            <div class="chord-controls">
                <select class="root-note">${createKeyOptions(data.root)}</select>
                <select class="chord-quality">${createQualityOptions(data.quality)}</select>
            </div>
            <div class="scale-controls">
                <select class="second-key">${createKeyOptions(data.scaleRoot)}</select>
                <select class="scale-select">${createScaleOptions(data.scaleType)}</select>
            </div>
        </div>`;
}

/**
 * Adds a new measure to the progression.
 * @param {string} [root='C']
 * @param {string} [quality='maj7']
 * @param {string} [scaleRoot='C']
 * @param {string} [scaleType='major']
 * @param {boolean} [isInitiallySplit=false]
 * @param {object|null} [secondPartData=null] - Data for the second part if split.
 */
function addMeasure(root = 'C', quality = 'maj7', scaleRoot = 'C', scaleType = 'major', 
                    isInitiallySplit = false, secondPartData = null) {
    const measuresContainer = UI.elements.measures;
    const newMeasureIndex = measuresContainer.children.length;

    const measureDiv = document.createElement('div');
    measureDiv.className = 'measure';
    measureDiv.dataset.measureIndex = newMeasureIndex;
    measureDiv.dataset.isSplit = isInitiallySplit ? 'true' : 'false';
    if (isInitiallySplit) measureDiv.classList.add('split-active');

    let measureHTML = `<div class="measure-header"><span class="measure-number">${newMeasureIndex + 1}</span></div>`;
    measureHTML += createMeasurePartHTML({ root, quality, scaleRoot, scaleType }, 0);
    if (isInitiallySplit) {
        const spData = secondPartData || { root, quality, scaleRoot, scaleType };
        measureHTML += createMeasurePartHTML(spData, 1);
    }
    measureHTML += `<div class="measure-footer"><button class="split-measure-button">${isInitiallySplit ? 'Unsplit' : 'Split'}</button></div>`;
    measureDiv.innerHTML = measureHTML;
    measuresContainer.appendChild(measureDiv);

    measureDiv.querySelectorAll('select').forEach(selectElement => {
        selectElement.addEventListener('change', (event) => {
            handleMeasureControlChange(event.target.closest('.measure-part'), event.target);
        });
    });
    
    measureDiv.querySelector('.measure-header').addEventListener('click', (event) => {
        if (event.target.tagName !== 'SELECT' && event.target.tagName !== 'BUTTON') {
            toggleMeasureLoopSelection(newMeasureIndex);
        }
    });
    
    const splitButton = measureDiv.querySelector('.split-measure-button');
    const is44Time = parseInt(UI.elements.timeSignature.value) === 4;
    splitButton.disabled = !is44Time;
    splitButton.title = is44Time ? "" : "Splitting measures only available in 4/4 time.";
    splitButton.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleSplitMeasure(measureDiv);
    });

    updateMeasureNumbers(); // Ensure all measure numbers and indices are correct
    if (newMeasureIndex === 0) addFirstChordListener();
    updateNextChordDisplay();
    log(`Added measure ${newMeasureIndex + 1}${isInitiallySplit ? ' (split)' : ''}`);
}

/**
 * Toggles a measure between being split (two parts) and unsplit (one part).
 * Only applicable in 4/4 time.
 * @param {HTMLElement} measureDiv - The measure div element.
 */
function toggleSplitMeasure(measureDiv) {
    if (parseInt(UI.elements.timeSignature.value) !== 4) {
        alert("Splitting measures is only available in 4/4 time.");
        return;
    }
    const isSplit = measureDiv.dataset.isSplit === 'true';
    const splitButton = measureDiv.querySelector('.split-measure-button');
    const firstPart = measureDiv.querySelector('.measure-part[data-part-index="0"]');

    if (isSplit) { // Unsplit
        measureDiv.querySelector('.measure-part[data-part-index="1"]')?.remove();
        measureDiv.dataset.isSplit = 'false';
        measureDiv.classList.remove('split-active');
        splitButton.textContent = 'Split';
    } else { // Split
        if (!firstPart) return;
        const firstPartData = {
            root: firstPart.querySelector('.root-note').value,
            quality: firstPart.querySelector('.chord-quality').value,
            scaleRoot: firstPart.querySelector('.second-key').value,
            scaleType: firstPart.querySelector('.scale-select').value
        };
        measureDiv.querySelector('.measure-footer').insertAdjacentHTML('beforebegin', createMeasurePartHTML(firstPartData, 1));
        const newSecondPart = measureDiv.querySelector('.measure-part[data-part-index="1"]');
        newSecondPart.querySelectorAll('select').forEach(select => {
            select.addEventListener('change', (e) => handleMeasureControlChange(e.target.closest('.measure-part'), e.target));
        });
        measureDiv.dataset.isSplit = 'true';
        measureDiv.classList.add('split-active');
        splitButton.textContent = 'Unsplit';
    }
    updateNextChordDisplay();
    const currentActiveMeasure = UI.elements.measures.querySelector('.measure.active');
    if (currentActiveMeasure === measureDiv) {
        const activePart = measureDiv.querySelector('.measure-part.part-active') || firstPart;
        if (activePart) handleMeasureControlChange(activePart, activePart.querySelector('select'));
    }
}

/**
 * Removes the last measure from the progression.
 */
function removeMeasure() {
    const measuresChildren = UI.elements.measures.children;
    if (measuresChildren.length > 0) {
        const removedMeasureIndex = measuresChildren.length - 1;
        if (AppState.loopStartMeasure === removedMeasureIndex || AppState.loopEndMeasure === removedMeasureIndex) {
            resetLoop(); // Reset loop if removed measure was part of it
        }
        // Adjust loop end if it's now beyond the last measure
        if (AppState.loopEndMeasure >= measuresChildren.length -1) {
            AppState.loopEndMeasure = Math.max(-1, measuresChildren.length - 2);
            if (AppState.loopStartMeasure > AppState.loopEndMeasure) AppState.loopStartMeasure = AppState.loopEndMeasure;
            if (AppState.loopStartMeasure === -1 && AppState.loopEndMeasure > -1) AppState.loopStartMeasure = AppState.loopEndMeasure; // single measure loop
             if (AppState.loopStartMeasure === -1 && AppState.loopEndMeasure === -1 && AppState.loopingActive) toggleLoopingMode(); // Turn off if no measures to loop
        }

        measuresChildren[measuresChildren.length - 1].remove();
        updateMeasureNumbers();
        if (measuresChildren.length > 0) {
            addFirstChordListener();
        } else {
            if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "Select a progression and key.";
            resetLoop(); // No measures, no loop
        }
        updateNextChordDisplay();
        log('Removed last measure');
    }
}

/**
 * Updates the displayed numbers on measures.
 */
function updateMeasureNumbers() {
    Array.from(UI.elements.measures.children).forEach((measure, index) => {
        measure.querySelector('.measure-number').textContent = index + 1;
        measure.dataset.measureIndex = index;
    });
}

/**
 * Handles changes in measure controls (chord root, quality, scale key, scale type).
 * @param {HTMLElement} measurePartDiv - The .measure-part div whose controls changed.
 * @param {HTMLElement} changedElement - The specific select element that triggered the change.
 */
function handleMeasureControlChange(measurePartDiv, changedElement) {
    const rootSelect = measurePartDiv.querySelector('.root-note');
    const qualitySelect = measurePartDiv.querySelector('.chord-quality');
    const scaleKeySelect = measurePartDiv.querySelector('.second-key');
    const scaleTypeSelect = measurePartDiv.querySelector('.scale-select');

    if (changedElement.classList.contains('root-note') || changedElement.classList.contains('chord-quality')) {
        scaleKeySelect.value = rootSelect.value;    
        scaleTypeSelect.value = suggestScaleForQuality(qualitySelect.value); 
    }

    updateFretboardNotes(
        UI.elements.chordFretboard,      
        scaleKeySelect.value,     
        scaleTypeSelect.value,    
        TUNINGS[UI.elements.chordTuning.value],
        measurePartDiv 
    );

    if (AppState.guideTonesActive) highlightGuideTones(measurePartDiv); 
    updateNextChordDisplay(); 
    const measureDiv = measurePartDiv.closest('.measure');
    log(`Measure ${parseInt(measureDiv.dataset.measureIndex) + 1}, Part ${measurePartDiv.dataset.partIndex} controls changed.`);
}

// ==================================
// === USER PROGRESSION SAVE/LOAD ===
// ==================================

/**
 * Saves the current progression in the measures to local storage.
 */
function saveCurrentProgression() {
    const measures = Array.from(UI.elements.measures.children);
    if (measures.length === 0) { alert("No progression to save!"); return; }

    let progressionName = prompt("Enter a name for this progression:", currentProgressionName || "My Custom Song");
    if (!progressionName || progressionName.trim() === "") { alert("Save cancelled or empty name provided."); return; }
    progressionName = progressionName.trim();

    const savedProgressionData = {
        progression: [], parts: [], splitStatus: [],
        defaultKey: UI.elements.keySelect.value,
        description: `User saved song - ${new Date().toLocaleDateString()}`,
        displayName: progressionName
    };

    measures.forEach(measureEl => {
        const isSplit = measureEl.dataset.isSplit === 'true';
        savedProgressionData.splitStatus.push(isSplit);
        const measurePartsData = [];
        let measureChordString = "";

        measureEl.querySelectorAll('.measure-part').forEach((partEl, partIdx) => {
            const root = partEl.querySelector('.root-note').value;
            const qualityValue = partEl.querySelector('.chord-quality').value;
            const qualityOption = partEl.querySelector(`.chord-quality option[value="${qualityValue}"]`);
            const qualityText = qualityOption ? qualityOption.textContent : qualityValue;
            
            measurePartsData.push({
                root: root, quality: qualityValue,
                scaleRoot: partEl.querySelector('.second-key').value,
                scaleType: partEl.querySelector('.scale-select').value,
                originalRoman: `${root}${qualityText}` // Store as absolute for re-parsing during key changes
            });
            if (partIdx > 0) measureChordString += " / ";
            measureChordString += `${root}${qualityText}`;
        });
        savedProgressionData.progression.push(measureChordString); // For simple re-keying of Roman numerals
        savedProgressionData.parts.push(measurePartsData); // For detailed structure
    });

    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    userSongs[progressionName] = savedProgressionData;
    localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));

    populateUserSongsDropdown();
    UI.elements.userProgressionSelect.value = progressionName;
    alert(`Progression "${progressionName}" saved!`);
    log(`User progression saved: ${progressionName}`);
    
    currentProgressionName = progressionName;
    currentFunctionalProgression = savedProgressionData.progression; 
}

/**
 * Checks if the currently loaded song is a user-saved song.
 * @returns {boolean} True if a user song is loaded.
 */
function isUserSongCurrentlyLoaded() {
    if (!currentProgressionName) return false;
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    return userSongs.hasOwnProperty(currentProgressionName);
}

/**
 * Populates the dropdown list of user-saved songs.
 */
function populateUserSongsDropdown() {
    const selectElement = UI.elements.userProgressionSelect;
    if (!selectElement) return;
    selectElement.innerHTML = '<option value="">-- Select a saved song --</option>';
    const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
    Object.keys(userSongs).sort().forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = userSongs[name].displayName || name;
        selectElement.appendChild(option);
    });
}

/**
 * Deletes the selected user-saved song from local storage.
 */
function deleteSelectedUserSong() {
    const selectedSongName = UI.elements.userProgressionSelect.value;
    if (!selectedSongName) { alert("Please select a saved song to delete."); return; }

    if (confirm(`Are you sure you want to delete "${selectedSongName}"? This cannot be undone.`)) {
        const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
        delete userSongs[selectedSongName];
        localStorage.setItem('userBebopProgressions', JSON.stringify(userSongs));
        populateUserSongsDropdown();
        if (currentProgressionName === selectedSongName) { // If deleted song was active
            UI.elements.measures.innerHTML = '<p>Select a progression.</p>';
            if(UI.elements.currentSongTitleFretboard) UI.elements.currentSongTitleFretboard.textContent = "";
            if(UI.elements.currentSongDescriptionFretboard) UI.elements.currentSongDescriptionFretboard.textContent = "";
            currentProgressionName = ""; currentFunctionalProgression = [];
            resetLoop();
        }
        alert(`Song "${selectedSongName}" deleted.`);
        log(`User song deleted: ${selectedSongName}`);
    }
}

// ==================================
// === LOOPER FUNCTIONALITY =======
// ==================================

/**
 * Toggles the loop selection state of a measure.
 * @param {number} measureIndex - The index of the measure to toggle.
 */
function toggleMeasureLoopSelection(measureIndex) {
    if (!AppState.loopingActive) {
        toggleLoopingMode();
        if (!AppState.loopingActive) return;
    }
    const measureElement = UI.elements.measures.children[measureIndex];
    if (!measureElement) return;

    measureElement.classList.toggle('loop-selected');
    const selectedIndices = Array.from(UI.elements.measures.children)
        .map((m, i) => m.classList.contains('loop-selected') ? i : -1)
        .filter(i => i !== -1).sort((a, b) => a - b);

    if (selectedIndices.length > 0) {
        AppState.loopStartMeasure = selectedIndices[0];
        AppState.loopEndMeasure = selectedIndices[selectedIndices.length - 1];
        Array.from(UI.elements.measures.children).forEach((m, i) => {
            m.classList.toggle('loop-selected', i >= AppState.loopStartMeasure && i <= AppState.loopEndMeasure);
        });
    } else {
        resetLoop();
    }
    log(`Loop range: ${AppState.loopStartMeasure} to ${AppState.loopEndMeasure}`);
}

/** Resets the loop selection. */
function resetLoop() {
    AppState.loopStartMeasure = -1; AppState.loopEndMeasure = -1;
    Array.from(UI.elements.measures.children).forEach(m => m.classList.remove('loop-selected'));
    log("Loop selection cleared.");
}

/** Toggles the overall looping mode ON or OFF. */
function toggleLoopingMode() {
    AppState.loopingActive = !AppState.loopingActive;
    UI.elements.loopSelectedToggle.textContent = AppState.loopingActive ? "Looping ON" : "Looping Off";
    UI.elements.loopSelectedToggle.classList.toggle('active', AppState.loopingActive);
    if (!AppState.loopingActive) resetLoop();
    else alert("Looping ON. Click measures to define loop range.");
    log(`Looping mode: ${AppState.loopingActive ? 'ON' : 'OFF'}`);
}

// ==================================
// === GUIDE TONES FUNCTIONALITY ==
// ==================================

/** Toggles guide tone highlighting ON or OFF. */
function toggleGuideTones() {
    AppState.guideTonesActive = !AppState.guideTonesActive;
    UI.elements.guideTonesToggle.textContent = AppState.guideTonesActive ? "Guide Tones ON" : "Guide Tones Off";
    UI.elements.guideTonesToggle.classList.toggle('active', AppState.guideTonesActive);
    
    const currentMeasureEl = UI.elements.measures.children[AppState.currentMeasure];
    const activePart = currentMeasureEl?.querySelector('.measure-part.part-active') || currentMeasureEl?.querySelector('.measure-part');
    
    if (AppState.guideTonesActive) highlightGuideTones(activePart);
    else clearGuideToneHighlights();
    log(`Guide tones: ${AppState.guideTonesActive ? 'ON' : 'OFF'}`);
}

/**
 * Highlights guide tones (3rd, 7th/6th) and the root on the main fretboard.
 * @param {HTMLElement|null} [activeMeasurePartContext=null] - The current active measure part.
 */
function highlightGuideTones(activeMeasurePartContext = null) {
    clearGuideToneHighlights();
    if (!AppState.guideTonesActive) return;

    let chordRootStr, chordQualityStr;
    if (activeMeasurePartContext) {
        chordRootStr = activeMeasurePartContext.querySelector('.root-note')?.value;
        chordQualityStr = activeMeasurePartContext.querySelector('.chord-quality')?.value;
    } else {
        const firstMeasurePart = UI.elements.measures.children[0]?.querySelector('.measure-part');
        if (!firstMeasurePart) return;
        chordRootStr = firstMeasurePart.querySelector('.root-note')?.value;
        chordQualityStr = firstMeasurePart.querySelector('.chord-quality')?.value;
    }

    if (!chordRootStr || !chordQualityStr) return;
    const chordRootNote = standardizeNoteName(chordRootStr);
    const chordIntervals = CHORD_INTERVALS[chordQualityStr];
    if (!chordIntervals) return;
    const rootNoteIndex = NOTES.indexOf(chordRootNote);
    if (rootNoteIndex === -1) return;

    const guideToneNotesSet = new Set();
    if (chordIntervals.includes(3)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 3) % 12]);
    else if (chordIntervals.includes(4)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 4) % 12]);
    
    if (chordQualityStr.includes('6')) {
        if (chordIntervals.includes(9)) guideToneNotesSet.add(NOTES[(rootNoteIndex + 9) % 12]);
    } else if (chordIntervals.includes(11)) {
        guideToneNotesSet.add(NOTES[(rootNoteIndex + 11) % 12]);
    } else if (chordIntervals.includes(10)) {
        guideToneNotesSet.add(NOTES[(rootNoteIndex + 10) % 12]);
    } else if (chordIntervals.includes(9) && chordQualityStr === 'dim7') {
         guideToneNotesSet.add(NOTES[(rootNoteIndex + 9) % 12]);
    }
    
    UI.elements.chordFretboard.querySelectorAll('.note').forEach(noteElement => {
        const noteName = noteElement.textContent;
        if (noteName === chordRootNote) noteElement.classList.add('root-highlight-for-guides');
        else if (guideToneNotesSet.has(noteName)) noteElement.classList.add('guide-tone-highlight');
    });
}

/** Clears all guide tone and root highlights from the fretboard. */
function clearGuideToneHighlights() {
    UI.elements.chordFretboard.querySelectorAll('.note').forEach(n => {
        n.classList.remove('guide-tone-highlight', 'root-highlight-for-guides');
        n.style.transform = 'translate(-50%, -50%) scale(1)'; // Reset scale
    });
}

// ==================================
// === FRETFLOW FUNCTIONALITY =====
// ==================================

/** Initializes the FretFlow section with multiple fretboards. */
function initializeFretFlow() {
    const fretboardsGrid = UI.elements.fretboardsGrid;
    if (!fretboardsGrid) { console.error("FretFlow grid not found."); return; }

    fretboardsGrid.innerHTML = ''; 
    for (let i = 0; i < 4; i++) {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'fretboard-section';
        sectionDiv.innerHTML = `
            <div class="fretboard-controls">
                <div class="control-group"><label for="ff-key-${i}">Key:</label><select id="ff-key-${i}" class="fretflow-key">${createKeyOptions()}</select></div>
                <div class="control-group"><label for="ff-scale-${i}">Scale:</label><select id="ff-scale-${i}" class="fretflow-scale">${createScaleOptions()}</select></div>
                <div class="control-group"><label for="ff-tuning-${i}">Tuning:</label><select id="ff-tuning-${i}" class="tuning-select">
                    <option value="standard">Std</option><option value="dropD">DropD</option><option value="openG">OpG</option>
                    <option value="DADGAD">DADGAD</option><option value="openE">OpE</option></select></div>
            </div>
            <div class="scale-display" id="ff-scale-display-${i}"></div>
            <div id="ff-fretboard-${i}" class="fretboard"></div>`;
        fretboardsGrid.appendChild(sectionDiv);

        const fretboardEl = sectionDiv.querySelector(`#ff-fretboard-${i}`);
        const keySelect = sectionDiv.querySelector(`#ff-key-${i}`);
        const scaleSelect = sectionDiv.querySelector(`#ff-scale-${i}`);
        const tuningSelect = sectionDiv.querySelector(`#ff-tuning-${i}`);
        const scaleDisplay = sectionDiv.querySelector(`#ff-scale-display-${i}`);

        const updateDisplay = () => {
            const tuningArr = TUNINGS[tuningSelect.value] || TUNINGS.standard;
            scaleDisplay.textContent = `${keySelect.value} ${scaleSelect.options[scaleSelect.selectedIndex].text}`;
            createFretboard(fretboardEl, tuningArr);
            updateFretboardNotes(fretboardEl, keySelect.value, scaleSelect.value, tuningArr);
        };
        [keySelect, scaleSelect, tuningSelect].forEach(el => el.addEventListener('change', updateDisplay));
        updateDisplay(); // Initial draw
    }
    log("FretFlow initialized.");
}

// ==================================
// === EVENT LISTENERS SETUP ======
// ==================================

/** Attaches an event listener to the first measure's scale controls to update the main fretboard. */
function addFirstChordListener() {
    const firstMeasurePart = UI.elements.measures.firstElementChild?.querySelector('.measure-part[data-part-index="0"]');
    if (firstMeasurePart) {
        const scaleRootSelect = firstMeasurePart.querySelector('.scale-controls .second-key');
        const scaleTypeSelect = firstMeasurePart.querySelector('.scale-controls .scale-select');
        const updateFunc = () => {
            if (scaleRootSelect && scaleTypeSelect && UI.elements.chordTuning) {
                updateFretboardNotes(UI.elements.chordFretboard, scaleRootSelect.value, scaleTypeSelect.value, TUNINGS[UI.elements.chordTuning.value], firstMeasurePart);
            }
        };
        updateFunc(); // Initial call
        // No need to re-add listeners if they are already on the elements from addMeasure
    } else { // No measures, show default on main fretboard
        updateFretboardNotes(UI.elements.chordFretboard, "C", "major", TUNINGS[UI.elements.chordTuning.value]);
        if (UI.elements.scaleDisplay) UI.elements.scaleDisplay.textContent = "C Major (Default)";
    }
}

/** Sets up all primary event listeners for the application. */
function setupEventListeners() {
    document.body.addEventListener('click', ensureAudioInitializedUserInteraction, { once: true });

    UI.elements.startStopButton.addEventListener('click', () => AppState.isPlaying ? stopPlayback() : startPlayback());
    UI.elements.drumSetToggleBtn?.addEventListener('click', () => {
        currentDrumSetIndex = (currentDrumSetIndex + 1) % drumSoundSets.length;
        UI.elements.drumSetToggleBtn.textContent = drumSoundSets[currentDrumSetIndex].name;
        log(`Drum set: ${drumSoundSets[currentDrumSetIndex].name}`);
    });
    UI.elements.soundType?.addEventListener('change', (e) => onMetronomeInstrumentChange(e.target.value));
    
    let currentDarkModeIndex = 0;
    const darkModeClasses = ['', 'dark-mode', 'dark-mode-2', 'dark-mode-3'];
    const activeToggleClasses = ['', 'active', 'active-2', 'active-3'];
    UI.elements.darkModeToggle.addEventListener('click', () => {
        currentDarkModeIndex = (currentDarkModeIndex + 1) % darkModeClasses.length;
        darkModeClasses.forEach(cls => { if (cls) document.body.classList.remove(cls); });
        activeToggleClasses.forEach(cls => { if (cls) UI.elements.darkModeToggle.classList.remove(cls); });
        if (currentDarkModeIndex > 0) {
            document.body.classList.add(darkModeClasses[currentDarkModeIndex]);
            UI.elements.darkModeToggle.classList.add(activeToggleClasses[currentDarkModeIndex]);
        }
        log(`Color mode: ${darkModeClasses[currentDarkModeIndex] || 'Light Mode'}`);
    });

    UI.elements.chordsEnabled.addEventListener('click', () => {
        const isActive = UI.elements.chordsEnabled.classList.toggle('active');
        UI.elements.chordsEnabled.textContent = isActive ? 'Chords Enabled' : 'Chords Disabled';
        log(`Chords ${isActive ? 'enabled' : 'disabled'}`);
    });

    UI.elements.tempo.addEventListener('input', () => {
        AppState.tempo = parseInt(UI.elements.tempo.value);
        UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
        if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
    });

    UI.elements.tapTempo.addEventListener('click', () => {
        const now = Date.now();
        AppState.tapTempoTimestamps.push(now);
        if (AppState.tapTempoTimestamps.length > 4) AppState.tapTempoTimestamps.shift();
        if (AppState.tapTempoTimestamps.length > 1) {
            let totalInterval = 0;
            for (let i = 1; i < AppState.tapTempoTimestamps.length; i++) totalInterval += AppState.tapTempoTimestamps[i] - AppState.tapTempoTimestamps[i-1];
            const avgInterval = totalInterval / (AppState.tapTempoTimestamps.length - 1);
            if (avgInterval > 0 && avgInterval < 3000) {
                AppState.tempo = Math.max(40, Math.min(220, Math.round(60000 / avgInterval)));
                UI.elements.tempo.value = AppState.tempo;
                UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
                if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
            }
        }
        setTimeout(() => { 
            if (AppState.tapTempoTimestamps.length > 0 && (Date.now() - AppState.tapTempoTimestamps[AppState.tapTempoTimestamps.length - 1] > 3000)) {
                AppState.tapTempoTimestamps = []; 
            }
        }, 3100);
    });

    UI.elements.timeSignature.addEventListener('change', () => {
        createBeats();
        const is44 = parseInt(UI.elements.timeSignature.value) === 4;
        document.querySelectorAll('.measure .split-measure-button').forEach(btn => {
            btn.disabled = !is44;
            btn.title = is44 ? "" : "Splitting only available in 4/4.";
            if (!is44 && btn.closest('.measure').dataset.isSplit === 'true') {
                toggleSplitMeasure(btn.closest('.measure')); 
            }
        });
        if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
    });

    UI.elements.reverbDial?.addEventListener('input', (e) => {
        AudioContextManager.reverbAmount = parseInt(e.target.value, 10) / 100;
        UI.elements.reverbDialValue.textContent = e.target.value;
        log(`Reverb: ${AudioContextManager.reverbAmount}`);
    });

    UI.elements.progressionSelect.addEventListener('change', (e) => {
        loadProgression(e.target.value, null, false);
        if (UI.elements.userProgressionSelect) UI.elements.userProgressionSelect.value = "";
    });
    UI.elements.userProgressionSelect?.addEventListener('change', (e) => {
        if (e.target.value) {
            const userSongs = JSON.parse(localStorage.getItem('userBebopProgressions') || '{}');
            loadProgression(e.target.value, userSongs[e.target.value]?.defaultKey || UI.elements.keySelect.value, true);
            if (UI.elements.progressionSelect) UI.elements.progressionSelect.value = "";
        }
    });
    UI.elements.keySelect.addEventListener('change', (e) => updateProgressionKey(e.target.value));
    UI.elements.chordTuning.addEventListener('change', () => { addFirstChordListener(); initializeFretFlow(); });
    UI.elements.saveProgressionButton?.addEventListener('click', saveCurrentProgression);
    UI.elements.deleteUserSongButton?.addEventListener('click', deleteSelectedUserSong);
    UI.elements.guideTonesToggle?.addEventListener('click', toggleGuideTones);
    UI.elements.loopSelectedToggle?.addEventListener('click', toggleLoopingMode);

    document.addEventListener('keydown', (event) => {
        const targetTagName = event.target.tagName.toLowerCase();
        if (['input', 'select', 'textarea'].includes(targetTagName)) return;
        let tempoChanged = false;
        switch (event.key) {
            case ' ': event.preventDefault(); UI.elements.startStopButton.click(); break;
            case 'ArrowUp':
                event.preventDefault();
                UI.elements.tempo.value = AppState.tempo = Math.min(220, parseInt(UI.elements.tempo.value) + 1);
                tempoChanged = true; break;
            case 'ArrowDown':
                event.preventDefault();
                UI.elements.tempo.value = AppState.tempo = Math.max(40, parseInt(UI.elements.tempo.value) - 1);
                tempoChanged = true; break;
        }
        if (tempoChanged) {
            UI.elements.tempoDisplay.textContent = `${AppState.tempo} BPM`;
            if (AppState.isPlaying) { stopPlayback(); startPlayback(); }
        }
    });
    log("Event listeners set up.");
}

// ==================================
// === INITIALIZATION =============
// ==================================

/** Initializes the application. */
async function initializeApp() {
    UI.init(); // Cache DOM elements first
    
    // Initial UI setup that depends on cached elements
    createBeats(); // Needs UI.elements.beatsContainer etc.
    const initialTuning = TUNINGS[UI.elements.chordTuning?.value || 'standard'] || TUNINGS.standard;
    createFretboard(UI.elements.chordFretboard, initialTuning);
    onMetronomeInstrumentChange(UI.elements.soundType?.value || 'click'); // Setup drum UI visibility
    populateUserSongsDropdown();

    // Load initial progression
    const initialProgressionName = UI.elements.progressionSelect?.value || Object.keys(progressions)[0];
    const initialKey = UI.elements.keySelect?.value || progressions[initialProgressionName]?.defaultKey || "C";
    loadProgression(initialProgressionName, initialKey, false); // This calls addFirstChordListener

    initializeFretFlow(); // Needs UI.elements.fretboardsGrid
    setupEventListeners(); // Setup all other interactive listeners

    try {
        await AudioContextManager.initialize();
    } catch (e) {
        updateLoadingStatus("Audio initialization failed. Click screen to retry.", true);
         // Add one-time click listener to body to re-attempt audio init
        document.body.addEventListener('click', async function retryAudioInit() {
            document.body.removeEventListener('click', retryAudioInit); // Remove self
            updateLoadingStatus("Retrying audio initialization...", true);
            try {
                await AudioContextManager.initialize();
                updateLoadingStatus("Audio initialized!", true);
                setTimeout(() => updateLoadingStatus("", false), 1500);
            } catch (err) {
                updateLoadingStatus("Audio retry failed. Please refresh or check browser settings.", true);
                 console.error("Audio retry failed:", err);
            }
        }, { once: true });
    }

    if (AppState.audioInitialized) { // Only show "App Initialized" if audio also worked
        updateLoadingStatus("Application initialized.", true);
        setTimeout(() => updateLoadingStatus("", false), 1500);
    }
    log("Application initialized.");
}

// --- DOM Ready Listener ---
document.addEventListener('DOMContentLoaded', () => {
    initializeApp().catch(error => {
        console.error("Application initialization failed:", error);
        updateLoadingStatus("Fatal Error: App could not initialize. Check console.", true);
    });
});

    </script>
</body>
</html>
